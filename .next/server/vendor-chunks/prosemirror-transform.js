"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-transform";
exports.ids = ["vendor-chunks/prosemirror-transform"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* binding */ AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* binding */ AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* binding */ AttrStep),\n/* harmony export */   DocAttrStep: () => (/* binding */ DocAttrStep),\n/* harmony export */   MapResult: () => (/* binding */ MapResult),\n/* harmony export */   Mapping: () => (/* binding */ Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* binding */ RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* binding */ RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* binding */ ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* binding */ ReplaceStep),\n/* harmony export */   Step: () => (/* binding */ Step),\n/* harmony export */   StepMap: () => (/* binding */ StepMap),\n/* harmony export */   StepResult: () => (/* binding */ StepResult),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   TransformError: () => (/* binding */ TransformError),\n/* harmony export */   canJoin: () => (/* binding */ canJoin),\n/* harmony export */   canSplit: () => (/* binding */ canSplit),\n/* harmony export */   dropPoint: () => (/* binding */ dropPoint),\n/* harmony export */   findWrapping: () => (/* binding */ findWrapping),\n/* harmony export */   insertPoint: () => (/* binding */ insertPoint),\n/* harmony export */   joinPoint: () => (/* binding */ joinPoint),\n/* harmony export */   liftTarget: () => (/* binding */ liftTarget),\n/* harmony export */   replaceStep: () => (/* binding */ replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) {\n    return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n    return value & lower16;\n}\nfunction recoverOffset(value) {\n    return (value - (value & lower16)) / factor16;\n}\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/ class MapResult {\n    /**\n    @internal\n    */ constructor(/**\n    The mapped version of the position.\n    */ pos, /**\n    @internal\n    */ delInfo, /**\n    @internal\n    */ recover){\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */ get deleted() {\n        return (this.delInfo & DEL_SIDE) > 0;\n    }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */ get deletedBefore() {\n        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n    /**\n    True when the token after the mapped position was deleted.\n    */ get deletedAfter() {\n        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */ get deletedAcross() {\n        return (this.delInfo & DEL_ACROSS) > 0;\n    }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/ class StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */ constructor(/**\n    @internal\n    */ ranges, /**\n    @internal\n    */ inverted = false){\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty) return StepMap.empty;\n    }\n    /**\n    @internal\n    */ recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted) for(let i = 0; i < index; i++)diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) {\n        return this._map(pos, assoc, false);\n    }\n    map(pos, assoc = 1) {\n        return this._map(pos, assoc, true);\n    }\n    /**\n    @internal\n    */ _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for(let i = 0; i < this.ranges.length; i += 3){\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos) break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple) return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */ touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for(let i = 0; i < this.ranges.length; i += 3){\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos) break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3) return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */ forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for(let i = 0, diff = 0; i < this.ranges.length; i += 3){\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */ invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */ toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */ static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [\n            0,\n            -n,\n            0\n        ] : [\n            0,\n            0,\n            n\n        ]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/ StepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/ class Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */ constructor(/**\n    The step maps in this mapping.\n    */ maps = [], /**\n    @internal\n    */ mirror, /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */ from = 0, /**\n    The end position in the `maps` array.\n    */ to = maps.length){\n        this.maps = maps;\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */ slice(from = 0, to = this.maps.length) {\n        return new Mapping(this.maps, this.mirror, from, to);\n    }\n    /**\n    @internal\n    */ copy() {\n        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */ appendMap(map, mirrors) {\n        this.to = this.maps.push(map);\n        if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */ appendMapping(mapping) {\n        for(let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++){\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */ getMirror(n) {\n        if (this.mirror) {\n            for(let i = 0; i < this.mirror.length; i++)if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];\n        }\n    }\n    /**\n    @internal\n    */ setMirror(n, m) {\n        if (!this.mirror) this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */ appendMappingInverted(mapping) {\n        for(let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--){\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */ invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */ map(pos, assoc = 1) {\n        if (this.mirror) return this._map(pos, assoc, true);\n        for(let i = this.from; i < this.to; i++)pos = this.maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */ mapResult(pos, assoc = 1) {\n        return this._map(pos, assoc, false);\n    }\n    /**\n    @internal\n    */ _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for(let i = this.from; i < this.to; i++){\n            let map = this.maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this.maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/ class Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */ getMap() {\n        return StepMap.empty;\n    }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */ merge(other) {\n        return null;\n    }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */ static fromJSON(schema, json) {\n        if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type) throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */ static jsonID(id, stepClass) {\n        if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/ class StepResult {\n    /**\n    @internal\n    */ constructor(/**\n    The transformed document, if successful.\n    */ doc, /**\n    The failure message, if unsuccessful.\n    */ failed){\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */ static ok(doc) {\n        return new StepResult(doc, null);\n    }\n    /**\n    Create a failed step result.\n    */ static fail(message) {\n        return new StepResult(null, message);\n    }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */ static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        } catch (e) {\n            if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for(let i = 0; i < fragment.childCount; i++){\n        let child = fragment.child(i);\n        if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline) child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/ class AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */ constructor(/**\n    The start of the marked range.\n    */ from, /**\n    The end of the marked range.\n    */ to, /**\n    The mark to add.\n    */ mark){\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent)=>{\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return {\n            stepType: \"addMark\",\n            mark: this.mark.toJSON(),\n            from: this.from,\n            to: this.to\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/ class RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */ constructor(/**\n    The start of the unmarked range.\n    */ from, /**\n    The end of the unmarked range.\n    */ to, /**\n    The mark to remove.\n    */ mark){\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node)=>{\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return {\n            stepType: \"removeMark\",\n            mark: this.mark.toJSON(),\n            from: this.from,\n            to: this.to\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/ class AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */ constructor(/**\n    The position of the target node.\n    */ pos, /**\n    The mark to add.\n    */ mark){\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node) return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for(let i = 0; i < node.marks.length; i++)if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return {\n            stepType: \"addNodeMark\",\n            pos: this.pos,\n            mark: this.mark.toJSON()\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/ class RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */ constructor(/**\n    The position of the target node.\n    */ pos, /**\n    The mark to remove.\n    */ mark){\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node) return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks)) return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return {\n            stepType: \"removeNodeMark\",\n            pos: this.pos,\n            mark: this.mark.toJSON()\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n/**\nReplace a part of the document with a slice of new content.\n*/ class ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */ constructor(/**\n    The start position of the replaced range.\n    */ from, /**\n    The end position of the replaced range.\n    */ to, /**\n    The slice to insert.\n    */ slice, /**\n    @internal\n    */ structure = false){\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([\n            this.from,\n            this.to - this.from,\n            this.slice.size\n        ]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross) return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        } else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = {\n            stepType: \"replace\",\n            from: this.from,\n            to: this.to\n        };\n        if (this.slice.size) json.slice = this.slice.toJSON();\n        if (this.structure) json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/ class ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */ constructor(/**\n    The start position of the replaced range.\n    */ from, /**\n    The end position of the replaced range.\n    */ to, /**\n    The start of preserved range.\n    */ gapFrom, /**\n    The end of preserved range.\n    */ gapTo, /**\n    The slice to insert.\n    */ slice, /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */ insert, /**\n    @internal\n    */ structure = false){\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd) return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted) return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([\n            this.from,\n            this.gapFrom - this.from,\n            this.insert,\n            this.gapTo,\n            this.to - this.gapTo,\n            this.slice.size - this.insert\n        ]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n        let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n        if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = {\n            stepType: \"replaceAround\",\n            from: this.from,\n            to: this.to,\n            gapFrom: this.gapFrom,\n            gapTo: this.gapTo,\n            insert: this.insert\n        };\n        if (this.slice.size) json.slice = this.slice.toJSON();\n        if (this.structure) json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while(dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount){\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while(dist > 0){\n            if (!next || next.isLeaf) return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent)=>{\n        if (!node.isInline) return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for(let i = 0; i < marks.length; i++){\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;\n                    else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start) adding.to = end;\n            else added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach((s)=>tr.step(s));\n    added.forEach((s)=>tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos)=>{\n        if (!node.isInline) return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n            let set = node.marks, found;\n            while(found = mark.isInSet(set)){\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        } else if (mark) {\n            if (mark.isInSet(node.marks)) toRemove = [\n                mark\n            ];\n        } else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for(let i = 0; i < toRemove.length; i++){\n                let style = toRemove[i], found;\n                for(let j = 0; j < matched.length; j++){\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style)) found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                } else {\n                    matched.push({\n                        style,\n                        from: Math.max(pos, from),\n                        to: end,\n                        step\n                    });\n                }\n            }\n        }\n    });\n    matched.forEach((m)=>tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for(let i = 0; i < node.childCount; i++){\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n        } else {\n            match = allowed;\n            for(let j = 0; j < child.marks.length; j++)if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n            if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n                let m, newline = /\\r?\\n|\\r/g, slice;\n                while(m = newline.exec(child.text)){\n                    if (!slice) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n                    replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n                }\n            }\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n    }\n    for(let i = replSteps.length - 1; i >= 0; i--)tr.step(replSteps[i]);\n}\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/ function liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for(let depth = range.depth;; --depth){\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n        if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n    for(let d = depth, splitting = false; d > target; d--)if (splitting || $from.index(d) > 0) {\n        splitting = true;\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n        openStart++;\n    } else {\n        start--;\n    }\n    let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n    for(let d = depth, splitting = false; d > target; d--)if (splitting || $to.after(d + 1) < $to.end(d)) {\n        splitting = true;\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n        openEnd++;\n    } else {\n        end++;\n    }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/ function findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner) return null;\n    return around.map(withAttrs).concat({\n        type: nodeType,\n        attrs\n    }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) {\n    return {\n        type,\n        attrs: null\n    };\n}\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around) return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside) return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for(let i = startIndex; innerMatch && i < endIndex; i++)innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd) return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for(let i = wrappers.length - 1; i >= 0; i--){\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd) throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos)=>{\n        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            let convertNewlines = null;\n            if (type.schema.linebreakReplacement) {\n                let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n                if (pre && !supportLinebreak) convertNewlines = false;\n                else if (!pre && supportLinebreak) convertNewlines = true;\n            }\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            if (convertNewlines === false) replaceLinebreaks(tr, node, pos, mapFrom);\n            clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n            if (convertNewlines === true) replaceNewlines(tr, node, pos, mapFrom);\n            return false;\n        }\n    });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset)=>{\n        if (child.isText) {\n            let m, newline = /\\r?\\n|\\r/g;\n            while(m = newline.exec(child.text)){\n                let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n                tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n            }\n        }\n    });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset)=>{\n        if (child.type == child.type.schema.linebreakReplacement) {\n            let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n            tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/ function setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node) throw new RangeError(\"No node at given position\");\n    if (!type) type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content)) throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/ function canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n    for(let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--){\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating) return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let overrideChild = typesAfter && typesAfter[i + 1];\n        if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n        let after = typesAfter && typesAfter[i] || node;\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest)) return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for(let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--){\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/ function canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && a.canAppend(b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/ function joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for(let d = $pos.depth;; d--){\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        } else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        } else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;\n        if (d == 0) break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);\n    tr.step(step);\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/ function insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;\n    if ($pos.parentOffset == 0) for(let d = $pos.depth - 1; d >= 0; d--){\n        let index = $pos.index(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);\n        if (index > 0) return null;\n    }\n    if ($pos.parentOffset == $pos.parent.content.size) for(let d = $pos.depth - 1; d >= 0; d--){\n        let index = $pos.indexAfter(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1);\n        if (index < $pos.node(d).childCount) return null;\n    }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/ function dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size) return pos;\n    let content = slice.content;\n    for(let i = 0; i < slice.openStart; i++)content = content.firstChild.content;\n    for(let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++){\n        for(let d = $pos.depth; d >= 0; d--){\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            } else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/ function replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (from == to && !slice.size) return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced){\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        for(let i = 0; i <= $from.depth; i++){\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for(let i = $from.depth; i > 0; i--)this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() {\n        return this.frontier.length - 1;\n    }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while(this.unplaced.size){\n            let fit = this.findFittable();\n            if (fit) this.placeNodes(fit);\n            else this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to) return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while(openStart && openEnd && content.childCount == 1){\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n        if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for(let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++){\n            let node = cur.firstChild;\n            if (cur.childCount > 1) openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for(let pass = 1; pass <= 2; pass++){\n            for(let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--){\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                } else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for(let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--){\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {\n                        sliceDepth,\n                        frontierDepth,\n                        parent,\n                        inject\n                    };\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) return {\n                        sliceDepth,\n                        frontierDepth,\n                        parent,\n                        wrap\n                    };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type)) break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf) return false;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        } else {\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while(this.depth > frontierDepth)this.closeFrontierNode();\n        if (wrap) for(let i = 0; i < wrap.length; i++)this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for(let i = 0; i < inject.childCount; i++)add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while(taken < fragment.childCount){\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches) break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) {\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd) openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for(let i = 0, cur = fragment; i < openEndCount; i++){\n            let node = cur.lastChild;\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt(node.childCount)\n            });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock) return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while(depth > 1 && after == this.$to.end(--depth))++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for(let i = Math.min(this.depth, $to.depth); i >= 0; i--){\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit) continue;\n            for(let d = i - 1; d >= 0; d--){\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount) continue scan;\n            }\n            return {\n                depth: i,\n                fit,\n                move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n            };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close) return null;\n        while(this.depth > close.depth)this.closeFrontierNode();\n        if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for(let d = close.depth + 1; d <= $to.depth; d++){\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n        this.frontier.push({\n            type,\n            match: type.contentMatch\n        });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0) return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for(let i = 0; i < depth; i++)fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0) return node;\n    let frag = node.content;\n    if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type)) return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for(let i = start; i < fragment.childCount; i++)if (!type.allowsMarks(fragment.child(i).marks)) return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size) return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for(let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--){\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating) break;\n        if (targetDepths.indexOf(d) > -1) preferredTarget = d;\n        else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for(let content = slice.content, i = 0;; i++){\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart) break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for(let d = preferredDepth - 1; d >= 0; d--){\n        let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = d;\n        else if (def || !leftNode.type.isTextblock) break;\n    }\n    for(let j = slice.openStart; j >= 0; j--){\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert) continue;\n        for(let i = 0; i < targetDepths.length; i++){\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for(let i = targetDepths.length - 1; i >= 0; i--){\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps) break;\n        let depth = targetDepths[i];\n        if (depth < 0) continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null) from = to = point;\n    }\n    tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for(let i = 0; i < covered.length; i++){\n        let depth = covered[i], last = i == covered.length - 1;\n        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for(let d = 1; d <= $from.depth && d <= $to.depth; d++){\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for(let d = minDepth; d >= 0; d--){\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;\n        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);\n    }\n    return result;\n}\n/**\nUpdate an attribute in a specific node.\n*/ class AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */ constructor(/**\n    The position of the target node.\n    */ pos, /**\n    The attribute to set.\n    */ attr, // The attribute's new value.\n    value){\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node) return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for(let name in node.attrs)attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return {\n            stepType: \"attr\",\n            pos: this.pos,\n            attr: this.attr,\n            value: this.value\n        };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\") throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n/**\nUpdate an attribute in the doc node.\n*/ class DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */ constructor(/**\n    The attribute to set.\n    */ attr, // The attribute's new value.\n    value){\n        super();\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let attrs = Object.create(null);\n        for(let name in doc.attrs)attrs[name] = doc.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = doc.type.create(attrs, doc.content, doc.marks);\n        return StepResult.ok(updated);\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n    map(mapping) {\n        return this;\n    }\n    toJSON() {\n        return {\n            stepType: \"docAttr\",\n            attr: this.attr,\n            value: this.value\n        };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.attr != \"string\") throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n        return new DocAttrStep(json.attr, json.value);\n    }\n}\nStep.jsonID(\"docAttr\", DocAttrStep);\n/**\n@internal\n*/ let TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/ class Transform {\n    /**\n    Create a transform that starts with the given document.\n    */ constructor(/**\n    The current document (the result of applying the steps in the\n    transform).\n    */ doc){\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */ this.steps = [];\n        /**\n        The documents before each of the steps.\n        */ this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */ this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */ get before() {\n        return this.docs.length ? this.docs[0] : this.doc;\n    }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */ step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed) throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */ maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed) this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */ get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */ addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */ replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step) this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */ replaceWith(from, to, content) {\n        return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */ delete(from, to) {\n        return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */ insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */ replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */ replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */ deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */ lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */ join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */ wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */ setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */ setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */ setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */ setDocAttribute(attr, value) {\n        this.step(new DocAttrStep(attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */ addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */ removeNodeMark(pos, mark) {\n        if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {\n            let node = this.doc.nodeAt(pos);\n            if (!node) throw new RangeError(\"No node at position \" + pos);\n            mark = mark.isInSet(node.marks);\n            if (!mark) return this;\n        }\n        this.step(new RemoveNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split.\n    */ split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */ addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */ removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */ clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGO0FBRWxGLCtEQUErRDtBQUMvRCxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLGtFQUFrRTtBQUNsRSxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG9FQUFvRTtBQUNwRSw4REFBOEQ7QUFDOUQsc0JBQXNCO0FBQ3RCLE1BQU1LLFVBQVU7QUFDaEIsTUFBTUMsV0FBV0MsS0FBS0MsR0FBRyxDQUFDLEdBQUc7QUFDN0IsU0FBU0MsWUFBWUMsS0FBSyxFQUFFQyxNQUFNO0lBQUksT0FBT0QsUUFBUUMsU0FBU0w7QUFBVTtBQUN4RSxTQUFTTSxhQUFhQyxLQUFLO0lBQUksT0FBT0EsUUFBUVI7QUFBUztBQUN2RCxTQUFTUyxjQUFjRCxLQUFLO0lBQUksT0FBTyxDQUFDQSxRQUFTQSxDQUFBQSxRQUFRUixPQUFNLENBQUMsSUFBS0M7QUFBVTtBQUMvRSxNQUFNUyxhQUFhLEdBQUdDLFlBQVksR0FBR0MsYUFBYSxHQUFHQyxXQUFXO0FBQ2hFOzs7QUFHQSxHQUNBLE1BQU1DO0lBQ0Y7O0lBRUEsR0FDQUMsWUFDQTs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7O0lBRUEsR0FDQUMsT0FBTyxFQUNQOztJQUVBLEdBQ0FDLE9BQU8sQ0FBRTtRQUNMLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtJQUNBOzs7O0lBSUEsR0FDQSxJQUFJQyxVQUFVO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQ0YsT0FBTyxHQUFHSixRQUFPLElBQUs7SUFBRztJQUN0RDs7SUFFQSxHQUNBLElBQUlPLGdCQUFnQjtRQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUNILE9BQU8sR0FBSVAsQ0FBQUEsYUFBYUUsVUFBUyxDQUFDLElB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QUNsRGlHLE9BQU9BLEtBQUswQixPQUFPLENBQUNyQixLQUFLSyxLQUFLO1lBQzlCLElBQUksQ0FBQ1YsTUFDRCxPQUFPLElBQUk7UUFDbkI7UUFDQSxJQUFJLENBQUN1RCxJQUFJLENBQUMsSUFBSTVCLG1CQUFtQjVILEtBQUtpRztRQUN0QyxPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7SUFNQSxHQUNBaUosTUFBTWxQLEdBQUcsRUFBRTBJLFFBQVEsQ0FBQyxFQUFFaUcsVUFBVSxFQUFFO1FBQzlCTyxNQUFNLElBQUksRUFBRWxQLEtBQUswSSxPQUFPaUc7UUFDeEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7SUFFQSxHQUNBNUYsUUFBUXRHLElBQUksRUFBRUMsRUFBRSxFQUFFdUQsSUFBSSxFQUFFO1FBQ3BCOEMsUUFBUSxJQUFJLEVBQUV0RyxNQUFNQyxJQUFJdUQ7UUFDeEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7SUFLQSxHQUNBd0QsV0FBV2hILElBQUksRUFBRUMsRUFBRSxFQUFFdUQsSUFBSSxFQUFFO1FBQ3ZCd0QsV0FBVyxJQUFJLEVBQUVoSCxNQUFNQyxJQUFJdUQ7UUFDM0IsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7SUFLQSxHQUNBK0Qsa0JBQWtCaEssR0FBRyxFQUFFaUssVUFBVSxFQUFFQyxLQUFLLEVBQUU7UUFDdENGLGtCQUFrQixJQUFJLEVBQUVoSyxLQUFLaUssWUFBWUM7UUFDekMsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUUwUyIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5qcz9iYTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcGxhY2VFcnJvciwgU2xpY2UsIEZyYWdtZW50LCBNYXJrVHlwZSwgTWFyayB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuLy8gUmVjb3ZlcnkgdmFsdWVzIGVuY29kZSBhIHJhbmdlIGluZGV4IGFuZCBhbiBvZmZzZXQuIFRoZXkgYXJlXG4vLyByZXByZXNlbnRlZCBhcyBudW1iZXJzLCBiZWNhdXNlIHRvbnMgb2YgdGhlbSB3aWxsIGJlIGNyZWF0ZWQgd2hlblxuLy8gbWFwcGluZywgZm9yIGV4YW1wbGUsIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY29yYXRpb25zLiBUaGUgbnVtYmVyJ3Ncbi8vIGxvd2VyIDE2IGJpdHMgcHJvdmlkZSB0aGUgaW5kZXgsIHRoZSByZW1haW5pbmcgYml0cyB0aGUgb2Zmc2V0LlxuLy9cbi8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGJpdCBzaGlmdCBvcGVyYXRvcnMgdG8gZW4tIGFuZFxuLy8gZGVjb2RlIHRoZXNlLCBzaW5jZSB0aG9zZSBjbGlwIHRvIDMyIGJpdHMsIHdoaWNoIHdlIG1pZ2h0IGluIHJhcmVcbi8vIGNhc2VzIHdhbnQgdG8gb3ZlcmZsb3cuIEEgNjQtYml0IGZsb2F0IGNhbiByZXByZXNlbnQgNDgtYml0XG4vLyBpbnRlZ2VycyBwcmVjaXNlbHkuXG5jb25zdCBsb3dlcjE2ID0gMHhmZmZmO1xuY29uc3QgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7IHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVySW5kZXgodmFsdWUpIHsgcmV0dXJuIHZhbHVlICYgbG93ZXIxNjsgfVxuZnVuY3Rpb24gcmVjb3Zlck9mZnNldCh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIC0gKHZhbHVlICYgbG93ZXIxNikpIC8gZmFjdG9yMTY7IH1cbmNvbnN0IERFTF9CRUZPUkUgPSAxLCBERUxfQUZURVIgPSAyLCBERUxfQUNST1NTID0gNCwgREVMX1NJREUgPSA4O1xuLyoqXG5BbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWFwcGVkIHBvc2l0aW9uIHdpdGggZXh0cmFcbmluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE1hcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbWFwcGVkIHZlcnNpb24gb2YgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRlbEluZm8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcikge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5kZWxJbmZvID0gZGVsSW5mbztcbiAgICAgICAgdGhpcy5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkLCB0aGF0IGlzLCB3aGV0aGVyIHRoZVxuICAgIHN0ZXAgcmVtb3ZlZCB0aGUgdG9rZW4gb24gdGhlIHNpZGUgcXVlcmllZCAodmlhIHRoZSBgYXNzb2NgKVxuICAgIGFyZ3VtZW50IGZyb20gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWQoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX1NJREUpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSB0b2tlbiBiZWZvcmUgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQmVmb3JlKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQkVGT1JFIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgdG9rZW4gYWZ0ZXIgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWZ0ZXIoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9BRlRFUiB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB3aGV0aGVyIGFueSBvZiB0aGUgc3RlcHMgbWFwcGVkIHRocm91Z2ggZGVsZXRlcyBhY3Jvc3MgdGhlXG4gICAgcG9zaXRpb24gKGluY2x1ZGluZyBib3RoIHRoZSB0b2tlbiBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uKS5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWNyb3NzKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9BQ1JPU1MpID4gMDsgfVxufVxuLyoqXG5BIG1hcCBkZXNjcmliaW5nIHRoZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgbWFkZSBieSBhIHN0ZXAsIHdoaWNoXG5jYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGVcbnByZS1zdGVwIHZlcnNpb24gb2YgYSBkb2N1bWVudCBhbmQgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGhlXG5wb3N0LXN0ZXAgdmVyc2lvbi5cbiovXG5jbGFzcyBTdGVwTWFwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwb3NpdGlvbiBtYXAuIFRoZSBtb2RpZmljYXRpb25zIHRvIHRoZSBkb2N1bWVudCBhcmVcbiAgICByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLCBpbiB3aGljaCBlYWNoIGdyb3VwIG9mIHRocmVlXG4gICAgcmVwcmVzZW50cyBhIG1vZGlmaWVkIGNodW5rIGFzIGBbc3RhcnQsIG9sZFNpemUsIG5ld1NpemVdYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGludmVydGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmIFN0ZXBNYXAuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaW52ZXJ0ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzW2luZGV4ICogM10gKyBkaWZmICsgcmVjb3Zlck9mZnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIG1hcChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSAhb2xkU2l6ZSA/IGFzc29jIDogcG9zID09IHN0YXJ0ID8gLTEgOiBwb3MgPT0gZW5kID8gMSA6IGFzc29jO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjb3ZlciA9IHBvcyA9PSAoYXNzb2MgPCAwID8gc3RhcnQgOiBlbmQpID8gbnVsbCA6IG1ha2VSZWNvdmVyKGkgLyAzLCBwb3MgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbCA9IHBvcyA9PSBzdGFydCA/IERFTF9BRlRFUiA6IHBvcyA9PSBlbmQgPyBERUxfQkVGT1JFIDogREVMX0FDUk9TUztcbiAgICAgICAgICAgICAgICBpZiAoYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZClcbiAgICAgICAgICAgICAgICAgICAgZGVsIHw9IERFTF9TSURFO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgZGVsLCByZWNvdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyArIGRpZmYgOiBuZXcgTWFwUmVzdWx0KHBvcyArIGRpZmYsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvdWNoZXMocG9zLCByZWNvdmVyKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kICYmIGkgPT0gaW5kZXggKiAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBlYWNoIG9mIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbmNsdWRlZCBpblxuICAgIHRoaXMgbWFwLlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSwgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLCBuZXdTdGFydCA9IHN0YXJ0ICsgKHRoaXMuaW52ZXJ0ZWQgPyAwIDogZGlmZik7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICAgICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXAuIFRoZSByZXN1bHQgY2FuIGJlIHVzZWQgdG9cbiAgICBtYXAgcG9zaXRpb25zIGluIHRoZSBwb3N0LXN0ZXAgZG9jdW1lbnQgdG8gdGhlIHByZS1zdGVwIGRvY3VtZW50LlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAodGhpcy5yYW5nZXMsICF0aGlzLmludmVydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwIHRoYXQgbW92ZXMgYWxsIHBvc2l0aW9ucyBieSBvZmZzZXQgYG5gICh3aGljaCBtYXkgYmVcbiAgICBuZWdhdGl2ZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIGFwcGx5aW5nIHN0ZXBzIG1lYW50IGZvciBhXG4gICAgc3ViLWRvY3VtZW50IHRvIGEgbGFyZ2VyIGRvY3VtZW50LCBvciB2aWNlLXZlcnNhLlxuICAgICovXG4gICAgc3RhdGljIG9mZnNldChuKSB7XG4gICAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG59XG4vKipcbkEgU3RlcE1hcCB0aGF0IGNvbnRhaW5zIG5vIGNoYW5nZWQgcmFuZ2VzLlxuKi9cblN0ZXBNYXAuZW1wdHkgPSBuZXcgU3RlcE1hcChbXSk7XG4vKipcbkEgbWFwcGluZyByZXByZXNlbnRzIGEgcGlwZWxpbmUgb2YgemVybyBvciBtb3JlIFtzdGVwXG5tYXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBNYXApLiBJdCBoYXMgc3BlY2lhbCBwcm92aXNpb25zIGZvciBsb3NzbGVzc2x5XG5oYW5kbGluZyBtYXBwaW5nIHBvc2l0aW9ucyB0aHJvdWdoIGEgc2VyaWVzIG9mIHN0ZXBzIGluIHdoaWNoIHNvbWVcbnN0ZXBzIGFyZSBpbnZlcnRlZCB2ZXJzaW9ucyBvZiBlYXJsaWVyIHN0ZXBzLiAoVGhpcyBjb21lcyB1cCB3aGVuXG7igJhbcmViYXNpbmddKC9kb2NzL2d1aWRlLyN0cmFuc2Zvcm0ucmViYXNpbmcp4oCZIHN0ZXBzIGZvclxuY29sbGFib3JhdGlvbiBvciBoaXN0b3J5IG1hbmFnZW1lbnQuKVxuKi9cbmNsYXNzIE1hcHBpbmcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBtYXBwaW5nIHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uIG1hcHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RlcCBtYXBzIGluIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtaXJyb3IsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgICBgbWFwUmVzdWx0YCBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICBmcm9tID0gMCwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICAgICovXG4gICAgdG8gPSBtYXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1hcHMgPSBtYXBzO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXBwaW5nIHRoYXQgbWFwcyBvbmx5IHRocm91Z2ggYSBwYXJ0IG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSA9IDAsIHRvID0gdGhpcy5tYXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLCB0aGlzLm1pcnJvciwgZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMuc2xpY2UoKSwgdGhpcy5taXJyb3IgJiYgdGhpcy5taXJyb3Iuc2xpY2UoKSwgdGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuICAgIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3JcbiAgICBpbWFnZSBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgICAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gICAgICAgIGlmIChtaXJyb3JzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbiAgICBtaXJyb3JpbmcgaW5mb3JtYXRpb24pLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoOyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbiAgICBnaXZlbiBvZmZzZXQsIGluIHRoaXMgbWFwcGluZyAoYXMgcGVyIHRoZSBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBgYXBwZW5kTWFwYCkuXG4gICAgKi9cbiAgICBnZXRNaXJyb3Iobikge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvcltpXSA9PSBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICAgIGlmICghdGhpcy5taXJyb3IpXG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMubWFwcy5sZW5ndGggKyBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgbGV0IGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgICAgICAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcChwb3MsIGFzc29jID0gMSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKVxuICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcsIHJldHVybmluZyBhIG1hcHBpbmdcbiAgICByZXN1bHQuXG4gICAgKi9cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkZWxJbmZvID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMubWFwc1tpXSwgcmVzdWx0ID0gbWFwLm1hcFJlc3VsdChwb3MsIGFzc29jKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBjb3JyO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbEluZm8gfD0gcmVzdWx0LmRlbEluZm87XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsSW5mbywgbnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5BIHN0ZXAgb2JqZWN0IHJlcHJlc2VudHMgYW4gYXRvbWljIGNoYW5nZS4gSXQgZ2VuZXJhbGx5IGFwcGxpZXNcbm9ubHkgdG8gdGhlIGRvY3VtZW50IGl0IHdhcyBjcmVhdGVkIGZvciwgc2luY2UgdGhlIHBvc2l0aW9uc1xuc3RvcmVkIGluIGl0IHdpbGwgb25seSBtYWtlIHNlbnNlIGZvciB0aGF0IGRvY3VtZW50LlxuXG5OZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG5vdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG5tZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG5KU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuW2BTdGVwLmpzb25JRGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxuKi9cbmNsYXNzIFN0ZXAge1xuICAgIC8qKlxuICAgIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuICAgIGFuZCB3aGljaCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlIG9sZFxuICAgIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0TWFwKCkgeyByZXR1cm4gU3RlcE1hcC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuICAgIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuICAgIHN0ZXBzIGNhbid0IGJlIG1lcmdlZC5cbiAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuICAgIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHN0ZXAgdHlwZSAke2pzb24uc3RlcFR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBzZXJpYWxpemUgc3RlcHMgdG8gSlNPTiwgZWFjaCBzdGVwIG5lZWRzIGEgc3RyaW5nXG4gICAgSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbiAgICByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuICAgIHRoYXQncyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIHN0ZXBzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG59XG4vKipcblRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbm5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG4qL1xuY2xhc3MgU3RlcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQsIGlmIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBmYWlsdXJlIG1lc3NhZ2UsIGlmIHVuc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGZhaWxlZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgb2soZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZmFpbGVkIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIGZhaWwobWVzc2FnZSkgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7IH1cbiAgICAvKipcbiAgICBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbiAgICBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuICAgIGZhaWxlZCBvbmUgaWYgaXQgdGhyb3dzIGEgYFJlcGxhY2VFcnJvcmAuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlcGxhY2UoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7XG4gICAgICAgIGlmIChjaGlsZC5pc0lubGluZSlcbiAgICAgICAgICAgIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICAgICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KG1hcHBlZCk7XG59XG4vKipcbkFkZCBhIG1hcmsgdG8gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBBZGRNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcy5tYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJlbW92ZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBub2RlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG4vKipcbkFkZCBhIG1hcmsgdG8gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEFkZE5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKG5ld1NldC5sZW5ndGggPT0gbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5tYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE5vZGVNYXJrXCIsIEFkZE5vZGVNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgUmVtb3ZlTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLm1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTm9kZU1hcmtcIiwgUmVtb3ZlTm9kZU1hcmtTdGVwKTtcblxuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgVGhlIGdpdmVuIGBzbGljZWAgc2hvdWxkIGZpdCB0aGUgJ2dhcCcgYmV0d2VlbiBgZnJvbWAgYW5kXG4gICAgYHRvYOKAlHRoZSBkZXB0aHMgbXVzdCBsaW5lIHVwLCBhbmQgdGhlIHN1cnJvdW5kaW5nIG5vZGVzIG11c3QgYmVcbiAgICBhYmxlIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBvcGVuIHNpZGVzIG9mIHRoZSBzbGljZS4gV2hlblxuICAgIGBzdHJ1Y3R1cmVgIGlzIHRydWUsIHRoZSBzdGVwIHdpbGwgZmFpbCBpZiB0aGUgY29udGVudCBiZXR3ZWVuXG4gICAgZnJvbSBhbmQgdG8gaXMgbm90IGp1c3QgYSBzZXF1ZW5jZSBvZiBjbG9zaW5nIGFuZCB0aGVuIG9wZW5pbmdcbiAgICB0b2tlbnMgKHRoaXMgaXMgdG8gZ3VhcmQgYWdhaW5zdCByZWJhc2VkIHJlcGxhY2Ugc3RlcHNcbiAgICBvdmVyd3JpdGluZyBzb21ldGhpbmcgdGhleSB3ZXJlbid0IHN1cHBvc2VkIHRvKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG5wcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuc2xpY2UuXG4qL1xuY2xhc3MgUmVwbGFjZUFyb3VuZFN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlLWFyb3VuZCBzdGVwIHdpdGggdGhlIGdpdmVuIHJhbmdlIGFuZCBnYXAuXG4gICAgYGluc2VydGAgc2hvdWxkIGJlIHRoZSBwb2ludCBpbiB0aGUgc2xpY2UgaW50byB3aGljaCB0aGUgY29udGVudFxuICAgIG9mIHRoZSBnYXAgc2hvdWxkIGJlIG1vdmVkLiBgc3RydWN0dXJlYCBoYXMgdGhlIHNhbWUgbWVhbmluZyBhc1xuICAgIGl0IGhhcyBpbiB0aGUgW2BSZXBsYWNlU3RlcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uUmVwbGFjZVN0ZXApIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBGcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcFRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICBpbnNlcnRlZC5cbiAgICAqL1xuICAgIGluc2VydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIGxldCBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICAgIGxldCBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsXG4gICAgICAgICAgICB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IHRoaXMuZnJvbSA9PSB0aGlzLmdhcEZyb20gPyBmcm9tLnBvcyA6IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpO1xuICAgICAgICBsZXQgZ2FwVG8gPSB0aGlzLnRvID09IHRoaXMuZ2FwVG8gPyB0by5wb3MgOiBtYXBwaW5nLm1hcCh0aGlzLmdhcFRvLCAxKTtcbiAgICAgICAgaWYgKChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcykgfHwgZ2FwRnJvbSA8IGZyb20ucG9zIHx8IGdhcFRvID4gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZnJvbS5wb3MsIHRvLnBvcywgZ2FwRnJvbSwgZ2FwVG8sIHRoaXMuc2xpY2UsIHRoaXMuaW5zZXJ0LCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byxcbiAgICAgICAgICAgIGdhcEZyb206IHRoaXMuZ2FwRnJvbSwgZ2FwVG86IHRoaXMuZ2FwVG8sIGluc2VydDogdGhpcy5pbnNlcnQgfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZUFyb3VuZFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBqc29uLmdhcEZyb20sIGpzb24uZ2FwVG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksIGpzb24uaW5zZXJ0LCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VBcm91bmRcIiwgUmVwbGFjZUFyb3VuZFN0ZXApO1xuZnVuY3Rpb24gY29udGVudEJldHdlZW4oZG9jLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCBkaXN0ID0gdG8gLSBmcm9tLCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICAgIHdoaWxlIChkaXN0ID4gMCAmJiBkZXB0aCA+IDAgJiYgJGZyb20uaW5kZXhBZnRlcihkZXB0aCkgPT0gJGZyb20ubm9kZShkZXB0aCkuY2hpbGRDb3VudCkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBkaXN0LS07XG4gICAgfVxuICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICBsZXQgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBkaXN0LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCByZW1vdmVkID0gW10sIGFkZGVkID0gW107XG4gICAgbGV0IHJlbW92aW5nLCBhZGRpbmc7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1hcmtzID0gbm9kZS5tYXJrcztcbiAgICAgICAgaWYgKCFtYXJrLmlzSW5TZXQobWFya3MpICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSBtYXJrLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmcgJiYgcmVtb3ZpbmcudG8gPT0gc3RhcnQgJiYgcmVtb3ZpbmcubWFyay5lcShtYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmluZy50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHJlbW92aW5nID0gbmV3IFJlbW92ZU1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmtzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGluZyAmJiBhZGRpbmcudG8gPT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgYWRkaW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2goYWRkaW5nID0gbmV3IEFkZE1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmspKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xuICAgIGFkZGVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IG1hdGNoZWQgPSBbXSwgc3RlcCA9IDA7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0ZXArKztcbiAgICAgICAgbGV0IHRvUmVtb3ZlID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBNYXJrVHlwZSkge1xuICAgICAgICAgICAgbGV0IHNldCA9IG5vZGUubWFya3MsIGZvdW5kO1xuICAgICAgICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbiAgICAgICAgICAgICAgICAodG9SZW1vdmUgfHwgKHRvUmVtb3ZlID0gW10pKS5wdXNoKGZvdW5kKTtcbiAgICAgICAgICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFyaykge1xuICAgICAgICAgICAgaWYgKG1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IFttYXJrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gbm9kZS5tYXJrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUgJiYgdG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHRvUmVtb3ZlW2ldLCBmb3VuZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtYXRjaGVkW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5zdGVwID09IHN0ZXAgLSAxICYmIHN0eWxlLmVxKG1hdGNoZWRbal0uc3R5bGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnN0ZXAgPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKHsgc3R5bGUsIGZyb206IE1hdGgubWF4KHBvcywgZnJvbSksIHRvOiBlbmQsIHN0ZXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgbWF0Y2hlZC5mb3JFYWNoKG0gPT4gdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSkpO1xufVxuZnVuY3Rpb24gY2xlYXJJbmNvbXBhdGlibGUodHIsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2ggPSBwYXJlbnRUeXBlLmNvbnRlbnRNYXRjaCwgY2xlYXJOZXdsaW5lcyA9IHRydWUpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgcmVwbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciwgZW5kLCBTbGljZS5lbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgICAgICAgaWYgKGNsZWFyTmV3bGluZXMgJiYgY2hpbGQuaXNUZXh0ICYmIHBhcmVudFR5cGUud2hpdGVzcGFjZSAhPSBcInByZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZywgc2xpY2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyZW50VHlwZS5zY2hlbWEudGV4dChcIiBcIiwgcGFyZW50VHlwZS5hbGxvd2VkTWFya3MoY2hpbGQubWFya3MpKSksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyICsgbS5pbmRleCwgY3VyICsgbS5pbmRleCArIG1bMF0ubGVuZ3RoLCBzbGljZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHJlcGxTdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdHIuc3RlcChyZXBsU3RlcHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG5jYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbltpc29sYXRpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbiovXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBsZXQgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICAgIGZvciAobGV0IGRlcHRoID0gcmFuZ2UuZGVwdGg7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICAgIGxldCB7ICRmcm9tLCAkdG8sIGRlcHRoIH0gPSByYW5nZTtcbiAgICBsZXQgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gICAgbGV0IHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcbiAgICBsZXQgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgbGV0IGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoZCArIDEpIDwgJHRvLmVuZChkKSkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxubm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxudGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbmNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbnVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuY29udGVudCBvZiBgcmFuZ2VgLlxuKi9cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzID0gbnVsbCwgaW5uZXJSYW5nZSA9IHJhbmdlKSB7XG4gICAgbGV0IGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBsZXQgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoIWlubmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpXG4gICAgICAgIC5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSwgYXR0cnMgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cbmZ1bmN0aW9uIHdpdGhBdHRycyh0eXBlKSB7IHJldHVybiB7IHR5cGUsIGF0dHJzOiBudWxsIH07IH1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoIWFyb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICBsZXQgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmICghaW5zaWRlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgbGV0IGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gd3JhcCh0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKHRyLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgIW5vZGUuaGFzTWFya3VwKHR5cGUsIGF0dHJzKSAmJiBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBjb252ZXJ0TmV3bGluZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZSA9IHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiLCBzdXBwb3J0TGluZWJyZWFrID0gISF0eXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUodHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICAgICAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRyLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlLCB1bmRlZmluZWQsIGNvbnZlcnROZXdsaW5lcyA9PT0gbnVsbCk7XG4gICAgICAgICAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRNID0gbWFwcGluZy5tYXAocG9zLCAxKSwgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpKSwgMCwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmVwbGFjZU5ld2xpbmVzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlTmV3bGluZXModHIsIG5vZGUsIHBvcywgbWFwRnJvbSkge1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nO1xuICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyAxICsgb2Zmc2V0ICsgbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQsIHN0YXJ0ICsgMSwgbm9kZS50eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudC5jcmVhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gY2hpbGQudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIDEgKyBvZmZzZXQpO1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQsIHN0YXJ0ICsgMSwgbm9kZS50eXBlLnNjaGVtYS50ZXh0KFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIHR5cGUpO1xufVxuLyoqXG5DaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbldoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiovXG5mdW5jdGlvbiBzZXROb2RlTWFya3VwKHRyLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXCIpO1xuICAgIGlmICghdHlwZSlcbiAgICAgICAgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBsZXQgbmV3Tm9kZSA9IHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBtYXJrcyB8fCBub2RlLm1hcmtzKTtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiB0ci5yZXBsYWNlV2l0aChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG5ld05vZGUpO1xuICAgIGlmICghdHlwZS52YWxpZENvbnRlbnQobm9kZS5jb250ZW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBwb3MgKyAxLCBwb3MgKyBub2RlLm5vZGVTaXplIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obmV3Tm9kZSksIDAsIDApLCAxLCB0cnVlKSk7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgc3BsaXR0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBhbGxvd2VkLlxuKi9cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gICAgbGV0IGlubmVyVHlwZSA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbdHlwZXNBZnRlci5sZW5ndGggLSAxXSkgfHwgJHBvcy5wYXJlbnQ7XG4gICAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fFxuICAgICAgICAhaW5uZXJUeXBlLnR5cGUudmFsaWRDb250ZW50KCRwb3MucGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleCgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMSwgaSA9IGRlcHRoIC0gMjsgZCA+IGJhc2U7IGQtLSwgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlKGQpLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCByZXN0ID0gbm9kZS5jb250ZW50LmN1dEJ5SW5kZXgoaW5kZXgsIG5vZGUuY2hpbGRDb3VudCk7XG4gICAgICAgIGxldCBvdmVycmlkZUNoaWxkID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2kgKyAxXTtcbiAgICAgICAgaWYgKG92ZXJyaWRlQ2hpbGQpXG4gICAgICAgICAgICByZXN0ID0gcmVzdC5yZXBsYWNlQ2hpbGQoMCwgb3ZlcnJpZGVDaGlsZC50eXBlLmNyZWF0ZShvdmVycmlkZUNoaWxkLmF0dHJzKSk7XG4gICAgICAgIGxldCBhZnRlciA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV0pIHx8IG5vZGU7XG4gICAgICAgIGlmICghbm9kZS5jYW5SZXBsYWNlKGluZGV4ICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihiYXNlKTtcbiAgICBsZXQgYmFzZVR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbMF07XG4gICAgcmV0dXJuICRwb3Mubm9kZShiYXNlKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGJhc2VUeXBlID8gYmFzZVR5cGUudHlwZSA6ICRwb3Mubm9kZShiYXNlICsgMSkudHlwZSk7XG59XG5mdW5jdGlvbiBzcGxpdCh0ciwgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyksIGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBhZnRlciA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoLCBlID0gJHBvcy5kZXB0aCAtIGRlcHRoLCBpID0gZGVwdGggLSAxOyBkID4gZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkcG9zLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgbGV0IHR5cGVBZnRlciA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXTtcbiAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKHR5cGVBZnRlciA/IHR5cGVBZnRlci50eXBlLmNyZWF0ZSh0eXBlQWZ0ZXIuYXR0cnMsIGFmdGVyKSA6ICRwb3Mubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHBvcywgcG9zLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIGRlcHRoLCBkZXB0aCksIHRydWUpKTtcbn1cbi8qKlxuVGVzdCB3aGV0aGVyIHRoZSBibG9ja3MgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIHBvc2l0aW9uIGNhbiBiZVxuam9pbmVkLlxuKi9cbmZ1bmN0aW9uIGNhbkpvaW4oZG9jLCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiBqb2luYWJsZSgkcG9zLm5vZGVCZWZvcmUsICRwb3Mubm9kZUFmdGVyKSAmJlxuICAgICAgICAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICAgIHJldHVybiAhIShhICYmIGIgJiYgIWEuaXNMZWFmICYmIGEuY2FuQXBwZW5kKGIpKTtcbn1cbi8qKlxuRmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdCBjYW4gYmUgam9pbmVkIHRvIHRoZVxuYmxvY2sgYmVmb3JlIChvciBhZnRlciBpZiBgZGlyYCBpcyBwb3NpdGl2ZSkuIFJldHVybnMgdGhlIGpvaW5hYmxlXG5wb2ludCwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcywgZGlyID0gLTEpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKGQgPT0gJHBvcy5kZXB0aCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlICYmICFiZWZvcmUuaXNUZXh0YmxvY2sgJiYgam9pbmFibGUoYmVmb3JlLCBhZnRlcikgJiZcbiAgICAgICAgICAgICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBkaXIgPCAwID8gJHBvcy5iZWZvcmUoZCkgOiAkcG9zLmFmdGVyKGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW4odHIsIHBvcywgZGVwdGgpIHtcbiAgICBsZXQgc3RlcCA9IG5ldyBSZXBsYWNlU3RlcChwb3MgLSBkZXB0aCwgcG9zICsgZGVwdGgsIFNsaWNlLmVtcHR5LCB0cnVlKTtcbiAgICB0ci5zdGVwKHN0ZXApO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHBvaW50IHdoZXJlIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSBjYW4gYmUgaW5zZXJ0ZWRcbm5lYXIgYHBvc2AsIGJ5IHNlYXJjaGluZyB1cCB0aGUgbm9kZSBoaWVyYXJjaHkgd2hlbiBgcG9zYCBpdHNlbGZcbmlzbid0IGEgdmFsaWQgcGxhY2UgYnV0IGlzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBub2RlLiBSZXR1cm5cbm51bGwgaWYgbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGluc2VydFBvaW50KGRvYywgcG9zLCBub2RlVHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoJHBvcy5pbmRleCgpLCAkcG9zLmluZGV4KCksIG5vZGVUeXBlKSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gMClcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYmVmb3JlKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gJHBvcy5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8ICRwb3Mubm9kZShkKS5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkZpbmRzIGEgcG9zaXRpb24gYXQgb3IgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aGVyZSB0aGUgZ2l2ZW5cbnNsaWNlIGNhbiBiZSBpbnNlcnRlZC4gV2lsbCBsb29rIGF0IHBhcmVudCBub2RlcycgbmVhcmVzdCBib3VuZGFyeVxuYW5kIHRyeSB0aGVyZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2Fzbid0IGRpcmVjdGx5IGF0IHRoZVxuc3RhcnQgb3IgZW5kIG9mIHRoYXQgbm9kZS4gUmV0dXJucyBudWxsIHdoZW4gbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGRyb3BQb2ludChkb2MsIHBvcywgc2xpY2UpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFzbGljZS5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2Uub3BlblN0YXJ0OyBpKyspXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBkID09ICRwb3MuZGVwdGggPyAwIDogJHBvcy5wb3MgPD0gKCRwb3Muc3RhcnQoZCArIDEpICsgJHBvcy5lbmQoZCArIDEpKSAvIDIgPyAtMSA6IDE7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0UG9zID0gJHBvcy5pbmRleChkKSArIChiaWFzID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCksIGZpdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwYXNzID09IDEpIHtcbiAgICAgICAgICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgICAgICAgICBmaXRzID0gd3JhcHBpbmcgJiYgcGFyZW50LmNhblJlcGxhY2VXaXRoKGluc2VydFBvcywgaW5zZXJ0UG9zLCB3cmFwcGluZ1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlhcyA9PSAwID8gJHBvcy5wb3MgOiBiaWFzIDwgMCA/ICRwb3MuYmVmb3JlKGQgKyAxKSA6ICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbuKAmEZpdOKAmSBhIHNsaWNlIGludG8gYSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHByb2R1Y2luZyBhXG5bc3RlcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSB0aGF0IGluc2VydHMgaXQuIFdpbGwgcmV0dXJuIG51bGwgaWZcbnRoZXJlJ3Mgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gaW5zZXJ0IHRoZSBzbGljZSBoZXJlLCBvciBpbnNlcnRpbmcgaXRcbndvdWxkIGJlIGEgbm8tb3AgKGFuIGVtcHR5IHNsaWNlIG92ZXIgYW4gZW1wdHkgcmFuZ2UpLlxuKi9cbmZ1bmN0aW9uIHJlcGxhY2VTdGVwKGRvYywgZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgaWYgKGZyb20gPT0gdG8gJiYgIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSBkb2MucmVzb2x2ZSh0byk7XG4gICAgLy8gT3B0aW1pemF0aW9uIC0tIGF2b2lkIHdvcmsgaWYgaXQncyBvYnZpb3VzIHRoYXQgaXQncyBub3QgbmVlZGVkLlxuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpO1xuICAgIHJldHVybiBuZXcgRml0dGVyKCRmcm9tLCAkdG8sIHNsaWNlKS5maXQoKTtcbn1cbmZ1bmN0aW9uIGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICByZXR1cm4gIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5zdGFydCgpID09ICR0by5zdGFydCgpICYmXG4gICAgICAgICRmcm9tLnBhcmVudC5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KCksICR0by5pbmRleCgpLCBzbGljZS5jb250ZW50KTtcbn1cbi8vIEFsZ29yaXRobSBmb3IgJ3BsYWNpbmcnIHRoZSBlbGVtZW50cyBvZiBhIHNsaWNlIGludG8gYSBnYXA6XG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlIGNvbnRlbnQgb2YgZWFjaCBub2RlIHRoYXQgaXMgb3BlbiB0byB0aGUgbGVmdCB0byBiZVxuLy8gaW5kZXBlbmRlbnRseSBwbGFjZWFibGUuIEkuZS4gaW4gPHAoXCJmb29cIiksIHAoXCJiYXJcIik+LCB3aGVuIHRoZVxuLy8gcGFyYWdyYXBoIG9uIHRoZSBsZWZ0IGlzIG9wZW4sIFwiZm9vXCIgY2FuIGJlIHBsYWNlZCAoc29tZXdoZXJlIG9uXG4vLyB0aGUgbGVmdCBzaWRlIG9mIHRoZSByZXBsYWNlbWVudCBnYXApIGluZGVwZW5kZW50bHkgZnJvbSBwKFwiYmFyXCIpLlxuLy9cbi8vIFRoaXMgY2xhc3MgdHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgcGxhY2VtZW50IHByb2dyZXNzIGluIHRoZVxuLy8gZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vL1xuLy8gIC0gYGZyb250aWVyYCBob2xkcyBhIHN0YWNrIG9mIGB7dHlwZSwgbWF0Y2h9YCBvYmplY3RzIHRoYXRcbi8vICAgIHJlcHJlc2VudCB0aGUgb3BlbiBzaWRlIG9mIHRoZSByZXBsYWNlbWVudC4gSXQgc3RhcnRzIGF0XG4vLyAgICBgJGZyb21gLCB0aGVuIG1vdmVzIGZvcndhcmQgYXMgY29udGVudCBpcyBwbGFjZWQsIGFuZCBpcyBmaW5hbGx5XG4vLyAgICByZWNvbmNpbGVkIHdpdGggYCR0b2AuXG4vL1xuLy8gIC0gYHVucGxhY2VkYCBpcyBhIHNsaWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCB0aGF0IGhhc24ndFxuLy8gICAgYmVlbiBwbGFjZWQgeWV0LlxuLy9cbi8vICAtIGBwbGFjZWRgIGlzIGEgZnJhZ21lbnQgb2YgcGxhY2VkIGNvbnRlbnQuIEl0cyBvcGVuLXN0YXJ0IHZhbHVlXG4vLyAgICBpcyBpbXBsaWNpdCBpbiBgJGZyb21gLCBhbmQgaXRzIG9wZW4tZW5kIHZhbHVlIGluIGBmcm9udGllcmAuXG5jbGFzcyBGaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCRmcm9tLCAkdG8sIHVucGxhY2VkKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSB1bnBsYWNlZDtcbiAgICAgICAgdGhpcy5mcm9udGllciA9IFtdO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAkZnJvbS5kZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICRmcm9tLm5vZGUoaSk7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9ICRmcm9tLmRlcHRoOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoaSkuY29weSh0aGlzLnBsYWNlZCkpO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmZyb250aWVyLmxlbmd0aCAtIDE7IH1cbiAgICBmaXQoKSB7XG4gICAgICAgIC8vIEFzIGxvbmcgYXMgdGhlcmUncyB1bnBsYWNlZCBjb250ZW50LCB0cnkgdG8gcGxhY2Ugc29tZSBvZiBpdC5cbiAgICAgICAgLy8gSWYgdGhhdCBmYWlscywgZWl0aGVyIGluY3JlYXNlIHRoZSBvcGVuIHNjb3JlIG9mIHRoZSB1bnBsYWNlZFxuICAgICAgICAvLyBzbGljZSwgb3IgZHJvcCBub2RlcyBmcm9tIGl0LCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgICAgIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICAgICAgICAgIGxldCBmaXQgPSB0aGlzLmZpbmRGaXR0YWJsZSgpO1xuICAgICAgICAgICAgaWYgKGZpdClcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlTm9kZXMoZml0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Nb3JlKCkgfHwgdGhpcy5kcm9wTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlcmUncyBpbmxpbmUgY29udGVudCBkaXJlY3RseSBhZnRlciB0aGUgZnJvbnRpZXIgX2FuZF9cbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgYHRoaXMuJHRvYCwgd2UgbXVzdCBnZW5lcmF0ZSBhIGBSZXBsYWNlQXJvdW5kYFxuICAgICAgICAvLyBzdGVwIHRoYXQgcHVsbHMgdGhhdCBjb250ZW50IGludG8gdGhlIG5vZGUgYWZ0ZXIgdGhlIGZyb250aWVyLlxuICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZSBmaXR0aW5nIG11c3QgYmUgZG9uZSB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0YmxvY2tcbiAgICAgICAgLy8gbm9kZSBhZnRlciBgdGhpcy4kdG9gLCBub3QgYHRoaXMuJHRvYCBpdHNlbGYuXG4gICAgICAgIGxldCBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLCBwbGFjZWRTaXplID0gdGhpcy5wbGFjZWQuc2l6ZSAtIHRoaXMuZGVwdGggLSB0aGlzLiRmcm9tLmRlcHRoO1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLiRmcm9tLCAkdG8gPSB0aGlzLmNsb3NlKG1vdmVJbmxpbmUgPCAwID8gdGhpcy4kdG8gOiAkZnJvbS5kb2MucmVzb2x2ZShtb3ZlSW5saW5lKSk7XG4gICAgICAgIGlmICghJHRvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIElmIGNsb3NpbmcgdG8gYCR0b2Agc3VjY2VlZGVkLCBjcmVhdGUgYSBzdGVwXG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5wbGFjZWQsIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoLCBvcGVuRW5kID0gJHRvLmRlcHRoO1xuICAgICAgICB3aGlsZSAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEpIHsgLy8gTm9ybWFsaXplIGJ5IGRyb3BwaW5nIG9wZW4gcGFyZW50IG5vZGVzXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgaWYgKG1vdmVJbmxpbmUgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSk7XG4gICAgICAgIGlmIChzbGljZS5zaXplIHx8ICRmcm9tLnBvcyAhPSB0aGlzLiR0by5wb3MpIC8vIERvbid0IGdlbmVyYXRlIG5vLW9wIHN0ZXBzXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRmluZCBhIHBvc2l0aW9uIG9uIHRoZSBzdGFydCBzcGluZSBvZiBgdGhpcy51bnBsYWNlZGAgdGhhdCBoYXNcbiAgICAvLyBjb250ZW50IHRoYXQgY2FuIGJlIG1vdmVkIHNvbWV3aGVyZSBvbiB0aGUgZnJvbnRpZXIuIFJldHVybnMgdHdvXG4gICAgLy8gZGVwdGhzLCBvbmUgZm9yIHRoZSBzbGljZSBhbmQgb25lIGZvciB0aGUgZnJvbnRpZXIuXG4gICAgZmluZEZpdHRhYmxlKCkge1xuICAgICAgICBsZXQgc3RhcnREZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjdXIgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQsIGQgPSAwLCBvcGVuRW5kID0gdGhpcy51bnBsYWNlZC5vcGVuRW5kOyBkIDwgc3RhcnREZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGN1ci5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgb3BlbkVuZCA8PSBkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREZXB0aCA9IGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB0cnkgd3JhcHBpbmcgbm9kZXMgKHBhc3MgMikgYWZ0ZXIgZmluZGluZyBhIHBsYWNlIHdpdGhvdXRcbiAgICAgICAgLy8gd3JhcHBpbmcgZmFpbGVkLlxuICAgICAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNsaWNlRGVwdGggPSBwYXNzID09IDEgPyBzdGFydERlcHRoIDogdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7IHNsaWNlRGVwdGggPj0gMDsgc2xpY2VEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYWdtZW50LCBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGNvbnRlbnRBdCh0aGlzLnVucGxhY2VkLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxKS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZnJvbnRpZXJEZXB0aCA9IHRoaXMuZGVwdGg7IGZyb250aWVyRGVwdGggPj0gMDsgZnJvbnRpZXJEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG1hdGNoIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLCB3cmFwLCBpbmplY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDEsIGlmIHRoZSBuZXh0IG5vZGUgbWF0Y2hlcywgb3IgdGhlcmUgaXMgbm8gbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBub2RlIGJ1dCB0aGUgcGFyZW50cyBsb29rIGNvbXBhdGlibGUsIHdlJ3ZlIGZvdW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzID09IDEgJiYgKGZpcnN0ID8gbWF0Y2gubWF0Y2hUeXBlKGZpcnN0LnR5cGUpIHx8IChpbmplY3QgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20oZmlyc3QpLCBmYWxzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudCAmJiB0eXBlLmNvbXBhdGlibGVDb250ZW50KHBhcmVudC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDIsIGxvb2sgZm9yIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGVzIHRoYXQgbWFrZVxuICAgICAgICAgICAgICAgICAgICAvLyBgZmlyc3RgIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXNzID09IDIgJiYgZmlyc3QgJiYgKHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcoZmlyc3QudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCB3cmFwIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnRpbnVlIGxvb2tpbmcgZnVydGhlciB1cCBpZiB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgbWF0Y2gubWF0Y2hUeXBlKHBhcmVudC50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuTW9yZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKCFpbm5lci5jaGlsZENvdW50IHx8IGlubmVyLmZpcnN0Q2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCArIDEsIE1hdGgubWF4KG9wZW5FbmQsIGlubmVyLnNpemUgKyBvcGVuU3RhcnQgPj0gY29udGVudC5zaXplIC0gb3BlbkVuZCA/IG9wZW5TdGFydCArIDEgOiAwKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcm9wTm9kZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgb3BlbkF0RW5kID0gY29udGVudC5zaXplIC0gb3BlblN0YXJ0IDw9IG9wZW5TdGFydCArIGlubmVyLnNpemU7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0IC0gMSwgMSksIG9wZW5TdGFydCAtIDEsIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQsIDEpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmUgY29udGVudCBmcm9tIHRoZSB1bnBsYWNlZCBzbGljZSBhdCBgc2xpY2VEZXB0aGAgdG8gdGhlXG4gICAgLy8gZnJvbnRpZXIgbm9kZSBhdCBgZnJvbnRpZXJEZXB0aGAuIENsb3NlIHRoYXQgZnJvbnRpZXIgbm9kZSB3aGVuXG4gICAgLy8gYXBwbGljYWJsZS5cbiAgICBwbGFjZU5vZGVzKHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QsIHdyYXAgfSkge1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGZyb250aWVyRGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmICh3cmFwKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZSh3cmFwW2ldKTtcbiAgICAgICAgbGV0IHNsaWNlID0gdGhpcy51bnBsYWNlZCwgZnJhZ21lbnQgPSBwYXJlbnQgPyBwYXJlbnQuY29udGVudCA6IHNsaWNlLmNvbnRlbnQ7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICAgICAgICBsZXQgdGFrZW4gPSAwLCBhZGQgPSBbXTtcbiAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF07XG4gICAgICAgIGlmIChpbmplY3QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgICAgICBhZGQucHVzaChpbmplY3QuY2hpbGQoaSkpO1xuICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaEZyYWdtZW50KGluamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiAoZW5kKSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGZyYWdtZW50LiBXaGVuIDAsIHRoZSBwYXJlbnQgaXMgb3BlbiwgYnV0IG5vIG1vcmUuIFdoZW5cbiAgICAgICAgLy8gbmVnYXRpdmUsIG5vdGhpbmcgaXMgb3Blbi5cbiAgICAgICAgbGV0IG9wZW5FbmRDb3VudCA9IChmcmFnbWVudC5zaXplICsgc2xpY2VEZXB0aCkgLSAoc2xpY2UuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIC8vIFNjYW4gb3ZlciB0aGUgZnJhZ21lbnQsIGZpdHRpbmcgYXMgbWFueSBjaGlsZCBub2RlcyBhc1xuICAgICAgICAvLyBwb3NzaWJsZS5cbiAgICAgICAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnbWVudC5jaGlsZCh0YWtlbiksIG1hdGNoZXMgPSBtYXRjaC5tYXRjaFR5cGUobmV4dC50eXBlKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRha2VuKys7XG4gICAgICAgICAgICBpZiAodGFrZW4gPiAxIHx8IG9wZW5TdGFydCA9PSAwIHx8IG5leHQuY29udGVudC5zaXplKSB7IC8vIERyb3AgZW1wdHkgb3BlbiBub2Rlc1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICBhZGQucHVzaChjbG9zZU5vZGVTdGFydChuZXh0Lm1hcmsodHlwZS5hbGxvd2VkTWFya3MobmV4dC5tYXJrcykpLCB0YWtlbiA9PSAxID8gb3BlblN0YXJ0IDogMCwgdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudCA/IG9wZW5FbmRDb3VudCA6IC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvRW5kID0gdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudDtcbiAgICAgICAgaWYgKCF0b0VuZClcbiAgICAgICAgICAgIG9wZW5FbmRDb3VudCA9IC0xO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIEZyYWdtZW50LmZyb20oYWRkKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCB0eXBlcyBtYXRjaCwgYW5kIHRoZSBlbnRpcmUgbm9kZSB3YXMgbW92ZWQsIGFuZFxuICAgICAgICAvLyBpdCdzIG5vdCBvcGVuLCBjbG9zZSB0aGlzIGZyb250aWVyIG5vZGUgcmlnaHQgYXdheS5cbiAgICAgICAgaWYgKHRvRW5kICYmIG9wZW5FbmRDb3VudCA8IDAgJiYgcGFyZW50ICYmIHBhcmVudC50eXBlID09IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0udHlwZSAmJiB0aGlzLmZyb250aWVyLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIC8vIEFkZCBuZXcgZnJvbnRpZXIgbm9kZXMgZm9yIGFueSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXIgPSBmcmFnbWVudDsgaSA8IG9wZW5FbmRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlOiBub2RlLnR5cGUsIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkgfSk7XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGB0aGlzLnVucGxhY2VkYC4gRHJvcCB0aGUgZW50aXJlIG5vZGUgZnJvbSB3aGljaCB3ZVxuICAgICAgICAvLyBwbGFjZWQgaXQgd2UgZ290IHRvIGl0cyBlbmQsIG90aGVyd2lzZSBqdXN0IGRyb3AgdGhlIHBsYWNlZFxuICAgICAgICAvLyBub2Rlcy5cbiAgICAgICAgdGhpcy51bnBsYWNlZCA9ICF0b0VuZCA/IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGgsIHRha2VuKSwgc2xpY2Uub3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKVxuICAgICAgICAgICAgOiBzbGljZURlcHRoID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCAtIDEsIDEpLCBzbGljZURlcHRoIC0gMSwgb3BlbkVuZENvdW50IDwgMCA/IHNsaWNlLm9wZW5FbmQgOiBzbGljZURlcHRoIC0gMSk7XG4gICAgfVxuICAgIG11c3RNb3ZlSW5saW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHRvLnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0sIGxldmVsO1xuICAgICAgICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8XG4gICAgICAgICAgICAodGhpcy4kdG8uZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAobGV2ZWwgPSB0aGlzLmZpbmRDbG9zZUxldmVsKHRoaXMuJHRvKSkgJiYgbGV2ZWwuZGVwdGggPT0gdGhpcy5kZXB0aCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB7IGRlcHRoIH0gPSB0aGlzLiR0bywgYWZ0ZXIgPSB0aGlzLiR0by5hZnRlcihkZXB0aCk7XG4gICAgICAgIHdoaWxlIChkZXB0aCA+IDEgJiYgYWZ0ZXIgPT0gdGhpcy4kdG8uZW5kKC0tZGVwdGgpKVxuICAgICAgICAgICAgKythZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH1cbiAgICBmaW5kQ2xvc2VMZXZlbCgkdG8pIHtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgaSA9IE1hdGgubWluKHRoaXMuZGVwdGgsICR0by5kZXB0aCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltpXTtcbiAgICAgICAgICAgIGxldCBkcm9wSW5uZXIgPSBpIDwgJHRvLmRlcHRoICYmICR0by5lbmQoaSArIDEpID09ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gKGkgKyAxKSk7XG4gICAgICAgICAgICBsZXQgZml0ID0gY29udGVudEFmdGVyRml0cygkdG8sIGksIHR5cGUsIG1hdGNoLCBkcm9wSW5uZXIpO1xuICAgICAgICAgICAgaWYgKCFmaXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gaSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZF07XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZCwgdHlwZSwgbWF0Y2gsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkZXB0aDogaSwgZml0LCBtb3ZlOiBkcm9wSW5uZXIgPyAkdG8uZG9jLnJlc29sdmUoJHRvLmFmdGVyKGkgKyAxKSkgOiAkdG8gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgkdG8pIHtcbiAgICAgICAgbGV0IGNsb3NlID0gdGhpcy5maW5kQ2xvc2VMZXZlbCgkdG8pO1xuICAgICAgICBpZiAoIWNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gY2xvc2UuZGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmIChjbG9zZS5maXQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7XG4gICAgICAgICR0byA9IGNsb3NlLm1vdmU7XG4gICAgICAgIGZvciAobGV0IGQgPSBjbG9zZS5kZXB0aCArIDE7IGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJHRvLm5vZGUoZCksIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUobm9kZS50eXBlLCBub2RlLmF0dHJzLCBhZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdG87XG4gICAgfVxuICAgIG9wZW5Gcm9udGllck5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50KSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZGVwdGgsIEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIGNvbnRlbnQpKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGUsIG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCB9KTtcbiAgICB9XG4gICAgY2xvc2VGcm9udGllck5vZGUoKSB7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5mcm9udGllci5wb3AoKTtcbiAgICAgICAgbGV0IGFkZCA9IG9wZW4ubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmIChhZGQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5mcm9udGllci5sZW5ndGgsIGFkZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5jdXRCeUluZGV4KGNvdW50LCBmcmFnbWVudC5jaGlsZENvdW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZyYWdtZW50LmZpcnN0Q2hpbGQuY29weShkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb3VudCkpKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb250ZW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgZnJhZ21lbnQubGFzdENoaWxkLmNvcHkoYWRkVG9GcmFnbWVudChmcmFnbWVudC5sYXN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb250ZW50KSkpO1xufVxuZnVuY3Rpb24gY29udGVudEF0KGZyYWdtZW50LCBkZXB0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZyA9IG5vZGUuY29udGVudDtcbiAgICBpZiAob3BlblN0YXJ0ID4gMSlcbiAgICAgICAgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTtcbiAgICBpZiAob3BlblN0YXJ0ID4gMCkge1xuICAgICAgICBmcmFnID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGZyYWcpLmFwcGVuZChmcmFnKTtcbiAgICAgICAgaWYgKG9wZW5FbmQgPD0gMClcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLmFwcGVuZChub2RlLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZnJhZykuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWcpO1xufVxuZnVuY3Rpb24gY29udGVudEFmdGVyRml0cygkdG8sIGRlcHRoLCB0eXBlLCBtYXRjaCwgb3Blbikge1xuICAgIGxldCBub2RlID0gJHRvLm5vZGUoZGVwdGgpLCBpbmRleCA9IG9wZW4gPyAkdG8uaW5kZXhBZnRlcihkZXB0aCkgOiAkdG8uaW5kZXgoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSBub2RlLmNoaWxkQ291bnQgJiYgIXR5cGUuY29tcGF0aWJsZUNvbnRlbnQobm9kZS50eXBlKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZpdCA9IG1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCBpbmRleCk7XG4gICAgcmV0dXJuIGZpdCAmJiAhaW52YWxpZE1hcmtzKHR5cGUsIG5vZGUuY29udGVudCwgaW5kZXgpID8gZml0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGludmFsaWRNYXJrcyh0eXBlLCBmcmFnbWVudCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIGlmICghdHlwZS5hbGxvd3NNYXJrcyhmcmFnbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWZpbmVzQ29udGVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUuc3BlYy5kZWZpbmluZyB8fCB0eXBlLnNwZWMuZGVmaW5pbmdGb3JDb250ZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHRyLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpKTtcbiAgICBsZXQgdGFyZ2V0RGVwdGhzID0gY292ZXJlZERlcHRocygkZnJvbSwgdHIuZG9jLnJlc29sdmUodG8pKTtcbiAgICAvLyBDYW4ndCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCwgc28gcmVtb3ZlIDAgaWYgaXQncyBwcmVzZW50XG4gICAgaWYgKHRhcmdldERlcHRoc1t0YXJnZXREZXB0aHMubGVuZ3RoIC0gMV0gPT0gMClcbiAgICAgICAgdGFyZ2V0RGVwdGhzLnBvcCgpO1xuICAgIC8vIE5lZ2F0aXZlIG51bWJlcnMgcmVwcmVzZW50IG5vdCBleHBhbnNpb24gb3ZlciB0aGUgd2hvbGUgbm9kZSBhdFxuICAgIC8vIHRoYXQgZGVwdGgsIGJ1dCByZXBsYWNpbmcgZnJvbSAkZnJvbS5iZWZvcmUoLUQpIHRvICR0by5wb3MuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldCA9IC0oJGZyb20uZGVwdGggKyAxKTtcbiAgICB0YXJnZXREZXB0aHMudW5zaGlmdChwcmVmZXJyZWRUYXJnZXQpO1xuICAgIC8vIFRoaXMgbG9vcCBwaWNrcyBhIHByZWZlcnJlZCB0YXJnZXQgZGVwdGgsIGlmIG9uZSBvZiB0aGUgY292ZXJpbmdcbiAgICAvLyBkZXB0aHMgaXMgbm90IG91dHNpZGUgb2YgYSBkZWZpbmluZyBub2RlLCBhbmQgYWRkcyBuZWdhdGl2ZVxuICAgIC8vIGRlcHRocyBmb3IgYW55IGRlcHRoIHRoYXQgaGFzICRmcm9tIGF0IGl0cyBzdGFydCBhbmQgZG9lcyBub3RcbiAgICAvLyBjcm9zcyBhIGRlZmluaW5nIG5vZGUuXG4gICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoLCBwb3MgPSAkZnJvbS5wb3MgLSAxOyBkID4gMDsgZC0tLCBwb3MtLSkge1xuICAgICAgICBsZXQgc3BlYyA9ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjO1xuICAgICAgICBpZiAoc3BlYy5kZWZpbmluZyB8fCBzcGVjLmRlZmluaW5nQXNDb250ZXh0IHx8IHNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICh0YXJnZXREZXB0aHMuaW5kZXhPZihkKSA+IC0xKVxuICAgICAgICAgICAgcHJlZmVycmVkVGFyZ2V0ID0gZDtcbiAgICAgICAgZWxzZSBpZiAoJGZyb20uYmVmb3JlKGQpID09IHBvcylcbiAgICAgICAgICAgIHRhcmdldERlcHRocy5zcGxpY2UoMSwgMCwgLWQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZml0IGVhY2ggcG9zc2libGUgZGVwdGggb2YgdGhlIHNsaWNlIGludG8gZWFjaCBwb3NzaWJsZVxuICAgIC8vIHRhcmdldCBkZXB0aCwgc3RhcnRpbmcgd2l0aCB0aGUgcHJlZmVycmVkIGRlcHRocy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0SW5kZXggPSB0YXJnZXREZXB0aHMuaW5kZXhPZihwcmVmZXJyZWRUYXJnZXQpO1xuICAgIGxldCBsZWZ0Tm9kZXMgPSBbXSwgcHJlZmVycmVkRGVwdGggPSBzbGljZS5vcGVuU3RhcnQ7XG4gICAgZm9yIChsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBsZWZ0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8vIEJhY2sgdXAgcHJlZmVycmVkRGVwdGggdG8gY292ZXIgZGVmaW5pbmcgdGV4dGJsb2NrcyBkaXJlY3RseVxuICAgIC8vIGFib3ZlIGl0LCBwb3NzaWJseSBza2lwcGluZyBhIG5vbi1kZWZpbmluZyB0ZXh0YmxvY2suXG4gICAgZm9yIChsZXQgZCA9IHByZWZlcnJlZERlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGxlZnROb2RlID0gbGVmdE5vZGVzW2RdLCBkZWYgPSBkZWZpbmVzQ29udGVudChsZWZ0Tm9kZS50eXBlKTtcbiAgICAgICAgaWYgKGRlZiAmJiAhbGVmdE5vZGUuc2FtZU1hcmt1cCgkZnJvbS5ub2RlKE1hdGguYWJzKHByZWZlcnJlZFRhcmdldCkgLSAxKSkpXG4gICAgICAgICAgICBwcmVmZXJyZWREZXB0aCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKGRlZiB8fCAhbGVmdE5vZGUudHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gc2xpY2Uub3BlblN0YXJ0OyBqID49IDA7IGotLSkge1xuICAgICAgICBsZXQgb3BlbkRlcHRoID0gKGogKyBwcmVmZXJyZWREZXB0aCArIDEpICUgKHNsaWNlLm9wZW5TdGFydCArIDEpO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gbGVmdE5vZGVzW29wZW5EZXB0aF07XG4gICAgICAgIGlmICghaW5zZXJ0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RGVwdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgcG9zc2libGUgZXhwYW5zaW9uIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHByZWZlcnJlZCBvbmVcbiAgICAgICAgICAgIGxldCB0YXJnZXREZXB0aCA9IHRhcmdldERlcHRoc1soaSArIHByZWZlcnJlZFRhcmdldEluZGV4KSAlIHRhcmdldERlcHRocy5sZW5ndGhdLCBleHBhbmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRhcmdldERlcHRoID0gLXRhcmdldERlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUodGFyZ2V0RGVwdGggLSAxKSwgaW5kZXggPSAkZnJvbS5pbmRleCh0YXJnZXREZXB0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGluc2VydC50eXBlLCBpbnNlcnQubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ci5yZXBsYWNlKCRmcm9tLmJlZm9yZSh0YXJnZXREZXB0aCksIGV4cGFuZCA/ICR0by5hZnRlcih0YXJnZXREZXB0aCkgOiB0bywgbmV3IFNsaWNlKGNsb3NlRnJhZ21lbnQoc2xpY2UuY29udGVudCwgMCwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRGVwdGgpLCBvcGVuRGVwdGgsIHNsaWNlLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnRTdGVwcyA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRyLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA+IHN0YXJ0U3RlcHMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlcHRoID0gdGFyZ2V0RGVwdGhzW2ldO1xuICAgICAgICBpZiAoZGVwdGggPCAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZyb20gPSAkZnJvbS5iZWZvcmUoZGVwdGgpO1xuICAgICAgICB0byA9ICR0by5hZnRlcihkZXB0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VGcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIG9sZE9wZW4sIG5ld09wZW4sIHBhcmVudCkge1xuICAgIGlmIChkZXB0aCA8IG9sZE9wZW4pIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZmlyc3QuY29weShjbG9zZUZyYWdtZW50KGZpcnN0LmNvbnRlbnQsIGRlcHRoICsgMSwgb2xkT3BlbiwgbmV3T3BlbiwgZmlyc3QpKSk7XG4gICAgfVxuICAgIGlmIChkZXB0aCA+IG5ld09wZW4pIHtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBtYXRjaC5maWxsQmVmb3JlKGZyYWdtZW50KS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICBmcmFnbWVudCA9IHN0YXJ0LmFwcGVuZChtYXRjaC5tYXRjaEZyYWdtZW50KHN0YXJ0KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZVdpdGgodHIsIGZyb20sIHRvLCBub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzSW5saW5lICYmIGZyb20gPT0gdG8gJiYgdHIuZG9jLnJlc29sdmUoZnJvbSkucGFyZW50LmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBsZXQgcG9pbnQgPSBpbnNlcnRQb2ludCh0ci5kb2MsIGZyb20sIG5vZGUudHlwZSk7XG4gICAgICAgIGlmIChwb2ludCAhPSBudWxsKVxuICAgICAgICAgICAgZnJvbSA9IHRvID0gcG9pbnQ7XG4gICAgfVxuICAgIHRyLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHRyLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgbGV0IGNvdmVyZWQgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY292ZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVwdGggPSBjb3ZlcmVkW2ldLCBsYXN0ID0gaSA9PSBjb3ZlcmVkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICgobGFzdCAmJiBkZXB0aCA9PSAwKSB8fCAkZnJvbS5ub2RlKGRlcHRoKS50eXBlLmNvbnRlbnRNYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uc3RhcnQoZGVwdGgpLCAkdG8uZW5kKGRlcHRoKSk7XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgKGxhc3QgfHwgJGZyb20ubm9kZShkZXB0aCAtIDEpLmNhblJlcGxhY2UoJGZyb20uaW5kZXgoZGVwdGggLSAxKSwgJHRvLmluZGV4QWZ0ZXIoZGVwdGggLSAxKSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZGVwdGgpLCAkdG8uYWZ0ZXIoZGVwdGgpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgZCA9IDE7IGQgPD0gJGZyb20uZGVwdGggJiYgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICBpZiAoZnJvbSAtICRmcm9tLnN0YXJ0KGQpID09ICRmcm9tLmRlcHRoIC0gZCAmJiB0byA+ICRmcm9tLmVuZChkKSAmJiAkdG8uZW5kKGQpIC0gdG8gIT0gJHRvLmRlcHRoIC0gZClcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGQpLCB0byk7XG4gICAgfVxuICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG59XG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkZXB0aHMgZm9yIHdoaWNoICRmcm9tIC0gJHRvIHNwYW5zIHRoZVxuLy8gd2hvbGUgY29udGVudCBvZiB0aGUgbm9kZXMgYXQgdGhhdCBkZXB0aC5cbmZ1bmN0aW9uIGNvdmVyZWREZXB0aHMoJGZyb20sICR0bykge1xuICAgIGxldCByZXN1bHQgPSBbXSwgbWluRGVwdGggPSBNYXRoLm1pbigkZnJvbS5kZXB0aCwgJHRvLmRlcHRoKTtcbiAgICBmb3IgKGxldCBkID0gbWluRGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGQpO1xuICAgICAgICBpZiAoc3RhcnQgPCAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJHRvLmVuZChkKSA+ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAgICAgJHRvLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoc3RhcnQgPT0gJHRvLnN0YXJ0KGQpIHx8XG4gICAgICAgICAgICAoZCA9PSAkZnJvbS5kZXB0aCAmJiBkID09ICR0by5kZXB0aCAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICBkICYmICR0by5zdGFydChkIC0gMSkgPT0gc3RhcnQgLSAxKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEF0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBhdHRyaWJ1dGUgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIG5vZGUuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IG5vZGUuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcCh0aGlzLnBvcywgdGhpcy5hdHRyLCBkb2Mubm9kZUF0KHRoaXMucG9zKS5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEF0dHJTdGVwKHBvcy5wb3MsIHRoaXMuYXR0ciwgdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYXR0clwiLCBwb3M6IHRoaXMucG9zLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAoanNvbi5wb3MsIGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhdHRyXCIsIEF0dHJTdGVwKTtcbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgZG9jIG5vZGUuXG4qL1xuY2xhc3MgRG9jQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBkb2MuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGRvYy5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZG9jLnR5cGUuY3JlYXRlKGF0dHJzLCBkb2MuY29udGVudCwgZG9jLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2sodXBkYXRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcCh0aGlzLmF0dHIsIGRvYy5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiZG9jQXR0clwiLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRG9jQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAoanNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImRvY0F0dHJcIiwgRG9jQXR0clN0ZXApO1xuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmxldCBUcmFuc2Zvcm1FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xufTtcblRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIGVyci5fX3Byb3RvX18gPSBUcmFuc2Zvcm1FcnJvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGVycjtcbn07XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm1FcnJvcjtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJUcmFuc2Zvcm1FcnJvclwiO1xuLyoqXG5BYnN0cmFjdGlvbiB0byBidWlsZCB1cCBhbmQgdHJhY2sgYW4gYXJyYXkgb2ZcbltzdGVwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSByZXByZXNlbnRpbmcgYSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi5cblxuTW9zdCB0cmFuc2Zvcm1pbmcgbWV0aG9kcyByZXR1cm4gdGhlIGBUcmFuc2Zvcm1gIG9iamVjdCBpdHNlbGYsIHNvXG50aGF0IHRoZXkgY2FuIGJlIGNoYWluZWQuXG4qL1xuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmFuc2Zvcm0gdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudCAodGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNmb3JtKS5cbiAgICAqL1xuICAgIGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGRvY3VtZW50cyBiZWZvcmUgZWFjaCBvZiB0aGUgc3RlcHMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQSBtYXBwaW5nIHdpdGggdGhlIG1hcHMgZm9yIGVhY2ggb2YgdGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGJlZm9yZSgpIHsgcmV0dXJuIHRoaXMuZG9jcy5sZW5ndGggPyB0aGlzLmRvY3NbMF0gOiB0aGlzLmRvYzsgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgbmV3IHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm0sIHNhdmluZyB0aGUgcmVzdWx0LiBUaHJvd3MgYW5cbiAgICBlcnJvciB3aGVuIHRoZSBzdGVwIGZhaWxzLlxuICAgICovXG4gICAgc3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChzdGVwKTtcbiAgICAgICAgaWYgKHJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gYXBwbHkgYSBzdGVwIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIGlnbm9yaW5nIGl0IGlmIGl0XG4gICAgZmFpbHMuIFJldHVybnMgdGhlIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgbWF5YmVTdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0ZXAuYXBwbHkodGhpcy5kb2MpO1xuICAgICAgICBpZiAoIXJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCwgcmVzdWx0LmRvYyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gY2hhbmdlZCAod2hlbiB0aGVyZSBhcmUgYW55XG4gICAgc3RlcHMpLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2NzLnB1c2godGhpcy5kb2MpO1xuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgICAgIHRoaXMubWFwcGluZy5hcHBlbmRNYXAoc3RlcC5nZXRNYXAoKSk7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB3aXRoIHRoZVxuICAgIGdpdmVuIGBzbGljZWAuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHRoaXMuZG9jLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgIHRoaXMuc3RlcChzdGVwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQsIHdoaWNoIG1heSBiZSBhXG4gICAgZnJhZ21lbnQsIG5vZGUsIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGRlbGV0ZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBTbGljZS5lbXB0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEluc2VydCB0aGUgZ2l2ZW4gY29udGVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpbnNlcnQocG9zLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKHBvcywgcG9zLCBjb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4gc2xpY2UsIHVzaW5nXG4gICAgYGZyb21gLCBgdG9gLCBhbmQgdGhlIHNsaWNlJ3NcbiAgICBbYG9wZW5TdGFydGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TbGljZS5vcGVuU3RhcnQpIHByb3BlcnR5IGFzIGhpbnRzLCByYXRoZXJcbiAgICB0aGFuIGZpeGVkIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLiBUaGlzIG1ldGhvZCBtYXkgZ3JvdyB0aGVcbiAgICByZXBsYWNlZCBhcmVhIG9yIGNsb3NlIG9wZW4gbm9kZXMgaW4gdGhlIHNsaWNlIGluIG9yZGVyIHRvIGdldCBhXG4gICAgZml0IHRoYXQgaXMgbW9yZSBpbiBsaW5lIHdpdGggV1lTSVdZRyBleHBlY3RhdGlvbnMsIGJ5IGRyb3BwaW5nXG4gICAgZnVsbHkgY292ZXJlZCBwYXJlbnQgbm9kZXMgb2YgdGhlIHJlcGxhY2VkIHJlZ2lvbiB3aGVuIHRoZXkgYXJlXG4gICAgbWFya2VkIFtub24tZGVmaW5pbmcgYXNcbiAgICBjb250ZXh0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdBc0NvbnRleHQpLCBvciBpbmNsdWRpbmcgYW5cbiAgICBvcGVuIHBhcmVudCBub2RlIGZyb20gdGhlIHNsaWNlIHRoYXQgX2lzXyBtYXJrZWQgYXMgW2RlZmluaW5nXG4gICAgaXRzIGNvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQpLlxuICAgIFxuICAgIFRoaXMgaXMgdGhlIG1ldGhvZCwgZm9yIGV4YW1wbGUsIHRvIGhhbmRsZSBwYXN0ZS4gVGhlIHNpbWlsYXJcbiAgICBbYHJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybS5yZXBsYWNlKSBtZXRob2QgaXMgYSBtb3JlXG4gICAgcHJpbWl0aXZlIHRvb2wgd2hpY2ggd2lsbCBfbm90XyBtb3ZlIHRoZSBzdGFydCBhbmQgZW5kIG9mIGl0cyBnaXZlblxuICAgIHJhbmdlLCBhbmQgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IG5lZWQgbW9yZSBwcmVjaXNlXG4gICAgY29udHJvbCBvdmVyIHdoYXQgaGFwcGVucy5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZSwgYnV0IHVzZSBgZnJvbWAgYW5kIGB0b2AgYXNcbiAgICBoaW50cywgcmF0aGVyIHRoYW4gcHJlY2lzZSBwb3NpdGlvbnMuIFdoZW4gZnJvbSBhbmQgdG8gYXJlIHRoZSBzYW1lXG4gICAgYW5kIGFyZSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgcGFyZW50IG5vZGUgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgbm9kZSBkb2Vzbid0IGZpdCwgdGhpcyBtZXRob2QgbWF5IF9tb3ZlXyB0aGVtIG91dCB0b3dhcmRzIGEgcGFyZW50XG4gICAgdGhhdCBkb2VzIGFsbG93IHRoZSBnaXZlbiBub2RlIHRvIGJlIHBsYWNlZC4gV2hlbiB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICBjb21wbGV0ZWx5IGNvdmVycyBhIHBhcmVudCBub2RlLCB0aGlzIG1ldGhvZCBtYXkgY29tcGxldGVseSByZXBsYWNlXG4gICAgdGhhdCBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlV2l0aCh0aGlzLCBmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGdpdmVuIHJhbmdlLCBleHBhbmRpbmcgaXQgdG8gY292ZXIgZnVsbHkgY292ZXJlZFxuICAgIHBhcmVudCBub2RlcyB1bnRpbCBhIHZhbGlkIHJlcGxhY2UgaXMgZm91bmQuXG4gICAgKi9cbiAgICBkZWxldGVSYW5nZShmcm9tLCB0bykge1xuICAgICAgICBkZWxldGVSYW5nZSh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2Ugb2ZmIGZyb20gaXRzIHBhcmVudCwgaWYgdGhlcmVcbiAgICBpcyBzaWJsaW5nIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIGl0LCBhbmQgbW92ZSBpdCB1cCB0aGUgdHJlZSB0b1xuICAgIHRoZSBkZXB0aCBzcGVjaWZpZWQgYnkgYHRhcmdldGAuIFlvdSdsbCBwcm9iYWJseSB3YW50IHRvIHVzZVxuICAgIFtgbGlmdFRhcmdldGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0ubGlmdFRhcmdldCkgdG8gY29tcHV0ZSBgdGFyZ2V0YCwgdG8gbWFrZVxuICAgIHN1cmUgdGhlIGxpZnQgaXMgdmFsaWQuXG4gICAgKi9cbiAgICBsaWZ0KHJhbmdlLCB0YXJnZXQpIHtcbiAgICAgICAgbGlmdCh0aGlzLCByYW5nZSwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gdGhlIGJsb2NrcyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJZiBkZXB0aCBpcyAyLCB0aGVpclxuICAgIGxhc3QgYW5kIGZpcnN0IHNpYmxpbmdzIGFyZSBhbHNvIGpvaW5lZCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgam9pbihwb3MsIGRlcHRoID0gMSkge1xuICAgICAgICBqb2luKHRoaXMsIHBvcywgZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV3JhcCB0aGUgZ2l2ZW4gW3JhbmdlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlKSBpbiB0aGUgZ2l2ZW4gc2V0IG9mIHdyYXBwZXJzLlxuICAgIFRoZSB3cmFwcGVycyBhcmUgYXNzdW1lZCB0byBiZSB2YWxpZCBpbiB0aGlzIHBvc2l0aW9uLCBhbmQgc2hvdWxkXG4gICAgcHJvYmFibHkgYmUgY29tcHV0ZWQgd2l0aCBbYGZpbmRXcmFwcGluZ2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uZmluZFdyYXBwaW5nKS5cbiAgICAqL1xuICAgIHdyYXAocmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgICAgIHdyYXAodGhpcywgcmFuZ2UsIHdyYXBwZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdHlwZSBvZiBhbGwgdGV4dGJsb2NrcyAocGFydGx5KSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB0b1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHNldEJsb2NrVHlwZShmcm9tLCB0byA9IGZyb20sIHR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgICAgICBzZXRCbG9ja1R5cGUodGhpcywgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuICAgIFdoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiAgICAqL1xuICAgIHNldE5vZGVNYXJrdXAocG9zLCB0eXBlLCBhdHRycyA9IG51bGwsIG1hcmtzKSB7XG4gICAgICAgIHNldE5vZGVNYXJrdXAodGhpcywgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhIGdpdmVuIG5vZGUgdG8gYSBuZXcgdmFsdWUuXG4gICAgVGhlIGBwb3NgIGFkZHJlc3NlcyB0aGUgZG9jdW1lbnQgY29udGVudC4gVXNlIGBzZXREb2NBdHRyaWJ1dGVgXG4gICAgdG8gc2V0IGF0dHJpYnV0ZXMgb24gdGhlIGRvY3VtZW50IGl0c2VsZi5cbiAgICAqL1xuICAgIHNldE5vZGVBdHRyaWJ1dGUocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEF0dHJTdGVwKHBvcywgYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IHRvIGEgbmV3IHZhbHVlLlxuICAgICovXG4gICAgc2V0RG9jQXR0cmlidXRlKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgRG9jQXR0clN0ZXAoYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIG5vZGUgYXQgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIChvciBhIG1hcmsgb2YgdGhlIGdpdmVuIHR5cGUpIGZyb20gdGhlIG5vZGUgYXRcbiAgICBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICBpZiAoIShtYXJrIGluc3RhbmNlb2YgTWFyaykpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrLmlzSW5TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoIW1hcmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4gICAgZ3JlYXRlciB0aGFuIG9uZSwgYW55IG51bWJlciBvZiBub2RlcyBhYm92ZSB0aGF0LiBCeSBkZWZhdWx0LCB0aGVcbiAgICBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4gICAgdXNlIGFmdGVyIHRoZSBzcGxpdC5cbiAgICAqL1xuICAgIHNwbGl0KHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgICAgIHNwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgYWRkTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgbWFya3MgZnJvbSBpbmxpbmUgbm9kZXMgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgbWFya2AgaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXNcbiAgICBhIG1hcmsgdHlwZSwgcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCxcbiAgICByZW1vdmUgYWxsIG1hcmtzIG9mIGFueSB0eXBlLlxuICAgICovXG4gICAgcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICByZW1vdmVNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0XG4gICAgYHBvc2AgdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHNcbiAgICBhbiBvcHRpb25hbCBzdGFydGluZyBbY29udGVudCBtYXRjaF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkNvbnRlbnRNYXRjaCkgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIEFkZE5vZGVNYXJrU3RlcCwgQXR0clN0ZXAsIERvY0F0dHJTdGVwLCBNYXBSZXN1bHQsIE1hcHBpbmcsIFJlbW92ZU1hcmtTdGVwLCBSZW1vdmVOb2RlTWFya1N0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCwgU3RlcCwgU3RlcE1hcCwgU3RlcFJlc3VsdCwgVHJhbnNmb3JtLCBUcmFuc2Zvcm1FcnJvciwgY2FuSm9pbiwgY2FuU3BsaXQsIGRyb3BQb2ludCwgZmluZFdyYXBwaW5nLCBpbnNlcnRQb2ludCwgam9pblBvaW50LCBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCB9O1xuIl0sIm5hbWVzIjpbIlJlcGxhY2VFcnJvciIsIlNsaWNlIiwiRnJhZ21lbnQiLCJNYXJrVHlwZSIsIk1hcmsiLCJsb3dlcjE2IiwiZmFjdG9yMTYiLCJNYXRoIiwicG93IiwibWFrZVJlY292ZXIiLCJpbmRleCIsIm9mZnNldCIsInJlY292ZXJJbmRleCIsInZhbHVlIiwicmVjb3Zlck9mZnNldCIsIkRFTF9CRUZPUkUiLCJERUxfQUZURVIiLCJERUxfQUNST1NTIiwiREVMX1NJREUiLCJNYXBSZXN1bHQiLCJjb25zdHJ1Y3RvciIsInBvcyIsImRlbEluZm8iLCJyZWNvdmVyIiwiZGVsZXRlZCIsImRlbGV0ZWRCZWZvcmUiLCJkZWxldGVkQWZ0ZXIiLCJkZWxldGVkQWNyb3NzIiwiU3RlcE1hcCIsInJhbmdlcyIsImludmVydGVkIiwibGVuZ3RoIiwiZW1wdHkiLCJkaWZmIiwiaSIsIm1hcFJlc3VsdCIsImFzc29jIiwiX21hcCIsIm1hcCIsInNpbXBsZSIsIm9sZEluZGV4IiwibmV3SW5kZXgiLCJzdGFydCIsIm9sZFNpemUiLCJuZXdTaXplIiwiZW5kIiwic2lkZSIsInJlc3VsdCIsImRlbCIsInRvdWNoZXMiLCJmb3JFYWNoIiwiZiIsIm9sZFN0YXJ0IiwibmV3U3RhcnQiLCJpbnZlcnQiLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJuIiwiTWFwcGluZyIsIm1hcHMiLCJtaXJyb3IiLCJmcm9tIiwidG8iLCJzbGljZSIsImNvcHkiLCJhcHBlbmRNYXAiLCJtaXJyb3JzIiwicHVzaCIsInNldE1pcnJvciIsImFwcGVuZE1hcHBpbmciLCJtYXBwaW5nIiwic3RhcnRTaXplIiwibWlyciIsImdldE1pcnJvciIsInVuZGVmaW5lZCIsIm0iLCJhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQiLCJ0b3RhbFNpemUiLCJpbnZlcnNlIiwiY29yciIsInN0ZXBzQnlJRCIsIk9iamVjdCIsImNyZWF0ZSIsIlN0ZXAiLCJnZXRNYXAiLCJtZXJnZSIsIm90aGVyIiwiZnJvbUpTT04iLCJzY2hlbWEiLCJqc29uIiwic3RlcFR5cGUiLCJSYW5nZUVycm9yIiwidHlwZSIsImpzb25JRCIsImlkIiwic3RlcENsYXNzIiwicHJvdG90eXBlIiwiU3RlcFJlc3VsdCIsImRvYyIsImZhaWxlZCIsIm9rIiwiZmFpbCIsIm1lc3NhZ2UiLCJmcm9tUmVwbGFjZSIsInJlcGxhY2UiLCJlIiwibWFwRnJhZ21lbnQiLCJmcmFnbWVudCIsInBhcmVudCIsIm1hcHBlZCIsImNoaWxkQ291bnQiLCJjaGlsZCIsImNvbnRlbnQiLCJzaXplIiwiaXNJbmxpbmUiLCJmcm9tQXJyYXkiLCJBZGRNYXJrU3RlcCIsIm1hcmsiLCJhcHBseSIsIm9sZFNsaWNlIiwiJGZyb20iLCJyZXNvbHZlIiwibm9kZSIsInNoYXJlZERlcHRoIiwiaXNBdG9tIiwiYWxsb3dzTWFya1R5cGUiLCJhZGRUb1NldCIsIm1hcmtzIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIlJlbW92ZU1hcmtTdGVwIiwiZXEiLCJtaW4iLCJtYXgiLCJ0b0pTT04iLCJtYXJrRnJvbUpTT04iLCJyZW1vdmVGcm9tU2V0IiwiQWRkTm9kZU1hcmtTdGVwIiwibm9kZUF0IiwidXBkYXRlZCIsImF0dHJzIiwiaXNMZWFmIiwibmV3U2V0IiwiaXNJblNldCIsIlJlbW92ZU5vZGVNYXJrU3RlcCIsIlJlcGxhY2VTdGVwIiwic3RydWN0dXJlIiwiY29udGVudEJldHdlZW4iLCJhcHBlbmQiLCJSZXBsYWNlQXJvdW5kU3RlcCIsImdhcEZyb20iLCJnYXBUbyIsImluc2VydCIsImdhcCIsImluc2VydGVkIiwiaW5zZXJ0QXQiLCJyZW1vdmVCZXR3ZWVuIiwiZGlzdCIsImRlcHRoIiwiaW5kZXhBZnRlciIsIm5leHQiLCJtYXliZUNoaWxkIiwiZmlyc3RDaGlsZCIsImFkZE1hcmsiLCJ0ciIsInJlbW92ZWQiLCJhZGRlZCIsInJlbW92aW5nIiwiYWRkaW5nIiwibm9kZXNCZXR3ZWVuIiwibm9kZVNpemUiLCJzIiwic3RlcCIsInJlbW92ZU1hcmsiLCJtYXRjaGVkIiwidG9SZW1vdmUiLCJzZXQiLCJmb3VuZCIsInN0eWxlIiwiaiIsImNsZWFySW5jb21wYXRpYmxlIiwicGFyZW50VHlwZSIsIm1hdGNoIiwiY29udGVudE1hdGNoIiwiY2xlYXJOZXdsaW5lcyIsInJlcGxTdGVwcyIsImN1ciIsImFsbG93ZWQiLCJtYXRjaFR5cGUiLCJpc1RleHQiLCJ3aGl0ZXNwYWNlIiwibmV3bGluZSIsImV4ZWMiLCJ0ZXh0IiwiYWxsb3dlZE1hcmtzIiwidmFsaWRFbmQiLCJmaWxsIiwiZmlsbEJlZm9yZSIsImNhbkN1dCIsImNhblJlcGxhY2UiLCJsaWZ0VGFyZ2V0IiwicmFuZ2UiLCJjdXRCeUluZGV4Iiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiJHRvIiwic3BlYyIsImlzb2xhdGluZyIsImxpZnQiLCJ0YXJnZXQiLCJnYXBTdGFydCIsImJlZm9yZSIsImdhcEVuZCIsImFmdGVyIiwiZCIsInNwbGl0dGluZyIsImZpbmRXcmFwcGluZyIsIm5vZGVUeXBlIiwiaW5uZXJSYW5nZSIsImFyb3VuZCIsImZpbmRXcmFwcGluZ091dHNpZGUiLCJpbm5lciIsImZpbmRXcmFwcGluZ0luc2lkZSIsIndpdGhBdHRycyIsImNvbmNhdCIsImNvbnRlbnRNYXRjaEF0Iiwib3V0ZXIiLCJjYW5SZXBsYWNlV2l0aCIsImluc2lkZSIsImxhc3RUeXBlIiwiaW5uZXJNYXRjaCIsIndyYXAiLCJ3cmFwcGVycyIsIm1hdGNoRnJhZ21lbnQiLCJzZXRCbG9ja1R5cGUiLCJpc1RleHRibG9jayIsIm1hcEZyb20iLCJzdGVwcyIsImhhc01hcmt1cCIsImNhbkNoYW5nZVR5cGUiLCJjb252ZXJ0TmV3bGluZXMiLCJsaW5lYnJlYWtSZXBsYWNlbWVudCIsInByZSIsInN1cHBvcnRMaW5lYnJlYWsiLCJyZXBsYWNlTGluZWJyZWFrcyIsInN0YXJ0TSIsImVuZE0iLCJyZXBsYWNlTmV3bGluZXMiLCJyZXBsYWNlV2l0aCIsIiRwb3MiLCJzZXROb2RlTWFya3VwIiwibmV3Tm9kZSIsInZhbGlkQ29udGVudCIsIm5hbWUiLCJjYW5TcGxpdCIsInR5cGVzQWZ0ZXIiLCJiYXNlIiwiaW5uZXJUeXBlIiwicmVzdCIsIm92ZXJyaWRlQ2hpbGQiLCJyZXBsYWNlQ2hpbGQiLCJiYXNlVHlwZSIsInNwbGl0IiwidHlwZUFmdGVyIiwiY2FuSm9pbiIsImpvaW5hYmxlIiwibm9kZUJlZm9yZSIsIm5vZGVBZnRlciIsImEiLCJiIiwiY2FuQXBwZW5kIiwiam9pblBvaW50IiwiZGlyIiwiam9pbiIsImluc2VydFBvaW50IiwicGFyZW50T2Zmc2V0IiwiZHJvcFBvaW50IiwicGFzcyIsImJpYXMiLCJpbnNlcnRQb3MiLCJmaXRzIiwid3JhcHBpbmciLCJyZXBsYWNlU3RlcCIsImZpdHNUcml2aWFsbHkiLCJGaXR0ZXIiLCJmaXQiLCJ1bnBsYWNlZCIsImZyb250aWVyIiwicGxhY2VkIiwiZmluZEZpdHRhYmxlIiwicGxhY2VOb2RlcyIsIm9wZW5Nb3JlIiwiZHJvcE5vZGUiLCJtb3ZlSW5saW5lIiwibXVzdE1vdmVJbmxpbmUiLCJwbGFjZWRTaXplIiwiY2xvc2UiLCJzdGFydERlcHRoIiwic2xpY2VEZXB0aCIsImNvbnRlbnRBdCIsImZpcnN0IiwiZnJvbnRpZXJEZXB0aCIsImluamVjdCIsImNvbXBhdGlibGVDb250ZW50Iiwib3BlbkF0RW5kIiwiZHJvcEZyb21GcmFnbWVudCIsImNsb3NlRnJvbnRpZXJOb2RlIiwib3BlbkZyb250aWVyTm9kZSIsInRha2VuIiwiYWRkIiwib3BlbkVuZENvdW50IiwibWF0Y2hlcyIsImNsb3NlTm9kZVN0YXJ0IiwidG9FbmQiLCJhZGRUb0ZyYWdtZW50IiwibGFzdENoaWxkIiwidG9wIiwibGV2ZWwiLCJjb250ZW50QWZ0ZXJGaXRzIiwiZmluZENsb3NlTGV2ZWwiLCJzY2FuIiwiZHJvcElubmVyIiwibW92ZSIsIm9wZW4iLCJwb3AiLCJjb3VudCIsImZyYWciLCJpbnZhbGlkTWFya3MiLCJhbGxvd3NNYXJrcyIsImRlZmluZXNDb250ZW50IiwiZGVmaW5pbmciLCJkZWZpbmluZ0ZvckNvbnRlbnQiLCJyZXBsYWNlUmFuZ2UiLCJkZWxldGVSYW5nZSIsInRhcmdldERlcHRocyIsImNvdmVyZWREZXB0aHMiLCJwcmVmZXJyZWRUYXJnZXQiLCJ1bnNoaWZ0IiwiZGVmaW5pbmdBc0NvbnRleHQiLCJpbmRleE9mIiwic3BsaWNlIiwicHJlZmVycmVkVGFyZ2V0SW5kZXgiLCJsZWZ0Tm9kZXMiLCJwcmVmZXJyZWREZXB0aCIsImxlZnROb2RlIiwiZGVmIiwic2FtZU1hcmt1cCIsImFicyIsIm9wZW5EZXB0aCIsInRhcmdldERlcHRoIiwiZXhwYW5kIiwiY2xvc2VGcmFnbWVudCIsInN0YXJ0U3RlcHMiLCJvbGRPcGVuIiwibmV3T3BlbiIsInJlcGxhY2VSYW5nZVdpdGgiLCJwb2ludCIsImNvdmVyZWQiLCJsYXN0IiwiZGVsZXRlIiwibWluRGVwdGgiLCJpbmxpbmVDb250ZW50IiwiQXR0clN0ZXAiLCJhdHRyIiwiRG9jQXR0clN0ZXAiLCJUcmFuc2Zvcm1FcnJvciIsIkVycm9yIiwiZXJyIiwiY2FsbCIsIl9fcHJvdG9fXyIsIlRyYW5zZm9ybSIsImRvY3MiLCJtYXliZVN0ZXAiLCJhZGRTdGVwIiwiZG9jQ2hhbmdlZCIsInNldE5vZGVBdHRyaWJ1dGUiLCJzZXREb2NBdHRyaWJ1dGUiLCJhZGROb2RlTWFyayIsInJlbW92ZU5vZGVNYXJrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-transform/dist/index.js\n");

/***/ })

};
;