"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-model";
exports.ids = ["vendor-chunks/prosemirror-model"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* binding */ ContentMatch),\n/* harmony export */   DOMParser: () => (/* binding */ DOMParser),\n/* harmony export */   DOMSerializer: () => (/* binding */ DOMSerializer),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkType: () => (/* binding */ MarkType),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodeRange: () => (/* binding */ NodeRange),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   ReplaceError: () => (/* binding */ ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* binding */ ResolvedPos),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Slice: () => (/* binding */ Slice)\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"(ssr)/./node_modules/orderedmap/dist/index.js\");\n\nfunction findDiffStart(a, b, pos) {\n    for(let i = 0;; i++){\n        if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n        let childA = a.child(i), childB = b.child(i);\n        if (childA == childB) {\n            pos += childA.nodeSize;\n            continue;\n        }\n        if (!childA.sameMarkup(childB)) return pos;\n        if (childA.isText && childA.text != childB.text) {\n            for(let j = 0; childA.text[j] == childB.text[j]; j++)pos++;\n            return pos;\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffStart(childA.content, childB.content, pos + 1);\n            if (inner != null) return inner;\n        }\n        pos += childA.nodeSize;\n    }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n    for(let iA = a.childCount, iB = b.childCount;;){\n        if (iA == 0 || iB == 0) return iA == iB ? null : {\n            a: posA,\n            b: posB\n        };\n        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n        if (childA == childB) {\n            posA -= size;\n            posB -= size;\n            continue;\n        }\n        if (!childA.sameMarkup(childB)) return {\n            a: posA,\n            b: posB\n        };\n        if (childA.isText && childA.text != childB.text) {\n            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n            while(same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]){\n                same++;\n                posA--;\n                posB--;\n            }\n            return {\n                a: posA,\n                b: posB\n            };\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n            if (inner) return inner;\n        }\n        posA -= size;\n        posB -= size;\n    }\n}\n/**\nA fragment represents a node's collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/ class Fragment {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ content, size){\n        this.content = content;\n        this.size = size || 0;\n        if (size == null) for(let i = 0; i < content.length; i++)this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */ nodesBetween(from, to, f, nodeStart = 0, parent) {\n        for(let i = 0, pos = 0; pos < to; i++){\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n                let start = pos + 1;\n                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n            }\n            pos = end;\n        }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */ descendants(f) {\n        this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */ textBetween(from, to, blockSeparator, leafText) {\n        let text = \"\", first = true;\n        this.nodesBetween(from, to, (node, pos)=>{\n            let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n            if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n                if (first) first = false;\n                else text += blockSeparator;\n            }\n            text += nodeText;\n        }, 0);\n        return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */ append(other) {\n        if (!other.size) return this;\n        if (!this.size) return other;\n        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n        if (last.isText && last.sameMarkup(first)) {\n            content[content.length - 1] = last.withText(last.text + first.text);\n            i = 1;\n        }\n        for(; i < other.content.length; i++)content.push(other.content[i]);\n        return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */ cut(from, to = this.size) {\n        if (from == 0 && to == this.size) return this;\n        let result = [], size = 0;\n        if (to > from) for(let i = 0, pos = 0; pos < to; i++){\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from) {\n                if (pos < from || end > to) {\n                    if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n                    else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n                }\n                result.push(child);\n                size += child.nodeSize;\n            }\n            pos = end;\n        }\n        return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */ cutByIndex(from, to) {\n        if (from == to) return Fragment.empty;\n        if (from == 0 && to == this.content.length) return this;\n        return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */ replaceChild(index, node) {\n        let current = this.content[index];\n        if (current == node) return this;\n        let copy = this.content.slice();\n        let size = this.size + node.nodeSize - current.nodeSize;\n        copy[index] = node;\n        return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */ addToStart(node) {\n        return new Fragment([\n            node\n        ].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */ addToEnd(node) {\n        return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */ eq(other) {\n        if (this.content.length != other.content.length) return false;\n        for(let i = 0; i < this.content.length; i++)if (!this.content[i].eq(other.content[i])) return false;\n        return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */ get firstChild() {\n        return this.content.length ? this.content[0] : null;\n    }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */ get lastChild() {\n        return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n    /**\n    The number of child nodes in this fragment.\n    */ get childCount() {\n        return this.content.length;\n    }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */ child(index) {\n        let found = this.content[index];\n        if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n        return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */ maybeChild(index) {\n        return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */ forEach(f) {\n        for(let i = 0, p = 0; i < this.content.length; i++){\n            let child = this.content[i];\n            f(child, p, i);\n            p += child.nodeSize;\n        }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */ findDiffStart(other, pos = 0) {\n        return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */ findDiffEnd(other, pos = this.size, otherPos = other.size) {\n        return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. (Not public.)\n    */ findIndex(pos, round = -1) {\n        if (pos == 0) return retIndex(0, pos);\n        if (pos == this.size) return retIndex(this.content.length, pos);\n        if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n        for(let i = 0, curPos = 0;; i++){\n            let cur = this.child(i), end = curPos + cur.nodeSize;\n            if (end >= pos) {\n                if (end == pos || round > 0) return retIndex(i + 1, end);\n                return retIndex(i, curPos);\n            }\n            curPos = end;\n        }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */ toString() {\n        return \"<\" + this.toStringInner() + \">\";\n    }\n    /**\n    @internal\n    */ toStringInner() {\n        return this.content.join(\", \");\n    }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */ toJSON() {\n        return this.content.length ? this.content.map((n)=>n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */ static fromJSON(schema, value) {\n        if (!value) return Fragment.empty;\n        if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n        return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */ static fromArray(array) {\n        if (!array.length) return Fragment.empty;\n        let joined, size = 0;\n        for(let i = 0; i < array.length; i++){\n            let node = array[i];\n            size += node.nodeSize;\n            if (i && node.isText && array[i - 1].sameMarkup(node)) {\n                if (!joined) joined = array.slice(0, i);\n                joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n            } else if (joined) {\n                joined.push(node);\n            }\n        }\n        return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */ static from(nodes) {\n        if (!nodes) return Fragment.empty;\n        if (nodes instanceof Fragment) return nodes;\n        if (Array.isArray(nodes)) return this.fromArray(nodes);\n        if (nodes.attrs) return new Fragment([\n            nodes\n        ], nodes.nodeSize);\n        throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n}\n/**\nAn empty fragment. Intended to be reused whenever a node doesn't\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/ Fragment.empty = new Fragment([], 0);\nconst found = {\n    index: 0,\n    offset: 0\n};\nfunction retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n}\nfunction compareDeep(a, b) {\n    if (a === b) return true;\n    if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\")) return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array) return false;\n    if (array) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++)if (!compareDeep(a[i], b[i])) return false;\n    } else {\n        for(let p in a)if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n        for(let p in b)if (!(p in a)) return false;\n    }\n    return true;\n}\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/ class Mark {\n    /**\n    @internal\n    */ constructor(/**\n    The type of this mark.\n    */ type, /**\n    The attributes associated with this mark.\n    */ attrs){\n        this.type = type;\n        this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */ addToSet(set) {\n        let copy, placed = false;\n        for(let i = 0; i < set.length; i++){\n            let other = set[i];\n            if (this.eq(other)) return set;\n            if (this.type.excludes(other.type)) {\n                if (!copy) copy = set.slice(0, i);\n            } else if (other.type.excludes(this.type)) {\n                return set;\n            } else {\n                if (!placed && other.type.rank > this.type.rank) {\n                    if (!copy) copy = set.slice(0, i);\n                    copy.push(this);\n                    placed = true;\n                }\n                if (copy) copy.push(other);\n            }\n        }\n        if (!copy) copy = set.slice();\n        if (!placed) copy.push(this);\n        return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */ removeFromSet(set) {\n        for(let i = 0; i < set.length; i++)if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n        return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */ isInSet(set) {\n        for(let i = 0; i < set.length; i++)if (this.eq(set[i])) return true;\n        return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */ eq(other) {\n        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */ toJSON() {\n        let obj = {\n            type: this.type.name\n        };\n        for(let _ in this.attrs){\n            obj.attrs = this.attrs;\n            break;\n        }\n        return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */ static fromJSON(schema, json) {\n        if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n        let type = schema.marks[json.type];\n        if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`);\n        return type.create(json.attrs);\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */ static sameSet(a, b) {\n        if (a == b) return true;\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++)if (!a[i].eq(b[i])) return false;\n        return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */ static setFrom(marks) {\n        if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n        if (marks instanceof Mark) return [\n            marks\n        ];\n        let copy = marks.slice();\n        copy.sort((a, b)=>a.type.rank - b.type.rank);\n        return copy;\n    }\n}\n/**\nThe empty set of marks.\n*/ Mark.none = [];\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/ class ReplaceError extends Error {\n}\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n*/ /**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/ class Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */ constructor(/**\n    The slice's content.\n    */ content, /**\n    The open depth at the start of the fragment.\n    */ openStart, /**\n    The open depth at the end.\n    */ openEnd){\n        this.content = content;\n        this.openStart = openStart;\n        this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */ get size() {\n        return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */ insertAt(pos, fragment) {\n        let content = insertInto(this.content, pos + this.openStart, fragment);\n        return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */ removeBetween(from, to) {\n        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */ eq(other) {\n        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */ toJSON() {\n        if (!this.content.size) return null;\n        let json = {\n            content: this.content.toJSON()\n        };\n        if (this.openStart > 0) json.openStart = this.openStart;\n        if (this.openEnd > 0) json.openEnd = this.openEnd;\n        return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */ static fromJSON(schema, json) {\n        if (!json) return Slice.empty;\n        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n        if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */ static maxOpen(fragment, openIsolating = true) {\n        let openStart = 0, openEnd = 0;\n        for(let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)openStart++;\n        for(let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)openEnd++;\n        return new Slice(fragment, openStart, openEnd);\n    }\n}\n/**\nThe empty slice.\n*/ Slice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from || child.isText) {\n        if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n        return content.cut(0, from).append(content.cut(to));\n    }\n    if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n        if (parent && !parent.canReplace(index, index, insert)) return null;\n        return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert);\n    return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n    if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n        let inner = replaceOuter($from, $to, slice, depth + 1);\n        return node.copy(node.content.replaceChild(index, inner));\n    } else if (!slice.content.size) {\n        return close(node, replaceTwoWay($from, $to, depth));\n    } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n        let parent = $from.parent, content = parent.content;\n        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n    } else {\n        let { start, end } = prepareSliceForReplace(slice, $from);\n        return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n}\nfunction checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n}\nfunction addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);\n    else target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n        startIndex = $start.index(depth);\n        if ($start.depth > depth) {\n            startIndex++;\n        } else if ($start.textOffset) {\n            addNode($start.nodeAfter, target);\n            startIndex++;\n        }\n    }\n    for(let i = startIndex; i < endIndex; i++)addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n        checkJoin(openStart, openEnd);\n        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    } else {\n        if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n        addRange($start, $end, depth, content);\n        if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n        let type = joinable($from, $to, depth + 1);\n        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n    let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice.content);\n    for(let i = extra - 1; i >= 0; i--)node = $along.node(i).copy(Fragment.from(node));\n    return {\n        start: node.resolveNoCache(slice.openStart + extra),\n        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n    };\n}\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/ class ResolvedPos {\n    /**\n    @internal\n    */ constructor(/**\n    The position that was resolved.\n    */ pos, /**\n    @internal\n    */ path, /**\n    The offset this position has into its parent node.\n    */ parentOffset){\n        this.pos = pos;\n        this.path = path;\n        this.parentOffset = parentOffset;\n        this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */ resolveDepth(val) {\n        if (val == null) return this.depth;\n        if (val < 0) return this.depth + val;\n        return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */ get parent() {\n        return this.node(this.depth);\n    }\n    /**\n    The root node in which the position was resolved.\n    */ get doc() {\n        return this.node(0);\n    }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */ node(depth) {\n        return this.path[this.resolveDepth(depth) * 3];\n    }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */ index(depth) {\n        return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */ indexAfter(depth) {\n        depth = this.resolveDepth(depth);\n        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */ start(depth) {\n        depth = this.resolveDepth(depth);\n        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */ end(depth) {\n        depth = this.resolveDepth(depth);\n        return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */ before(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */ after(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */ get textOffset() {\n        return this.pos - this.path[this.path.length - 1];\n    }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */ get nodeAfter() {\n        let parent = this.parent, index = this.index(this.depth);\n        if (index == parent.childCount) return null;\n        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n        return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */ get nodeBefore() {\n        let index = this.index(this.depth);\n        let dOff = this.pos - this.path[this.path.length - 1];\n        if (dOff) return this.parent.child(index).cut(0, dOff);\n        return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */ posAtIndex(index, depth) {\n        depth = this.resolveDepth(depth);\n        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n        for(let i = 0; i < index; i++)pos += node.child(i).nodeSize;\n        return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */ marks() {\n        let parent = this.parent, index = this.index();\n        // In an empty parent, return the empty array\n        if (parent.content.size == 0) return Mark.none;\n        // When inside a text node, just return the text node's marks\n        if (this.textOffset) return parent.child(index).marks;\n        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n        // If the `after` flag is true of there is no node before, make\n        // the node after this position the main reference.\n        if (!main) {\n            let tmp = main;\n            main = other;\n            other = tmp;\n        }\n        // Use all marks in the main node, except those that have\n        // `inclusive` set to false and are not present in the other node.\n        let marks = main.marks;\n        for(var i = 0; i < marks.length; i++)if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */ marksAcross($end) {\n        let after = this.parent.maybeChild(this.index());\n        if (!after || !after.isInline) return null;\n        let marks = after.marks, next = $end.parent.maybeChild($end.index());\n        for(var i = 0; i < marks.length; i++)if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */ sharedDepth(pos) {\n        for(let depth = this.depth; depth > 0; depth--)if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n        return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */ blockRange(other = this, pred) {\n        if (other.pos < this.pos) return other.blockRange(this);\n        for(let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n        return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */ sameParent(other) {\n        return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */ max(other) {\n        return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */ min(other) {\n        return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */ toString() {\n        let str = \"\";\n        for(let i = 1; i <= this.depth; i++)str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n        return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */ static resolve(doc, pos) {\n        if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n        let path = [];\n        let start = 0, parentOffset = pos;\n        for(let node = doc;;){\n            let { index, offset } = node.content.findIndex(parentOffset);\n            let rem = parentOffset - offset;\n            path.push(node, index, start + offset);\n            if (!rem) break;\n            node = node.child(index);\n            if (node.isText) break;\n            parentOffset = rem - 1;\n            start += offset + 1;\n        }\n        return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */ static resolveCached(doc, pos) {\n        for(let i = 0; i < resolveCache.length; i++){\n            let cached = resolveCache[i];\n            if (cached.pos == pos && cached.doc == doc) return cached;\n        }\n        let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n        resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n        return result;\n    }\n}\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/ class NodeRange {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */ constructor(/**\n    A resolved position along the start of the content. May have a\n    `depth` greater than this object's `depth` property, since\n    these are the positions that were used to compute the range,\n    not re-resolved positions directly at its boundaries.\n    */ $from, /**\n    A position along the end of the content. See\n    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n    */ $to, /**\n    The depth of the node that this range points into.\n    */ depth){\n        this.$from = $from;\n        this.$to = $to;\n        this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */ get start() {\n        return this.$from.before(this.depth + 1);\n    }\n    /**\n    The position at the end of the range.\n    */ get end() {\n        return this.$to.after(this.depth + 1);\n    }\n    /**\n    The parent node that the range points into.\n    */ get parent() {\n        return this.$from.node(this.depth);\n    }\n    /**\n    The start index of the range in the parent node.\n    */ get startIndex() {\n        return this.$from.index(this.depth);\n    }\n    /**\n    The end index of the range in the parent node.\n    */ get endIndex() {\n        return this.$to.indexAfter(this.depth);\n    }\n}\nconst emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](/docs/guide/#doc) for more information.\n*/ class Node {\n    /**\n    @internal\n    */ constructor(/**\n    The type of node that this is.\n    */ type, /**\n    An object mapping attribute names to values. The kind of\n    attributes allowed and required are\n    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n    */ attrs, // A fragment holding the node's children.\n    content, /**\n    The marks (things like whether it is emphasized or part of a\n    link) applied to this node.\n    */ marks = Mark.none){\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.content = content || Fragment.empty;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */ get nodeSize() {\n        return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n    /**\n    The number of children that the node has.\n    */ get childCount() {\n        return this.content.childCount;\n    }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */ child(index) {\n        return this.content.child(index);\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */ maybeChild(index) {\n        return this.content.maybeChild(index);\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */ forEach(f) {\n        this.content.forEach(f);\n    }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */ nodesBetween(from, to, f, startPos = 0) {\n        this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */ descendants(f) {\n        this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */ get textContent() {\n        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.\n    */ textBetween(from, to, blockSeparator, leafText) {\n        return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */ get firstChild() {\n        return this.content.firstChild;\n    }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */ get lastChild() {\n        return this.content.lastChild;\n    }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */ eq(other) {\n        return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */ sameMarkup(other) {\n        return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */ hasMarkup(type, attrs, marks) {\n        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */ copy(content = null) {\n        if (content == this.content) return this;\n        return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */ mark(marks) {\n        return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */ cut(from, to = this.content.size) {\n        if (from == 0 && to == this.content.size) return this;\n        return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */ slice(from, to = this.content.size, includeParents = false) {\n        if (from == to) return Slice.empty;\n        let $from = this.resolve(from), $to = this.resolve(to);\n        let depth = includeParents ? 0 : $from.sharedDepth(to);\n        let start = $from.start(depth), node = $from.node(depth);\n        let content = node.content.cut($from.pos - start, $to.pos - start);\n        return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */ replace(from, to, slice) {\n        return replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */ nodeAt(pos) {\n        for(let node = this;;){\n            let { index, offset } = node.content.findIndex(pos);\n            node = node.maybeChild(index);\n            if (!node) return null;\n            if (offset == pos || node.isText) return node;\n            pos -= offset + 1;\n        }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */ childAfter(pos) {\n        let { index, offset } = this.content.findIndex(pos);\n        return {\n            node: this.content.maybeChild(index),\n            index,\n            offset\n        };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */ childBefore(pos) {\n        if (pos == 0) return {\n            node: null,\n            index: 0,\n            offset: 0\n        };\n        let { index, offset } = this.content.findIndex(pos);\n        if (offset < pos) return {\n            node: this.content.child(index),\n            index,\n            offset\n        };\n        let node = this.content.child(index - 1);\n        return {\n            node,\n            index: index - 1,\n            offset: offset - node.nodeSize\n        };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */ resolve(pos) {\n        return ResolvedPos.resolveCached(this, pos);\n    }\n    /**\n    @internal\n    */ resolveNoCache(pos) {\n        return ResolvedPos.resolve(this, pos);\n    }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */ rangeHasMark(from, to, type) {\n        let found = false;\n        if (to > from) this.nodesBetween(from, to, (node)=>{\n            if (type.isInSet(node.marks)) found = true;\n            return !found;\n        });\n        return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */ get isBlock() {\n        return this.type.isBlock;\n    }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */ get isTextblock() {\n        return this.type.isTextblock;\n    }\n    /**\n    True when this node allows inline content.\n    */ get inlineContent() {\n        return this.type.inlineContent;\n    }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */ get isInline() {\n        return this.type.isInline;\n    }\n    /**\n    True when this is a text node.\n    */ get isText() {\n        return this.type.isText;\n    }\n    /**\n    True when this is a leaf node.\n    */ get isLeaf() {\n        return this.type.isLeaf;\n    }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */ get isAtom() {\n        return this.type.isAtom;\n    }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */ toString() {\n        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n        let name = this.type.name;\n        if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n        return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */ contentMatchAt(index) {\n        let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n        if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n        return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */ canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n        let two = one && one.matchFragment(this.content, to);\n        if (!two || !two.validEnd) return false;\n        for(let i = start; i < end; i++)if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n        return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */ canReplaceWith(from, to, type, marks) {\n        if (marks && !this.type.allowsMarks(marks)) return false;\n        let start = this.contentMatchAt(from).matchType(type);\n        let end = start && start.matchFragment(this.content, to);\n        return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */ canAppend(other) {\n        if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);\n        else return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise error when they do not.\n    */ check() {\n        this.type.checkContent(this.content);\n        let copy = Mark.none;\n        for(let i = 0; i < this.marks.length; i++)copy = this.marks[i].addToSet(copy);\n        if (!Mark.sameSet(copy, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m)=>m.type.name)}`);\n        this.content.forEach((node)=>node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */ toJSON() {\n        let obj = {\n            type: this.type.name\n        };\n        for(let _ in this.attrs){\n            obj.attrs = this.attrs;\n            break;\n        }\n        if (this.content.size) obj.content = this.content.toJSON();\n        if (this.marks.length) obj.marks = this.marks.map((n)=>n.toJSON());\n        return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */ static fromJSON(schema, json) {\n        if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n        let marks = null;\n        if (json.marks) {\n            if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n            marks = json.marks.map(schema.markFromJSON);\n        }\n        if (json.type == \"text\") {\n            if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n            return schema.text(json.text, marks);\n        }\n        let content = Fragment.fromJSON(schema, json.content);\n        return schema.nodeType(json.type).create(json.attrs, content, marks);\n    }\n}\nNode.prototype.text = undefined;\nclass TextNode extends Node {\n    /**\n    @internal\n    */ constructor(type, attrs, content, marks){\n        super(type, attrs, null, marks);\n        if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n        this.text = content;\n    }\n    toString() {\n        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n        return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() {\n        return this.text;\n    }\n    textBetween(from, to) {\n        return this.text.slice(from, to);\n    }\n    get nodeSize() {\n        return this.text.length;\n    }\n    mark(marks) {\n        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n    withText(text) {\n        if (text == this.text) return this;\n        return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from = 0, to = this.text.length) {\n        if (from == 0 && to == this.text.length) return this;\n        return this.withText(this.text.slice(from, to));\n    }\n    eq(other) {\n        return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n        let base = super.toJSON();\n        base.text = this.text;\n        return base;\n    }\n}\nfunction wrapMarks(marks, str) {\n    for(let i = marks.length - 1; i >= 0; i--)str = marks[i].type.name + \"(\" + str + \")\";\n    return str;\n}\n/**\nInstances of this class represent a match state of a node type's\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/ class ContentMatch {\n    /**\n    @internal\n    */ constructor(/**\n    True when this match state represents a valid end of the node.\n    */ validEnd){\n        this.validEnd = validEnd;\n        /**\n        @internal\n        */ this.next = [];\n        /**\n        @internal\n        */ this.wrapCache = [];\n    }\n    /**\n    @internal\n    */ static parse(string, nodeTypes) {\n        let stream = new TokenStream(string, nodeTypes);\n        if (stream.next == null) return ContentMatch.empty;\n        let expr = parseExpr(stream);\n        if (stream.next) stream.err(\"Unexpected trailing text\");\n        let match = dfa(nfa(expr));\n        checkForDeadEnds(match, stream);\n        return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */ matchType(type) {\n        for(let i = 0; i < this.next.length; i++)if (this.next[i].type == type) return this.next[i].next;\n        return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */ matchFragment(frag, start = 0, end = frag.childCount) {\n        let cur = this;\n        for(let i = start; cur && i < end; i++)cur = cur.matchType(frag.child(i).type);\n        return cur;\n    }\n    /**\n    @internal\n    */ get inlineContent() {\n        return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */ get defaultType() {\n        for(let i = 0; i < this.next.length; i++){\n            let { type } = this.next[i];\n            if (!(type.isText || type.hasRequiredAttrs())) return type;\n        }\n        return null;\n    }\n    /**\n    @internal\n    */ compatible(other) {\n        for(let i = 0; i < this.next.length; i++)for(let j = 0; j < other.next.length; j++)if (this.next[i].type == other.next[j].type) return true;\n        return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */ fillBefore(after, toEnd = false, startIndex = 0) {\n        let seen = [\n            this\n        ];\n        function search(match, types) {\n            let finished = match.matchFragment(after, startIndex);\n            if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map((tp)=>tp.createAndFill()));\n            for(let i = 0; i < match.next.length; i++){\n                let { type, next } = match.next[i];\n                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n                    seen.push(next);\n                    let found = search(next, types.concat(type));\n                    if (found) return found;\n                }\n            }\n            return null;\n        }\n        return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */ findWrapping(target) {\n        for(let i = 0; i < this.wrapCache.length; i += 2)if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n        let computed = this.computeWrapping(target);\n        this.wrapCache.push(target, computed);\n        return computed;\n    }\n    /**\n    @internal\n    */ computeWrapping(target) {\n        let seen = Object.create(null), active = [\n            {\n                match: this,\n                type: null,\n                via: null\n            }\n        ];\n        while(active.length){\n            let current = active.shift(), match = current.match;\n            if (match.matchType(target)) {\n                let result = [];\n                for(let obj = current; obj.type; obj = obj.via)result.push(obj.type);\n                return result.reverse();\n            }\n            for(let i = 0; i < match.next.length; i++){\n                let { type, next } = match.next[i];\n                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n                    active.push({\n                        match: type.contentMatch,\n                        type,\n                        via: current\n                    });\n                    seen[type.name] = true;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */ get edgeCount() {\n        return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */ edge(n) {\n        if (n >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`);\n        return this.next[n];\n    }\n    /**\n    @internal\n    */ toString() {\n        let seen = [];\n        function scan(m) {\n            seen.push(m);\n            for(let i = 0; i < m.next.length; i++)if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n        }\n        scan(this);\n        return seen.map((m, i)=>{\n            let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n            for(let i = 0; i < m.next.length; i++)out += (i ? \", \" : \"\") + m.next[i].type.name + \"->\" + seen.indexOf(m.next[i].next);\n            return out;\n        }).join(\"\\n\");\n    }\n}\n/**\n@internal\n*/ ContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n    constructor(string, nodeTypes){\n        this.string = string;\n        this.nodeTypes = nodeTypes;\n        this.inline = null;\n        this.pos = 0;\n        this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n        if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n        if (this.tokens[0] == \"\") this.tokens.shift();\n    }\n    get next() {\n        return this.tokens[this.pos];\n    }\n    eat(tok) {\n        return this.next == tok && (this.pos++ || true);\n    }\n    err(str) {\n        throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n}\nfunction parseExpr(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSeq(stream));\n    }while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : {\n        type: \"choice\",\n        exprs\n    };\n}\nfunction parseExprSeq(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSubscript(stream));\n    }while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : {\n        type: \"seq\",\n        exprs\n    };\n}\nfunction parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for(;;){\n        if (stream.eat(\"+\")) expr = {\n            type: \"plus\",\n            expr\n        };\n        else if (stream.eat(\"*\")) expr = {\n            type: \"star\",\n            expr\n        };\n        else if (stream.eat(\"?\")) expr = {\n            type: \"opt\",\n            expr\n        };\n        else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);\n        else break;\n    }\n    return expr;\n}\nfunction parseNum(stream) {\n    if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n}\nfunction parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(\",\")) {\n        if (stream.next != \"}\") max = parseNum(stream);\n        else max = -1;\n    }\n    if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n    return {\n        type: \"range\",\n        min,\n        max,\n        expr\n    };\n}\nfunction resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type) return [\n        type\n    ];\n    let result = [];\n    for(let typeName in types){\n        let type = types[typeName];\n        if (type.groups.indexOf(name) > -1) result.push(type);\n    }\n    if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n}\nfunction parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n        let expr = parseExpr(stream);\n        if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n        return expr;\n    } else if (!/\\W/.test(stream.next)) {\n        let exprs = resolveName(stream, stream.next).map((type)=>{\n            if (stream.inline == null) stream.inline = type.isInline;\n            else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n            return {\n                type: \"name\",\n                value: type\n            };\n        });\n        stream.pos++;\n        return exprs.length == 1 ? exprs[0] : {\n            type: \"choice\",\n            exprs\n        };\n    } else {\n        stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n}\n/**\nConstruct an NFA from an expression as returned by the parser. The\nNFA is represented as an array of states, which are themselves\narrays of edges, which are `{term, to}` objects. The first state is\nthe entry state and the last node is the success state.\n\nNote that unlike typical NFAs, the edge ordering in this one is\nsignificant, in that it is used to contruct filler content when\nnecessary.\n*/ function nfa(expr) {\n    let nfa = [\n        []\n    ];\n    connect(compile(expr, 0), node());\n    return nfa;\n    function node() {\n        return nfa.push([]) - 1;\n    }\n    function edge(from, to, term) {\n        let edge = {\n            term,\n            to\n        };\n        nfa[from].push(edge);\n        return edge;\n    }\n    function connect(edges, to) {\n        edges.forEach((edge)=>edge.to = to);\n    }\n    function compile(expr, from) {\n        if (expr.type == \"choice\") {\n            return expr.exprs.reduce((out, expr)=>out.concat(compile(expr, from)), []);\n        } else if (expr.type == \"seq\") {\n            for(let i = 0;; i++){\n                let next = compile(expr.exprs[i], from);\n                if (i == expr.exprs.length - 1) return next;\n                connect(next, from = node());\n            }\n        } else if (expr.type == \"star\") {\n            let loop = node();\n            edge(from, loop);\n            connect(compile(expr.expr, loop), loop);\n            return [\n                edge(loop)\n            ];\n        } else if (expr.type == \"plus\") {\n            let loop = node();\n            connect(compile(expr.expr, from), loop);\n            connect(compile(expr.expr, loop), loop);\n            return [\n                edge(loop)\n            ];\n        } else if (expr.type == \"opt\") {\n            return [\n                edge(from)\n            ].concat(compile(expr.expr, from));\n        } else if (expr.type == \"range\") {\n            let cur = from;\n            for(let i = 0; i < expr.min; i++){\n                let next = node();\n                connect(compile(expr.expr, cur), next);\n                cur = next;\n            }\n            if (expr.max == -1) {\n                connect(compile(expr.expr, cur), cur);\n            } else {\n                for(let i = expr.min; i < expr.max; i++){\n                    let next = node();\n                    edge(cur, next);\n                    connect(compile(expr.expr, cur), next);\n                    cur = next;\n                }\n            }\n            return [\n                edge(cur)\n            ];\n        } else if (expr.type == \"name\") {\n            return [\n                edge(from, undefined, expr.value)\n            ];\n        } else {\n            throw new Error(\"Unknown expr type\");\n        }\n    }\n}\nfunction cmp(a, b) {\n    return b - a;\n}\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node) {\n        let edges = nfa[node];\n        if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n        result.push(node);\n        for(let i = 0; i < edges.length; i++){\n            let { term, to } = edges[i];\n            if (!term && result.indexOf(to) == -1) scan(to);\n        }\n    }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n    let labeled = Object.create(null);\n    return explore(nullFrom(nfa, 0));\n    function explore(states) {\n        let out = [];\n        states.forEach((node)=>{\n            nfa[node].forEach(({ term, to })=>{\n                if (!term) return;\n                let set;\n                for(let i = 0; i < out.length; i++)if (out[i][0] == term) set = out[i][1];\n                nullFrom(nfa, to).forEach((node)=>{\n                    if (!set) out.push([\n                        term,\n                        set = []\n                    ]);\n                    if (set.indexOf(node) == -1) set.push(node);\n                });\n            });\n        });\n        let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n        for(let i = 0; i < out.length; i++){\n            let states = out[i][1].sort(cmp);\n            state.next.push({\n                type: out[i][0],\n                next: labeled[states.join(\",\")] || explore(states)\n            });\n        }\n        return state;\n    }\n}\nfunction checkForDeadEnds(match, stream) {\n    for(let i = 0, work = [\n        match\n    ]; i < work.length; i++){\n        let state = work[i], dead = !state.validEnd, nodes = [];\n        for(let j = 0; j < state.next.length; j++){\n            let { type, next } = state.next[j];\n            nodes.push(type.name);\n            if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n            if (work.indexOf(next) == -1) work.push(next);\n        }\n        if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n}\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n    let defaults = Object.create(null);\n    for(let attrName in attrs){\n        let attr = attrs[attrName];\n        if (!attr.hasDefault) return null;\n        defaults[attrName] = attr.default;\n    }\n    return defaults;\n}\nfunction computeAttrs(attrs, value) {\n    let built = Object.create(null);\n    for(let name in attrs){\n        let given = value && value[name];\n        if (given === undefined) {\n            let attr = attrs[name];\n            if (attr.hasDefault) given = attr.default;\n            else throw new RangeError(\"No value supplied for attribute \" + name);\n        }\n        built[name] = given;\n    }\n    return built;\n}\nfunction initAttrs(attrs) {\n    let result = Object.create(null);\n    if (attrs) for(let name in attrs)result[name] = new Attribute(attrs[name]);\n    return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name the node type has in this schema.\n    */ name, /**\n    A link back to the `Schema` the node type belongs to.\n    */ schema, /**\n    The spec that this type is based on\n    */ spec){\n        this.name = name;\n        this.schema = schema;\n        this.spec = spec;\n        /**\n        The set of marks allowed in this node. `null` means all marks\n        are allowed.\n        */ this.markSet = null;\n        this.groups = spec.group ? spec.group.split(\" \") : [];\n        this.attrs = initAttrs(spec.attrs);\n        this.defaultAttrs = defaultAttrs(this.attrs);\n        this.contentMatch = null;\n        this.inlineContent = null;\n        this.isBlock = !(spec.inline || name == \"text\");\n        this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */ get isInline() {\n        return !this.isBlock;\n    }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */ get isTextblock() {\n        return this.isBlock && this.inlineContent;\n    }\n    /**\n    True for node types that allow no content.\n    */ get isLeaf() {\n        return this.contentMatch == ContentMatch.empty;\n    }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */ get isAtom() {\n        return this.isLeaf || !!this.spec.atom;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */ get whitespace() {\n        return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */ hasRequiredAttrs() {\n        for(let n in this.attrs)if (this.attrs[n].isRequired) return true;\n        return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */ compatibleContent(other) {\n        return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */ computeAttrs(attrs) {\n        if (!attrs && this.defaultAttrs) return this.defaultAttrs;\n        else return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */ create(attrs = null, content, marks) {\n        if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */ createChecked(attrs = null, content, marks) {\n        content = Fragment.from(content);\n        this.checkContent(content);\n        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */ createAndFill(attrs = null, content, marks) {\n        attrs = this.computeAttrs(attrs);\n        content = Fragment.from(content);\n        if (content.size) {\n            let before = this.contentMatch.fillBefore(content);\n            if (!before) return null;\n            content = before.append(content);\n        }\n        let matched = this.contentMatch.matchFragment(content);\n        let after = matched && matched.fillBefore(Fragment.empty, true);\n        if (!after) return null;\n        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */ validContent(content) {\n        let result = this.contentMatch.matchFragment(content);\n        if (!result || !result.validEnd) return false;\n        for(let i = 0; i < content.childCount; i++)if (!this.allowsMarks(content.child(i).marks)) return false;\n        return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */ checkContent(content) {\n        if (!this.validContent(content)) throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */ allowsMarkType(markType) {\n        return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */ allowsMarks(marks) {\n        if (this.markSet == null) return true;\n        for(let i = 0; i < marks.length; i++)if (!this.allowsMarkType(marks[i].type)) return false;\n        return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */ allowedMarks(marks) {\n        if (this.markSet == null) return marks;\n        let copy;\n        for(let i = 0; i < marks.length; i++){\n            if (!this.allowsMarkType(marks[i].type)) {\n                if (!copy) copy = marks.slice(0, i);\n            } else if (copy) {\n                copy.push(marks[i]);\n            }\n        }\n        return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */ static compile(nodes, schema) {\n        let result = Object.create(null);\n        nodes.forEach((name, spec)=>result[name] = new NodeType(name, schema, spec));\n        let topType = schema.spec.topNode || \"doc\";\n        if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n        if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n        for(let _ in result.text.attrs)throw new RangeError(\"The text node type should not have attributes\");\n        return result;\n    }\n}\n// Attribute descriptors\nclass Attribute {\n    constructor(options){\n        this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n        this.default = options.default;\n    }\n    get isRequired() {\n        return !this.hasDefault;\n    }\n}\n// Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/ class MarkType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the mark type.\n    */ name, /**\n    @internal\n    */ rank, /**\n    The schema that this mark type instance is part of.\n    */ schema, /**\n    The spec on which the type is based.\n    */ spec){\n        this.name = name;\n        this.rank = rank;\n        this.schema = schema;\n        this.spec = spec;\n        this.attrs = initAttrs(spec.attrs);\n        this.excluded = null;\n        let defaults = defaultAttrs(this.attrs);\n        this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */ create(attrs = null) {\n        if (!attrs && this.instance) return this.instance;\n        return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */ static compile(marks, schema) {\n        let result = Object.create(null), rank = 0;\n        marks.forEach((name, spec)=>result[name] = new MarkType(name, rank++, schema, spec));\n        return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */ removeFromSet(set) {\n        for(var i = 0; i < set.length; i++)if (set[i].type == this) {\n            set = set.slice(0, i).concat(set.slice(i + 1));\n            i--;\n        }\n        return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */ isInSet(set) {\n        for(let i = 0; i < set.length; i++)if (set[i].type == this) return set[i];\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */ excludes(other) {\n        return this.excluded.indexOf(other) > -1;\n    }\n}\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/ class Schema {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */ constructor(spec){\n        /**\n        The [linebreak\n        replacement](https://prosemirror.net/docs/ref/#model.NodeSpec.linebreakReplacement) node defined\n        in this schema, if any.\n        */ this.linebreakReplacement = null;\n        /**\n        An object for storing whatever values modules may want to\n        compute and cache per schema. (If you want to store something\n        in it, try to use property names unlikely to clash.)\n        */ this.cached = Object.create(null);\n        let instanceSpec = this.spec = {};\n        for(let prop in spec)instanceSpec[prop] = spec[prop];\n        instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes), instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n        this.marks = MarkType.compile(this.spec.marks, this);\n        let contentExprCache = Object.create(null);\n        for(let prop in this.nodes){\n            if (prop in this.marks) throw new RangeError(prop + \" can not be both a node and a mark\");\n            let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n            type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n            type.inlineContent = type.contentMatch.inlineContent;\n            if (type.spec.linebreakReplacement) {\n                if (this.linebreakReplacement) throw new RangeError(\"Multiple linebreak nodes defined\");\n                if (!type.isInline || !type.isLeaf) throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n                this.linebreakReplacement = type;\n            }\n            type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n        }\n        for(let prop in this.marks){\n            let type = this.marks[prop], excl = type.spec.excludes;\n            type.excluded = excl == null ? [\n                type\n            ] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n        }\n        this.nodeFromJSON = this.nodeFromJSON.bind(this);\n        this.markFromJSON = this.markFromJSON.bind(this);\n        this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n        this.cached.wrappings = Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */ node(type, attrs = null, content, marks) {\n        if (typeof type == \"string\") type = this.nodeType(type);\n        else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);\n        else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n        return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */ text(text, marks) {\n        let type = this.nodes.text;\n        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */ mark(type, attrs) {\n        if (typeof type == \"string\") type = this.marks[type];\n        return type.create(attrs);\n    }\n    /**\n    Deserialize a node from its JSON representation. This method is\n    bound.\n    */ nodeFromJSON(json) {\n        return Node.fromJSON(this, json);\n    }\n    /**\n    Deserialize a mark from its JSON representation. This method is\n    bound.\n    */ markFromJSON(json) {\n        return Mark.fromJSON(this, json);\n    }\n    /**\n    @internal\n    */ nodeType(name) {\n        let found = this.nodes[name];\n        if (!found) throw new RangeError(\"Unknown node type: \" + name);\n        return found;\n    }\n}\nfunction gatherMarks(schema, marks) {\n    let found = [];\n    for(let i = 0; i < marks.length; i++){\n        let name = marks[i], mark = schema.marks[name], ok = mark;\n        if (mark) {\n            found.push(mark);\n        } else {\n            for(let prop in schema.marks){\n                let mark = schema.marks[prop];\n                if (name == \"_\" || mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = mark);\n            }\n        }\n        if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n    return found;\n}\nfunction isTagRule(rule) {\n    return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n    return rule.style != null;\n}\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/ class DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */ constructor(/**\n    The schema into which the parser parses.\n    */ schema, /**\n    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n    uses, in order of precedence.\n    */ rules){\n        this.schema = schema;\n        this.rules = rules;\n        /**\n        @internal\n        */ this.tags = [];\n        /**\n        @internal\n        */ this.styles = [];\n        rules.forEach((rule)=>{\n            if (isTagRule(rule)) this.tags.push(rule);\n            else if (isStyleRule(rule)) this.styles.push(rule);\n        });\n        // Only normalize list elements when lists in the schema can't directly contain themselves\n        this.normalizeLists = !this.tags.some((r)=>{\n            if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n            let node = schema.nodes[r.node];\n            return node.contentMatch.matchType(node);\n        });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */ parse(dom, options = {}) {\n        let context = new ParseContext(this, options, false);\n        context.addAll(dom, options.from, options.to);\n        return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */ parseSlice(dom, options = {}) {\n        let context = new ParseContext(this, options, true);\n        context.addAll(dom, options.from, options.to);\n        return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */ matchTag(dom, context, after) {\n        for(let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++){\n            let rule = this.tags[i];\n            if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n                if (rule.getAttrs) {\n                    let result = rule.getAttrs(dom);\n                    if (result === false) continue;\n                    rule.attrs = result || undefined;\n                }\n                return rule;\n            }\n        }\n    }\n    /**\n    @internal\n    */ matchStyle(prop, value, context, after) {\n        for(let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++){\n            let rule = this.styles[i], style = rule.style;\n            if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n            // or has an '=' sign after the prop, followed by the given\n            // value.\n            style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n            if (rule.getAttrs) {\n                let result = rule.getAttrs(value);\n                if (result === false) continue;\n                rule.attrs = result || undefined;\n            }\n            return rule;\n        }\n    }\n    /**\n    @internal\n    */ static schemaRules(schema) {\n        let result = [];\n        function insert(rule) {\n            let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n            for(; i < result.length; i++){\n                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n                if (nextPriority < priority) break;\n            }\n            result.splice(i, 0, rule);\n        }\n        for(let name in schema.marks){\n            let rules = schema.marks[name].spec.parseDOM;\n            if (rules) rules.forEach((rule)=>{\n                insert(rule = copy(rule));\n                if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;\n            });\n        }\n        for(let name in schema.nodes){\n            let rules = schema.nodes[name].spec.parseDOM;\n            if (rules) rules.forEach((rule)=>{\n                insert(rule = copy(rule));\n                if (!(rule.node || rule.ignore || rule.mark)) rule.node = name;\n            });\n        }\n        return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).\n    */ static fromSchema(schema) {\n        return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n}\nconst blockTags = {\n    address: true,\n    article: true,\n    aside: true,\n    blockquote: true,\n    canvas: true,\n    dd: true,\n    div: true,\n    dl: true,\n    fieldset: true,\n    figcaption: true,\n    figure: true,\n    footer: true,\n    form: true,\n    h1: true,\n    h2: true,\n    h3: true,\n    h4: true,\n    h5: true,\n    h6: true,\n    header: true,\n    hgroup: true,\n    hr: true,\n    li: true,\n    noscript: true,\n    ol: true,\n    output: true,\n    p: true,\n    pre: true,\n    section: true,\n    table: true,\n    tfoot: true,\n    ul: true\n};\nconst ignoreTags = {\n    head: true,\n    noscript: true,\n    object: true,\n    script: true,\n    style: true,\n    title: true\n};\nconst listTags = {\n    ol: true,\n    ul: true\n};\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n    if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n    constructor(type, attrs, // Marks applied to this node itself\n    marks, // Marks that can't apply here, but will be used in children if possible\n    pendingMarks, solid, match, options){\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.pendingMarks = pendingMarks;\n        this.solid = solid;\n        this.options = options;\n        this.content = [];\n        // Marks applied to the node's children\n        this.activeMarks = Mark.none;\n        // Nested Marks with same type\n        this.stashMarks = [];\n        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n        if (!this.match) {\n            if (!this.type) return [];\n            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n            if (fill) {\n                this.match = this.type.contentMatch.matchFragment(fill);\n            } else {\n                let start = this.type.contentMatch, wrap;\n                if (wrap = start.findWrapping(node.type)) {\n                    this.match = start;\n                    return wrap;\n                } else {\n                    return null;\n                }\n            }\n        }\n        return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n        if (!(this.options & OPT_PRESERVE_WS)) {\n            let last = this.content[this.content.length - 1], m;\n            if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n                let text = last;\n                if (last.text.length == m[0].length) this.content.pop();\n                else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n            }\n        }\n        let content = Fragment.from(this.content);\n        if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n        return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    popFromStashMark(mark) {\n        for(let i = this.stashMarks.length - 1; i >= 0; i--)if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];\n    }\n    applyPending(nextType) {\n        for(let i = 0, pending = this.pendingMarks; i < pending.length; i++){\n            let mark = pending[i];\n            if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {\n                this.activeMarks = mark.addToSet(this.activeMarks);\n                this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n            }\n        }\n    }\n    inlineContext(node) {\n        if (this.type) return this.type.inlineContent;\n        if (this.content.length) return this.content[0].isInline;\n        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n}\nclass ParseContext {\n    constructor(// The parser we are using.\n    parser, // The options passed to this parse.\n    options, isOpen){\n        this.parser = parser;\n        this.options = options;\n        this.isOpen = isOpen;\n        this.open = 0;\n        let topNode = options.topNode, topContext;\n        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n        if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n        else if (isOpen) topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);\n        else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n        this.nodes = [\n            topContext\n        ];\n        this.find = options.findPositions;\n        this.needsBlock = false;\n    }\n    get top() {\n        return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom) {\n        if (dom.nodeType == 3) this.addTextNode(dom);\n        else if (dom.nodeType == 1) this.addElement(dom);\n    }\n    withStyleRules(dom, f) {\n        let style = dom.style;\n        if (!style || !style.length) return f();\n        let marks = this.readStyles(dom.style);\n        if (!marks) return; // A style with ignore: true\n        let [addMarks, removeMarks] = marks, top = this.top;\n        for(let i = 0; i < removeMarks.length; i++)this.removePendingMark(removeMarks[i], top);\n        for(let i = 0; i < addMarks.length; i++)this.addPendingMark(addMarks[i]);\n        f();\n        for(let i = 0; i < addMarks.length; i++)this.removePendingMark(addMarks[i], top);\n        for(let i = 0; i < removeMarks.length; i++)this.addPendingMark(removeMarks[i]);\n    }\n    addTextNode(dom) {\n        let value = dom.nodeValue;\n        let top = this.top;\n        if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n            if (!(top.options & OPT_PRESERVE_WS)) {\n                value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n                // If this starts with whitespace, and there is no node before it, or\n                // a hard break, or a text node that ends with whitespace, strip the\n                // leading space.\n                if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n                    let nodeBefore = top.content[top.content.length - 1];\n                    let domNodeBefore = dom.previousSibling;\n                    if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n                }\n            } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n                value = value.replace(/\\r?\\n|\\r/g, \" \");\n            } else {\n                value = value.replace(/\\r\\n?/g, \"\\n\");\n            }\n            if (value) this.insertNode(this.parser.schema.text(value));\n            this.findInText(dom);\n        } else {\n            this.findInside(dom);\n        }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, matchAfter) {\n        let name = dom.nodeName.toLowerCase(), ruleID;\n        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n        if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n            this.findInside(dom);\n            this.ignoreFallback(dom);\n        } else if (!rule || rule.skip || rule.closeParent) {\n            if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);\n            else if (rule && rule.skip.nodeType) dom = rule.skip;\n            let sync, top = this.top, oldNeedsBlock = this.needsBlock;\n            if (blockTags.hasOwnProperty(name)) {\n                if (top.content.length && top.content[0].isInline && this.open) {\n                    this.open--;\n                    top = this.top;\n                }\n                sync = true;\n                if (!top.type) this.needsBlock = true;\n            } else if (!dom.firstChild) {\n                this.leafFallback(dom);\n                return;\n            }\n            if (rule && rule.skip) this.addAll(dom);\n            else this.withStyleRules(dom, ()=>this.addAll(dom));\n            if (sync) this.sync(top);\n            this.needsBlock = oldNeedsBlock;\n        } else {\n            this.withStyleRules(dom, ()=>{\n                this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);\n            });\n        }\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom) {\n        if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"));\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom) {\n        // Ignored BR nodes should at least create an inline context\n        if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"));\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an array of marks, or null to indicate some of the styles\n    // had a rule with `ignore` set.\n    readStyles(styles) {\n        let add = Mark.none, remove = Mark.none;\n        for(let i = 0, l = styles.length; i < l; i++){\n            let name = styles.item(i);\n            for(let after = undefined;;){\n                let rule = this.parser.matchStyle(name, styles.getPropertyValue(name), this, after);\n                if (!rule) break;\n                if (rule.ignore) return null;\n                if (rule.clearMark) {\n                    this.top.pendingMarks.concat(this.top.activeMarks).forEach((m)=>{\n                        if (rule.clearMark(m)) remove = m.addToSet(remove);\n                    });\n                } else {\n                    add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);\n                }\n                if (rule.consuming === false) after = rule;\n                else break;\n            }\n        }\n        return [\n            add,\n            remove\n        ];\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, continueAfter) {\n        let sync, nodeType, mark;\n        if (rule.node) {\n            nodeType = this.parser.schema.nodes[rule.node];\n            if (!nodeType.isLeaf) {\n                sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);\n            } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n                this.leafFallback(dom);\n            }\n        } else {\n            let markType = this.parser.schema.marks[rule.mark];\n            mark = markType.create(rule.attrs);\n            this.addPendingMark(mark);\n        }\n        let startIn = this.top;\n        if (nodeType && nodeType.isLeaf) {\n            this.findInside(dom);\n        } else if (continueAfter) {\n            this.addElement(dom, continueAfter);\n        } else if (rule.getContent) {\n            this.findInside(dom);\n            rule.getContent(dom, this.parser.schema).forEach((node)=>this.insertNode(node));\n        } else {\n            let contentDOM = dom;\n            if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);\n            else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);\n            else if (rule.contentElement) contentDOM = rule.contentElement;\n            this.findAround(dom, contentDOM, true);\n            this.addAll(contentDOM);\n        }\n        if (sync && this.sync(startIn)) this.open--;\n        if (mark) this.removePendingMark(mark, startIn);\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, startIndex, endIndex) {\n        let index = startIndex || 0;\n        for(let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index){\n            this.findAtPoint(parent, index);\n            this.addDOM(dom);\n        }\n        this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node) {\n        let route, sync;\n        for(let depth = this.open; depth >= 0; depth--){\n            let cx = this.nodes[depth];\n            let found = cx.findWrapping(node);\n            if (found && (!route || route.length > found.length)) {\n                route = found;\n                sync = cx;\n                if (!found.length) break;\n            }\n            if (cx.solid) break;\n        }\n        if (!route) return false;\n        this.sync(sync);\n        for(let i = 0; i < route.length; i++)this.enterInner(route[i], null, false);\n        return true;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node) {\n        if (node.isInline && this.needsBlock && !this.top.type) {\n            let block = this.textblockFromContext();\n            if (block) this.enterInner(block);\n        }\n        if (this.findPlace(node)) {\n            this.closeExtra();\n            let top = this.top;\n            top.applyPending(node.type);\n            if (top.match) top.match = top.match.matchType(node.type);\n            let marks = top.activeMarks;\n            for(let i = 0; i < node.marks.length; i++)if (!top.type || top.type.allowsMarkType(node.marks[i].type)) marks = node.marks[i].addToSet(marks);\n            top.content.push(node.mark(marks));\n            return true;\n        }\n        return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, preserveWS) {\n        let ok = this.findPlace(type.create(attrs));\n        if (ok) this.enterInner(type, attrs, true, preserveWS);\n        return ok;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs = null, solid = false, preserveWS) {\n        this.closeExtra();\n        let top = this.top;\n        top.applyPending(type);\n        top.match = top.match && top.match.matchType(type);\n        let options = wsOptionsFor(type, preserveWS, top.options);\n        if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n        this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n        this.open++;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n        let i = this.nodes.length - 1;\n        if (i > this.open) {\n            for(; i > this.open; i--)this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n            this.nodes.length = this.open + 1;\n        }\n    }\n    finish() {\n        this.open = 0;\n        this.closeExtra(this.isOpen);\n        return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n    }\n    sync(to) {\n        for(let i = this.open; i >= 0; i--)if (this.nodes[i] == to) {\n            this.open = i;\n            return true;\n        }\n        return false;\n    }\n    get currentPos() {\n        this.closeExtra();\n        let pos = 0;\n        for(let i = this.open; i >= 0; i--){\n            let content = this.nodes[i].content;\n            for(let j = content.length - 1; j >= 0; j--)pos += content[j].nodeSize;\n            if (i) pos++;\n        }\n        return pos;\n    }\n    findAtPoint(parent, offset) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n        }\n    }\n    findInside(parent) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n        }\n    }\n    findAround(parent, content, before) {\n        if (parent != content && this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n                let pos = content.compareDocumentPosition(this.find[i].node);\n                if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n            }\n        }\n    }\n    findInText(textNode) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n        }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n        if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n        let parts = context.split(\"/\");\n        let option = this.options.context;\n        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n        let match = (i, depth)=>{\n            for(; i >= 0; i--){\n                let part = parts[i];\n                if (part == \"\") {\n                    if (i == parts.length - 1 || i == 0) continue;\n                    for(; depth >= minDepth; depth--)if (match(i - 1, depth)) return true;\n                    return false;\n                } else {\n                    let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n                    if (!next || next.name != part && next.groups.indexOf(part) == -1) return false;\n                    depth--;\n                }\n            }\n            return true;\n        };\n        return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n        let $context = this.options.context;\n        if ($context) for(let d = $context.depth; d >= 0; d--){\n            let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n            if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n        }\n        for(let name in this.parser.schema.nodes){\n            let type = this.parser.schema.nodes[name];\n            if (type.isTextblock && type.defaultAttrs) return type;\n        }\n    }\n    addPendingMark(mark) {\n        let found = findSameMarkInSet(mark, this.top.pendingMarks);\n        if (found) this.top.stashMarks.push(found);\n        this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n    }\n    removePendingMark(mark, upto) {\n        for(let depth = this.open; depth >= 0; depth--){\n            let level = this.nodes[depth];\n            let found = level.pendingMarks.lastIndexOf(mark);\n            if (found > -1) {\n                level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n            } else {\n                level.activeMarks = mark.removeFromSet(level.activeMarks);\n                let stashMark = level.popFromStashMark(mark);\n                if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) level.activeMarks = stashMark.addToSet(level.activeMarks);\n            }\n            if (level == upto) break;\n        }\n    }\n}\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n    for(let child = dom.firstChild, prevItem = null; child; child = child.nextSibling){\n        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n        if (name && listTags.hasOwnProperty(name) && prevItem) {\n            prevItem.appendChild(child);\n            child = prevItem;\n        } else if (name == \"li\") {\n            prevItem = child;\n        } else if (name) {\n            prevItem = null;\n        }\n    }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n    let copy = {};\n    for(let prop in obj)copy[prop] = obj[prop];\n    return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n    let nodes = nodeType.schema.nodes;\n    for(let name in nodes){\n        let parent = nodes[name];\n        if (!parent.allowsMarkType(markType)) continue;\n        let seen = [], scan = (match)=>{\n            seen.push(match);\n            for(let i = 0; i < match.edgeCount; i++){\n                let { type, next } = match.edge(i);\n                if (type == nodeType) return true;\n                if (seen.indexOf(next) < 0 && scan(next)) return true;\n            }\n        };\n        if (scan(parent.contentMatch)) return true;\n    }\n}\nfunction findSameMarkInSet(mark, set) {\n    for(let i = 0; i < set.length; i++){\n        if (mark.eq(set[i])) return set[i];\n    }\n}\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/ class DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */ constructor(/**\n    The node serialization functions.\n    */ nodes, /**\n    The mark serialization functions.\n    */ marks){\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */ serializeFragment(fragment, options = {}, target) {\n        if (!target) target = doc(options).createDocumentFragment();\n        let top = target, active = [];\n        fragment.forEach((node)=>{\n            if (active.length || node.marks.length) {\n                let keep = 0, rendered = 0;\n                while(keep < active.length && rendered < node.marks.length){\n                    let next = node.marks[rendered];\n                    if (!this.marks[next.type.name]) {\n                        rendered++;\n                        continue;\n                    }\n                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n                    keep++;\n                    rendered++;\n                }\n                while(keep < active.length)top = active.pop()[1];\n                while(rendered < node.marks.length){\n                    let add = node.marks[rendered++];\n                    let markDOM = this.serializeMark(add, node.isInline, options);\n                    if (markDOM) {\n                        active.push([\n                            add,\n                            top\n                        ]);\n                        top.appendChild(markDOM.dom);\n                        top = markDOM.contentDOM || markDOM.dom;\n                    }\n                }\n            }\n            top.appendChild(this.serializeNodeInner(node, options));\n        });\n        return target;\n    }\n    /**\n    @internal\n    */ serializeNodeInner(node, options) {\n        let { dom, contentDOM } = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n        if (contentDOM) {\n            if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n            this.serializeFragment(node.content, options, contentDOM);\n        }\n        return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */ serializeNode(node, options = {}) {\n        let dom = this.serializeNodeInner(node, options);\n        for(let i = node.marks.length - 1; i >= 0; i--){\n            let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n            if (wrap) {\n                (wrap.contentDOM || wrap.dom).appendChild(dom);\n                dom = wrap.dom;\n            }\n        }\n        return dom;\n    }\n    /**\n    @internal\n    */ serializeMark(mark, inline, options = {}) {\n        let toDOM = this.marks[mark.type.name];\n        return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n    }\n    /**\n    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If\n    the spec has a hole (zero) in it, `contentDOM` will point at the\n    node with the hole.\n    */ static renderSpec(doc, structure, xmlNS = null) {\n        if (typeof structure == \"string\") return {\n            dom: doc.createTextNode(structure)\n        };\n        if (structure.nodeType != null) return {\n            dom: structure\n        };\n        if (structure.dom && structure.dom.nodeType != null) return structure;\n        let tagName = structure[0], space = tagName.indexOf(\" \");\n        if (space > 0) {\n            xmlNS = tagName.slice(0, space);\n            tagName = tagName.slice(space + 1);\n        }\n        let contentDOM;\n        let dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n        let attrs = structure[1], start = 1;\n        if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n            start = 2;\n            for(let name in attrs)if (attrs[name] != null) {\n                let space = name.indexOf(\" \");\n                if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);\n                else dom.setAttribute(name, attrs[name]);\n            }\n        }\n        for(let i = start; i < structure.length; i++){\n            let child = structure[i];\n            if (child === 0) {\n                if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n                return {\n                    dom,\n                    contentDOM: dom\n                };\n            } else {\n                let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc, child, xmlNS);\n                dom.appendChild(inner);\n                if (innerContent) {\n                    if (contentDOM) throw new RangeError(\"Multiple content holes\");\n                    contentDOM = innerContent;\n                }\n            }\n        }\n        return {\n            dom,\n            contentDOM\n        };\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */ static fromSchema(schema) {\n        return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */ static nodesFromSchema(schema) {\n        let result = gatherToDOM(schema.nodes);\n        if (!result.text) result.text = (node)=>node.text;\n        return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */ static marksFromSchema(schema) {\n        return gatherToDOM(schema.marks);\n    }\n}\nfunction gatherToDOM(obj) {\n    let result = {};\n    for(let name in obj){\n        let toDOM = obj[name].spec.toDOM;\n        if (toDOM) result[name] = toDOM;\n    }\n    return result;\n}\nfunction doc(options) {\n    return options.document || window.document;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUVwQyxTQUFTQyxjQUFjQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRztJQUM1QixJQUFLLElBQUlDLElBQUksSUFBSUEsSUFBSztRQUNsQixJQUFJQSxLQUFLSCxFQUFFSSxVQUFVLElBQUlELEtBQUtGLEVBQUVHLFVBQVUsRUFDdEMsT0FBT0osRUFBRUksVUFBVSxJQUFJSCxFQUFFRyxVQUFVLEdBQUcsT0FBT0Y7UUFDakQsSUFBSUcsU0FBU0wsRUFBRU0sS0FBSyxDQUFDSCxJQUFJSSxTQUFTTixFQUFFSyxLQUFLLENBQUNIO1FBQzFDLElBQUlFLFVBQVVFLFFBQVE7WUFDbEJMLE9BQU9HLE9BQU9HLFFBQVE7WUFDdEI7UUFDSjtRQUNBLElBQUksQ0FBQ0gsT0FBT0ksVUFBVSxDQUFDRixTQUNuQixPQUFPTDtRQUNYLElBQUlHLE9BQU9LLE1BQU0sSUFBSUwsT0FBT00sSUFBSSxJQUFJSixPQUFPSSxJQUFJLEVBQUU7WUFDN0MsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLE9BQU9NLElBQUksQ0FBQ0MsRUFBRSxJQUFJTCxPQUFPSSxJQUFJLENBQUNDLEVBQUUsRUFBRUEsSUFDOUNWO1lBQ0osT0FBT0E7UUFDWDtRQUNBLElBQUlHLE9BQU9RLE9BQU8sQ0FBQ0MsSUFBSSxJQUFJUCxPQUFPTSxPQUFPLENBQUNDLElBQUksRUFBRTtZQUM1QyxJQUFJQyxRQUFRaEIsY0FBY00sT0FBT1EsT0FBTyxFQUFFTixPQUFPTSxPQUFPLEVBQUVYLE1BQU07WUFDaEUsSUFBSWEsU0FBUyxNQUNULE9BQU9BO1FBQ2Y7UUFDQWIsT0FBT0csT0FBT0csUUFBUTtJQUMxQjtBQUNKO0FBQ0EsU0FBU1EsWUFBWWhCLENBQUMsRUFBRUMsQ0FBQyxFQUFFZ0IsSUFBSSxFQUFFQyxJQUFJO0lBQ2pDLElBQUssSUFBSUMsS0FB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LFlBQ0EsTUFBTSxJQUFJcmEsV0FBVztvQkFDekJxYSxhQUFheUQ7Z0JBQ2pCO1lBQ0o7UUFDSjtRQUNBLE9BQU87WUFBRTdMO1lBQUtvSTtRQUFXO0lBQzdCO0lBQ0E7OztJQUdBLEdBQ0EsT0FBTy9HLFdBQVdyUyxNQUFNLEVBQUU7UUFDdEIsT0FBT0EsT0FBTzBHLE1BQU0sQ0FBQ29XLGFBQWEsSUFDN0I5YyxDQUFBQSxPQUFPMEcsTUFBTSxDQUFDb1csYUFBYSxHQUFHLElBQUlyQixjQUFjLElBQUksQ0FBQ3NCLGVBQWUsQ0FBQy9jLFNBQVMsSUFBSSxDQUFDZ2QsZUFBZSxDQUFDaGQsUUFBTztJQUNuSDtJQUNBOzs7SUFHQSxHQUNBLE9BQU8rYyxnQkFBZ0IvYyxNQUFNLEVBQUU7UUFDM0IsSUFBSTdCLFNBQVM4ZSxZQUFZamQsT0FBT1EsS0FBSztRQUNyQyxJQUFJLENBQUNyQyxPQUFPL0MsSUFBSSxFQUNaK0MsT0FBTy9DLElBQUksR0FBRytCLENBQUFBLE9BQVFBLEtBQUsvQixJQUFJO1FBQ25DLE9BQU8rQztJQUNYO0lBQ0E7O0lBRUEsR0FDQSxPQUFPNmUsZ0JBQWdCaGQsTUFBTSxFQUFFO1FBQzNCLE9BQU9pZCxZQUFZamQsT0FBT3dCLEtBQUs7SUFDbkM7QUFDSjtBQUNBLFNBQVN5YixZQUFZN2IsR0FBRztJQUNwQixJQUFJakQsU0FBUyxDQUFDO0lBQ2QsSUFBSyxJQUFJa0QsUUFBUUQsSUFBSztRQUNsQixJQUFJZ2IsUUFBUWhiLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDN0QsSUFBSSxDQUFDNGUsS0FBSztRQUNoQyxJQUFJQSxPQUNBamUsTUFBTSxDQUFDa0QsS0FBSyxHQUFHK2E7SUFDdkI7SUFDQSxPQUFPamU7QUFDWDtBQUNBLFNBQVNnSCxJQUFJOEosT0FBTztJQUNoQixPQUFPQSxRQUFRaU8sUUFBUSxJQUFJQyxPQUFPRCxRQUFRO0FBQzlDO0FBRWlKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1vZGVsL2Rpc3QvaW5kZXguanM/NzhlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT3JkZXJlZE1hcCBmcm9tICdvcmRlcmVkbWFwJztcblxuZnVuY3Rpb24gZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gYS5jaGlsZENvdW50ID09IGIuY2hpbGRDb3VudCA/IG51bGwgOiBwb3M7XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKGkpLCBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKylcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICAgIGZvciAobGV0IGlBID0gYS5jaGlsZENvdW50LCBpQiA9IGIuY2hpbGRDb3VudDs7KSB7XG4gICAgICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApXG4gICAgICAgICAgICByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDogeyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLCBjaGlsZEIgPSBiLmNoaWxkKC0taUIpLCBzaXplID0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgbGV0IHNhbWUgPSAwLCBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKHNhbWUgPCBtaW5TaXplICYmIGNoaWxkQS50ZXh0W2NoaWxkQS50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSA9PSBjaGlsZEIudGV4dFtjaGlsZEIudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lKys7XG4gICAgICAgICAgICAgICAgcG9zQS0tO1xuICAgICAgICAgICAgICAgIHBvc0ItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZkVuZChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvc0EgLSAxLCBwb3NCIC0gMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgIH1cbn1cblxuLyoqXG5BIGZyYWdtZW50IHJlcHJlc2VudHMgYSBub2RlJ3MgY29sbGVjdGlvbiBvZiBjaGlsZCBub2Rlcy5cblxuTGlrZSBub2RlcywgZnJhZ21lbnRzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcywgYW5kIHlvdVxuc2hvdWxkIG5vdCBtdXRhdGUgdGhlbSBvciB0aGVpciBjb250ZW50LiBSYXRoZXIsIHlvdSBjcmVhdGUgbmV3XG5pbnN0YW5jZXMgd2hlbmV2ZXIgbmVlZGVkLiBUaGUgQVBJIHRyaWVzIHRvIG1ha2UgdGhpcyBlYXN5LlxuKi9cbmNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGVudCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgICAgIGlmIChzaXplID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplICs9IGNvbnRlbnRbaV0ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyBiZXR3ZWVuIHRoZSBnaXZlbiB0d29cbiAgICBwb3NpdGlvbnMgKHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgZnJhZ21lbnQpLiBEb2Vzbid0IGRlc2NlbmRcbiAgICBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIG5vZGVTdGFydCA9IDAsIHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gYHBvc2Agd2lsbCBiZVxuICAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuXG4gICAgYGZhbHNlYCB0byBwcmV2ZW50IHRyYXZlcnNhbCBvZiBhIGdpdmVuIG5vZGUncyBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgdGV4dCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gU2VlIHRoZSBzYW1lIG1ldGhvZCBvblxuICAgIFtgTm9kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnRleHRCZXR3ZWVuKS5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiLCBmaXJzdCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZVRleHQgPSBub2RlLmlzVGV4dCA/IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcylcbiAgICAgICAgICAgICAgICA6ICFub2RlLmlzTGVhZiA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiBsZWFmVGV4dCA/ICh0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0ID8gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIChub2RlLmlzTGVhZiAmJiBub2RlVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrKSAmJiBibG9ja1NlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9IG5vZGVUZXh0O1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBjb250YWluaW5nIHRoZSBjb21iaW5lZCBjb250ZW50IG9mIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICAgICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgc3ViLWZyYWdtZW50IGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSB8fCBlbmQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbiAgICByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VDaGlsZChpbmRleCwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvRW5kKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBsYXN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgZihjaGlsZCwgcCwgaSk7XG4gICAgICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbiAgICBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAqL1xuICAgIGZpbmREaWZmU3RhcnQob3RoZXIsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZVxuICAgIHRoZSBzYW1lLiBTaW5jZSB0aGlzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHRoZSBzYW1lIGluIGJvdGhcbiAgICBub2RlcywgYW4gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGZpbmREaWZmRW5kKG90aGVyLCBwb3MgPSB0aGlzLnNpemUsIG90aGVyUG9zID0gb3RoZXIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZFbmQodGhpcywgb3RoZXIsIHBvcywgb3RoZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRleCBhbmQgaW5uZXIgb2Zmc2V0IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiByZWxhdGl2ZVxuICAgIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4gICAgKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIChOb3QgcHVibGljLilcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MsIHJvdW5kID0gLTEpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBzZXRzIG9mIG1hcmtzIGFyZSBpZGVudGljYWwuXG4gICAgKi9cbiAgICBzdGF0aWMgc2FtZVNldChhLCBiKSB7XG4gICAgICAgIGlmIChhID09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcHJvcGVybHkgc29ydGVkIG1hcmsgc2V0IGZyb20gbnVsbCwgYSBzaW5nbGUgbWFyaywgb3IgYW5cbiAgICB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXRGcm9tKG1hcmtzKSB7XG4gICAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKVxuICAgICAgICAgICAgcmV0dXJuIFttYXJrc107XG4gICAgICAgIGxldCBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5zb3J0KChhLCBiKSA9PiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIG1hcmtzLlxuKi9cbk1hcmsubm9uZSA9IFtdO1xuXG4vKipcbkVycm9yIHR5cGUgcmFpc2VkIGJ5IFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2hlblxuZ2l2ZW4gYW4gaW52YWxpZCByZXBsYWNlbWVudC5cbiovXG5jbGFzcyBSZXBsYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKlxuUmVwbGFjZUVycm9yID0gZnVuY3Rpb24odGhpczogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSlcbiAgOyhlcnIgYXMgYW55KS5fX3Byb3RvX18gPSBSZXBsYWNlRXJyb3IucHJvdG90eXBlXG4gIHJldHVybiBlcnJcbn0gYXMgYW55XG5cblJlcGxhY2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3JcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCJcbiovXG4vKipcbkEgc2xpY2UgcmVwcmVzZW50cyBhIHBpZWNlIGN1dCBvdXQgb2YgYSBsYXJnZXIgZG9jdW1lbnQuIEl0XG5zdG9yZXMgbm90IG9ubHkgYSBmcmFnbWVudCwgYnV0IGFsc28gdGhlIGRlcHRoIHVwIHRvIHdoaWNoIG5vZGVzIG9uXG5ib3RoIHNpZGUgYXJlIOKAmG9wZW7igJkgKGN1dCB0aHJvdWdoKS5cbiovXG5jbGFzcyBTbGljZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UuIFdoZW4gc3BlY2lmeWluZyBhIG5vbi16ZXJvIG9wZW4gZGVwdGgsIHlvdSBtdXN0XG4gICAgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vZGVzIG9mIGF0IGxlYXN0IHRoYXQgZGVwdGggYXQgdGhlXG4gICAgYXBwcm9wcmlhdGUgc2lkZSBvZiB0aGUgZnJhZ21lbnTigJRpLmUuIGlmIHRoZSBmcmFnbWVudCBpcyBhblxuICAgIGVtcHR5IHBhcmFncmFwaCBub2RlLCBgb3BlblN0YXJ0YCBhbmQgYG9wZW5FbmRgIGNhbid0IGJlIGdyZWF0ZXJcbiAgICB0aGFuIDEuXG4gICAgXG4gICAgSXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbnRlbnQgb2Ygb3BlbiBub2RlcyB0byBjb25mb3JtIHRvXG4gICAgdGhlIHNjaGVtYSdzIGNvbnRlbnQgY29uc3RyYWludHMsIHRob3VnaCBpdCBzaG91bGQgYmUgYSB2YWxpZFxuICAgIHN0YXJ0L2VuZC9taWRkbGUgZm9yIHN1Y2ggYSBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZXMgYXJlXG4gICAgb3Blbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgb3BlblN0YXJ0LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgb3BlbkVuZCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIHNsaWNlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSB7IGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbiAgICBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF4T3BlbihmcmFnbWVudCwgb3Blbklzb2xhdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShmcmFnbWVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzbGljZS5cbiovXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGZyb20pLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgbGV0IHsgaW5kZXg6IGluZGV4VG8sIG9mZnNldDogb2Zmc2V0VG8gfSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBpbmRleFRvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGRpc3QpLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCk7XG4gICAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgaWYgKHNsaWNlLm9wZW5TdGFydCA+ICRmcm9tLmRlcHRoKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIik7XG4gICAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gICAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gICAgbGV0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09ICR0by5pbmRleChkZXB0aCkgJiYgZGVwdGggPCAkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICBsZXQgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tKb2luKG1haW4sIHN1Yikge1xuICAgIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gICAgbGV0IG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICAgIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gICAgbGV0IGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgICAgIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7XG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgICBsZXQgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgICBpZiAoJHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgICAgICBpZiAoJHN0YXJ0LmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpO1xuICAgIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgICAgICBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gICAgbGV0IG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5TdGFydClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICAgICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgICAgIGlmIChvcGVuRW5kKVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuRW5kLCByZXBsYWNlVHdvV2F5KCRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAoJGZyb20uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICBsZXQgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgICBsZXQgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICAgIGZvciAobGV0IGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBub2RlID0gJGFsb25nLm5vZGUoaSkuY29weShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4geyBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSkgfTtcbn1cblxuLyoqXG5Zb3UgY2FuIFtfcmVzb2x2ZV9dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbmluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxucmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0XG5pbmZvcm1hdGlvbiwgYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG5cblRocm91Z2hvdXQgdGhpcyBpbnRlcmZhY2UsIG1ldGhvZHMgdGhhdCB0YWtlIGFuIG9wdGlvbmFsIGBkZXB0aGBcbnBhcmFtZXRlciB3aWxsIGludGVycHJldCB1bmRlZmluZWQgYXMgYHRoaXMuZGVwdGhgIGFuZCBuZWdhdGl2ZVxubnVtYmVycyBhcyBgdGhpcy5kZXB0aCArIHZhbHVlYC5cbiovXG5jbGFzcyBSZXNvbHZlZFBvcyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gdGhhdCB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGF0aCwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCB0aGlzIHBvc2l0aW9uIGhhcyBpbnRvIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudE9mZnNldCkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXRoLmxlbmd0aCAvIDMgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICAgIGlmICh2YWwgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbiAgICBhIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGF0IG5vZGUgaXMgbm90IGNvbnNpZGVyZWRcbiAgICB0aGUgcGFyZW504oCUdGV4dCBub2RlcyBhcmUg4oCYZmxhdOKAmSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSByb290IG5vZGUgaW4gd2hpY2ggdGhlIHBvc2l0aW9uIHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIGdldCBkb2MoKSB7IHJldHVybiB0aGlzLm5vZGUoMCk7IH1cbiAgICAvKipcbiAgICBUaGUgYW5jZXN0b3Igbm9kZSBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIGBwLm5vZGUocC5kZXB0aClgIGlzIHRoZVxuICAgIHNhbWUgYXMgYHAucGFyZW50YC5cbiAgICAqL1xuICAgIG5vZGUoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzXG4gICAgYXQgdGhlIDNyZCBub2RlIGluIHRoZSAybmQgcGFyYWdyYXBoIG9uIHRoZSB0b3AgbGV2ZWwsIGZvclxuICAgIGV4YW1wbGUsIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cbiAgICAqL1xuICAgIGluZGV4KGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwuXG4gICAgKi9cbiAgICBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBzdGFydChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIGVuZChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGJlZm9yZShkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG4gICAgKi9cbiAgICBhZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoaXMgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoaXMgcmV0dXJucyB0aGVcbiAgICBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IHRleHRPZmZzZXQoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZSBwb3NpdGlvblxuICAgIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbiAgICBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQWZ0ZXIoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sIGNoaWxkID0gcGFyZW50LmNoaWxkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGVcbiAgICBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVCZWZvcmUoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZE9mZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCkuY3V0KDAsIGRPZmYpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gZGVwdGggKHdoaWNoIGRlZmF1bHRzIHRvIGB0aGlzLmRlcHRoYCkuXG4gICAgKi9cbiAgICBwb3NBdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSwgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhdCB0aGlzIHBvc2l0aW9uLCBmYWN0b3JpbmcgaW4gdGhlIHN1cnJvdW5kaW5nXG4gICAgbWFya3MnIFtgaW5jbHVzaXZlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuICAgIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4gICAgbm9kZSBhZnRlciBpdCAoaWYgYW55KSBhcmUgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBtYXJrcygpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgcGFyZW50LCByZXR1cm4gdGhlIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChwYXJlbnQuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gICAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcztcbiAgICAgICAgbGV0IG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gICAgICAgIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBtYWluO1xuICAgICAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gICAgICAgIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICAgICAgICBsZXQgbWFya3MgPSBtYWluLm1hcmtzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2VcbiAgICB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbiAgICBpcyBtb3N0bHkgdXNlZnVsIGZvciBnZXR0aW5nIHRoZSBzZXQgb2YgbWFya3MgdG8gcHJlc2VydmUgYWZ0ZXIgYVxuICAgIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4gICAgaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbiAgICBjYXNlIG5vIG1hcmtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQpLlxuICAgICovXG4gICAgbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gICAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbiAgICBwb3NpdGlvbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMuXG4gICAgKi9cbiAgICBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbiAgICB0aGUgc2FtZSB0ZXh0YmxvY2ssIGZvciBleGFtcGxlLCBhIHJhbmdlIGFyb3VuZCB0aGF0IHRleHRibG9ja1xuICAgIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2VcbiAgICBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuICAgIHBhc3MgaW4gYW4gb3B0aW9uYWwgcHJlZGljYXRlIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmVudFxuICAgIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuICAgICovXG4gICAgYmxvY2tSYW5nZShvdGhlciA9IHRoaXMsIHByZWQpIHtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSlcbiAgICAgICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtYXgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWluKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZShkb2MsIHBvcykge1xuICAgICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBkb2M7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFyZW0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9zID09IHBvcyAmJiBjYWNoZWQuZG9jID09IGRvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXNvbHZlQ2FjaGVbcmVzb2x2ZUNhY2hlUG9zXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICByZXNvbHZlQ2FjaGVQb3MgPSAocmVzb2x2ZUNhY2hlUG9zICsgMSkgJSByZXNvbHZlQ2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmxldCByZXNvbHZlQ2FjaGUgPSBbXSwgcmVzb2x2ZUNhY2hlUG9zID0gMCwgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXSgvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGlzLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgICBhdHRyaWJ1dGVzIGFsbG93ZWQgYW5kIHJlcXVpcmVkIGFyZVxuICAgIFtkZXRlcm1pbmVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBhdHRycywgXG4gICAgLy8gQSBmcmFnbWVudCBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gICAgbGluaykgYXBwbGllZCB0byB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBtYXJrcyA9IE1hcmsubm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oL2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBub2RlIChtZXRob2QgcmVjZWl2ZXIpLFxuICAgIGl0cyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBjaGlsZCBpbmRleC4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzIGNoaWxkcmVuIHdpbGwgbm90IGJlXG4gICAgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYVxuICAgIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGNvdW50IGZyb20uXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zID0gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIERvZXNuJ3RcbiAgICBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNMZWFmICYmIHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KVxuICAgICAgICAgICAgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGFsbCB0ZXh0IGJldHdlZW4gcG9zaXRpb25zIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gc2VwYXJhdGUgdGV4dFxuICAgIGZyb20gZGlmZmVyZW50IGJsb2NrIG5vZGVzLiBJZiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuICAgIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQsIG90aGVyd2lzZVxuICAgIFtgbGVhZlRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWNebGVhZlRleHQpIHdpbGwgYmUgdXNlZC5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIG5vZGVzIHJlcHJlc2VudCB0aGUgc2FtZSBwaWVjZSBvZiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8ICh0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbiAgICB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuICAgICovXG4gICAgc2FtZU1hcmt1cChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUncyBtYXJrdXAgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gdHlwZSxcbiAgICBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG4gICAgKi9cbiAgICBoYXNNYXJrdXAodHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJlxuICAgICAgICAgICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICAgICAgICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSB3aXRoIHRoZSBzYW1lIG1hcmt1cCBhcyB0aGlzIG5vZGUsIGNvbnRhaW5pbmdcbiAgICB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuICAgICovXG4gICAgY29weShjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuICAgIG9mIHRoZSBub2RlJ3Mgb3duIG1hcmtzLlxuICAgICovXG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSB3aXRoIG9ubHkgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4gICAgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuICAgIHJldHVybiBpdCBhcyBhIGBTbGljZWAgb2JqZWN0LlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLnJlc29sdmUodG8pO1xuICAgICAgICBsZXQgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuICAgIHRoZSBnaXZlbiBzbGljZS4gVGhlIHNsaWNlIG11c3QgJ2ZpdCcsIG1lYW5pbmcgaXRzIG9wZW4gc2lkZXNcbiAgICBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuICAgIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4gICAgaW50by4gSWYgYW55IG9mIHRoaXMgaXMgdmlvbGF0ZWQsIGFuIGVycm9yIG9mIHR5cGVcbiAgICBbYFJlcGxhY2VFcnJvcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHJldHVybmluZyBhblxuICAgIFtvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVOb0NhY2hlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gbWFyayBvciBtYXJrIHR5cGUgb2NjdXJzIGluIHRoaXMgZG9jdW1lbnRcbiAgICBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgcmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxuICAgICovXG4gICAgZ2V0IGlzQmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBpbmxpbmUgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYSBub2RlIHRoYXQgY2FuXG4gICAgYXBwZWFyIGFtb25nIHRleHQpLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0KCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuICAgIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuICAgIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgW2BhdG9tYCBwcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0b20pXG4gICAgb24gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXNcbiAgICBhbiB1bmVkaXRhYmxlIFtub2RlIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KSkuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuICAgIHB1cnBvc2VzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICovXG4gICAgY29udGVudE1hdGNoQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCAoYnlcbiAgICBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4gICAgdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuICAgIGNhbiBvcHRpb25hbGx5IHBhc3MgYHN0YXJ0YCBhbmQgYGVuZGAgaW5kaWNlcyBpbnRvIHRoZVxuICAgIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuICAgICovXG4gICAgY2FuUmVwbGFjZShmcm9tLCB0bywgcmVwbGFjZW1lbnQgPSBGcmFnbWVudC5lbXB0eSwgc3RhcnQgPSAwLCBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBsZXQgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBgZnJvbWAgdG8gYHRvYCAoYnkgaW5kZXgpIHdpdGhcbiAgICBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuICAgICovXG4gICAgY2FuUmVwbGFjZVdpdGgoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gICAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSdzIGNvbnRlbnQgY291bGQgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbiAgICBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuICAgIG1lcmdpbmcgY29tcGxldGVseSBpbmNvbXBhdGlibGUgbm9kZXMpLlxuICAgICovXG4gICAgY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuICAgIHNjaGVtYSwgYW5kIHJhaXNlIGVycm9yIHdoZW4gdGhleSBkbyBub3QuXG4gICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBsZXQgY29weSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29weSA9IHRoaXMubWFya3NbaV0uYWRkVG9TZXQoY29weSk7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSAke3RoaXMudHlwZS5uYW1lfTogJHt0aGlzLm1hcmtzLm1hcChtID0+IG0udHlwZS5uYW1lKX1gKTtcbiAgICAgICAgdGhpcy5jb250ZW50LmZvckVhY2gobm9kZSA9PiBub2RlLmNoZWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAobiA9PiBuLnRvSlNPTigpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IG1hcmtzID0gbnVsbDtcbiAgICAgICAgaWYgKGpzb24ubWFya3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbWFyayBkYXRhIGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxufVxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudGV4dDsgfVxuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pOyB9XG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICAgIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgY3V0KGZyb20gPSAwLCB0byA9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYmFzZSA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlIHR5cGUnc1xuW2NvbnRlbnQgZXhwcmVzc2lvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlIHVzZWQgdG9cbmZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXIgYSBnaXZlblxucG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4qL1xuY2xhc3MgQ29udGVudE1hdGNoIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG1hdGNoIHN0YXRlIHJlcHJlc2VudHMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB2YWxpZEVuZCkge1xuICAgICAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgICAgbGV0IG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gICAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCBhIGZyYWdtZW50LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgbWF0Y2ggd2hlblxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaEZyYWdtZW50KGZyYWcsIHN0YXJ0ID0gMCwgZW5kID0gZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoICE9IDAgJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbiAgICBiZSBnZW5lcmF0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB0aGlzLm5leHRbaV07XG4gICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGF0aWJsZShvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuICAgIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4gICAgc3VjY2Vzc2Z1bCwgcmV0dXJuIGEgZnJhZ21lbnQgb2YgaW5zZXJ0ZWQgbm9kZXMgKHdoaWNoIG1heSBiZVxuICAgIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbiAgICByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBmaWxsQmVmb3JlKGFmdGVyLCB0b0VuZCA9IGZhbHNlLCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgc2VlbiA9IFt0aGlzXTtcbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQgJiYgKCF0b0VuZCB8fCBmaW5pc2hlZC52YWxpZEVuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKHRwID0+IHRwLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2VhcmNoKG5leHQsIHR5cGVzLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHNldCBvZiB3cmFwcGluZyBub2RlIHR5cGVzIHRoYXQgd291bGQgYWxsb3cgYSBub2RlIG9mIHRoZVxuICAgIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4gICAgKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwQ2FjaGVbaV0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICAgIGxldCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3sgbWF0Y2g6IHRoaXMsIHR5cGU6IG51bGwsIHZpYTogbnVsbCB9XTtcbiAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksIG1hdGNoID0gY3VycmVudC5tYXRjaDtcbiAgICAgICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh7IG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCwgdHlwZSwgdmlhOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGdldCBlZGdlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIF9uX+KAi3RoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZWRnZShuKSB7XG4gICAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUncyBubyAke259dGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlZW4ubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG91dCArPSAoaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcbmNsYXNzIFRva2VuU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTsgfVxuICAgIGVhdCh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7IH1cbiAgICBlcnIoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKTsgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcInNlcVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICAgIGxldCBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJwbHVzXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInN0YXJcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwib3B0XCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICAgICAgICBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gICAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgICBsZXQgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpXG4gICAgICAgICAgICBtYXggPSBwYXJzZU51bShzdHJlYW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXggPSAtMTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcInJhbmdlXCIsIG1pbiwgbWF4LCBleHByIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgICBsZXQgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBbdHlwZV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICBpZiAodHlwZS5ncm91cHMuaW5kZXhPZihuYW1lKSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDApXG4gICAgICAgIHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSlcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSlcbiAgICAgICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIH1cbn1cbi8qKlxuQ29uc3RydWN0IGFuIE5GQSBmcm9tIGFuIGV4cHJlc3Npb24gYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlci4gVGhlXG5ORkEgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGVzLCB3aGljaCBhcmUgdGhlbXNlbHZlc1xuYXJyYXlzIG9mIGVkZ2VzLCB3aGljaCBhcmUgYHt0ZXJtLCB0b31gIG9iamVjdHMuIFRoZSBmaXJzdCBzdGF0ZSBpc1xudGhlIGVudHJ5IHN0YXRlIGFuZCB0aGUgbGFzdCBub2RlIGlzIHRoZSBzdWNjZXNzIHN0YXRlLlxuXG5Ob3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbnNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxubmVjZXNzYXJ5LlxuKi9cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gICAgbGV0IG5mYSA9IFtbXV07XG4gICAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICAgIHJldHVybiBuZmE7XG4gICAgZnVuY3Rpb24gbm9kZSgpIHsgcmV0dXJuIG5mYS5wdXNoKFtdKSAtIDE7IH1cbiAgICBmdW5jdGlvbiBlZGdlKGZyb20sIHRvLCB0ZXJtKSB7XG4gICAgICAgIGxldCBlZGdlID0geyB0ZXJtLCB0byB9O1xuICAgICAgICBuZmFbZnJvbV0ucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZWRnZSA9PiBlZGdlLnRvID0gdG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoKG91dCwgZXhwcikgPT4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBleHByLmV4cHJzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgIGNvbm5lY3QobmV4dCwgZnJvbSA9IG5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic3RhclwiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGVkZ2UoZnJvbSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBmcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByLm1pbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwci5taW47IGkgPCBleHByLm1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlKGN1ciwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tLCB1bmRlZmluZWQsIGV4cHIudmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXhwciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9XG4vLyBHZXQgdGhlIHNldCBvZiBub2RlcyByZWFjaGFibGUgYnkgbnVsbCBlZGdlcyBmcm9tIGBub2RlYC4gT21pdFxuLy8gbm9kZXMgd2l0aCBvbmx5IGEgc2luZ2xlIG51bGwtb3V0LWVkZ2UsIHNpbmNlIHRoZXkgbWF5IGxlYWQgdG9cbi8vIG5lZWRsZXNzIGR1cGxpY2F0ZWQgbm9kZXMuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgc2Nhbihub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKTtcbiAgICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICAgICAgbGV0IGVkZ2VzID0gbmZhW25vZGVdO1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEgJiYgIWVkZ2VzWzBdLnRlcm0pXG4gICAgICAgICAgICByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0ZXJtLCB0byB9ID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRlcm0gJiYgcmVzdWx0LmluZGV4T2YodG8pID09IC0xKVxuICAgICAgICAgICAgICAgIHNjYW4odG8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQ29tcGlsZXMgYW4gTkZBIGFzIHByb2R1Y2VkIGJ5IGBuZmFgIGludG8gYSBERkEsIG1vZGVsZWQgYXMgYSBzZXRcbi8vIG9mIHN0YXRlIG9iamVjdHMgKGBDb250ZW50TWF0Y2hgIGluc3RhbmNlcykgd2l0aCB0cmFuc2l0aW9uc1xuLy8gYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZGZhKG5mYSkge1xuICAgIGxldCBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZXhwbG9yZShudWxsRnJvbShuZmEsIDApKTtcbiAgICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgICAgICBsZXQgb3V0ID0gW107XG4gICAgICAgIHN0YXRlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbmZhW25vZGVdLmZvckVhY2goKHsgdGVybSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGVybSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRbaV1bMF0gPT0gdGVybSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IG91dFtpXVsxXTtcbiAgICAgICAgICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFt0ZXJtLCBzZXQgPSBbXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0LmluZGV4T2Yobm9kZSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gb3V0W2ldWzFdLnNvcnQoY21wKTtcbiAgICAgICAgICAgIHN0YXRlLm5leHQucHVzaCh7IHR5cGU6IG91dFtpXVswXSwgbmV4dDogbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoc3RhdGVzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSB3b3JrW2ldLCBkZWFkID0gIXN0YXRlLnZhbGlkRW5kLCBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IHN0YXRlLm5leHRbal07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHR5cGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVhZCAmJiAhKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICBkZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod29yay5pbmRleE9mKG5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgIHdvcmsucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVhZClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgICB9XG59XG5cbi8vIEZvciBub2RlIHR5cGVzIHdoZXJlIGFsbCBhdHRycyBoYXZlIGEgZGVmYXVsdCB2YWx1ZSAob3Igd2hpY2ggZG9uJ3Rcbi8vIGhhdmUgYW55IGF0dHJpYnV0ZXMpLCBidWlsZCB1cCBhIHNpbmdsZSByZXVzYWJsZSBkZWZhdWx0IGF0dHJpYnV0ZVxuLy8gb2JqZWN0LCBhbmQgdXNlIGl0IGZvciBhbGwgbm9kZXMgdGhhdCBkb24ndCBzcGVjaWZ5IHNwZWNpZmljXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0ci5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG59XG5mdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gICAgbGV0IGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBnaXZlbiA9IHZhbHVlICYmIHZhbHVlW25hbWVdO1xuICAgICAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICAgICAgZ2l2ZW4gPSBhdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0O1xufVxuZnVuY3Rpb24gaW5pdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZShhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cblt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbnJlcHJlc2VudHMuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgICAgICAgYXJlIGFsbG93ZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya1NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG4gICAgICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlXG4gICAgZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tOyB9XG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZSdzIFt3aGl0ZXNwYWNlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMud2hpdGVzcGFjZSkgb3B0aW9uLlxuICAgICovXG4gICAgZ2V0IHdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIGhhc1JlcXVpcmVkQXR0cnMoKSB7XG4gICAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5hdHRycylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGFsbG93cyBzb21lIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXNcbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlLlxuICAgICovXG4gICAgY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4gICAgY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4gICAgZGVmYXVsdHMgZW50aXJlbHksIGlmIG5vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZXhpc3QpLiBgY29udGVudGBcbiAgICBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuICAgIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAgIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4gICAgYWdhaW5zdCB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCByZXN0cmljdGlvbnMsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG4gICAgKi9cbiAgICBjcmVhdGVDaGVja2VkKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIHRoaXMuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgc2VlIGlmIGl0IGlzXG4gICAgbmVjZXNzYXJ5IHRvIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudFxuICAgIHRvIG1ha2UgaXQgZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCxcbiAgICByZXR1cm4gbnVsbC4gTm90ZSB0aGF0LCBkdWUgdG8gdGhlIGZhY3QgdGhhdCByZXF1aXJlZCBub2RlcyBjYW5cbiAgICBhbHdheXMgYmUgY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3JcbiAgICBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjcmVhdGVBbmRGaWxsKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgYXR0cnMgPSB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyk7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoZWQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuICAgIHR5cGUuXG4gICAgKi9cbiAgICB2YWxpZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyBub3QgdmFsaWQgY29udGVudCBmb3IgdGhpc1xuICAgIG5vZGUgdHlwZS5cbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb250ZW50IGZvciBub2RlICR7dGhpcy5uYW1lfTogJHtjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApfWApO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBtYXJrIHR5cGUgaXMgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGFyZSBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIG1hcmtzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgbm9kZSBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWFya3Muc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShub2Rlcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIGxldCB0b3BUeXBlID0gc2NoZW1hLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiO1xuICAgICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2NoZW1hIGlzIG1pc3NpbmcgaXRzIHRvcCBub2RlIHR5cGUgKCdcIiArIHRvcFR5cGUgKyBcIicpXCIpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFdmVyeSBzY2hlbWEgbmVlZHMgYSAndGV4dCcgdHlwZVwiKTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiByZXN1bHQudGV4dC5hdHRycylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIEF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuY2xhc3MgQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICB9XG4gICAgZ2V0IGlzUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0O1xuICAgIH1cbn1cbi8vIE1hcmtzXG4vKipcbkxpa2Ugbm9kZXMsIG1hcmtzICh3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIG5vZGVzIHRvIHNpZ25pZnlcbnRoaW5ncyBsaWtlIGVtcGhhc2lzIG9yIGJlaW5nIHBhcnQgb2YgYSBsaW5rKSBhcmVcblt0YWdnZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrLnR5cGUpIHdpdGggdHlwZSBvYmplY3RzLCB3aGljaCBhcmVcbmluc3RhbnRpYXRlZCBvbmNlIHBlciBgU2NoZW1hYC5cbiovXG5jbGFzcyBNYXJrVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5rLCBcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIHRoYXQgdGhpcyBtYXJrIHR5cGUgaW5zdGFuY2UgaXMgcGFydCBvZi5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgb24gd2hpY2ggdGhlIHR5cGUgaXMgYmFzZWQuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICAgICAgbGV0IGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZGVmYXVsdHMgPyBuZXcgTWFyayh0aGlzLCBkZWZhdWx0cykgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIG9mIHRoaXMgdHlwZS4gYGF0dHJzYCBtYXkgYmUgYG51bGxgIG9yIGFuIG9iamVjdFxuICAgIGNvbnRhaW5pbmcgb25seSBzb21lIG9mIHRoZSBtYXJrJ3MgYXR0cmlidXRlcy4gVGhlIG90aGVycywgaWZcbiAgICB0aGV5IGhhdmUgZGVmYXVsdHMsIHdpbGwgYmUgYWRkZWQuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmsodGhpcywgY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobWFya3MsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmFuayA9IDA7XG4gICAgICAgIG1hcmtzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBNYXJrVHlwZShuYW1lLCByYW5rKyssIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldCwgYSBuZXcgc2V0XG4gICAgd2l0aG91dCBpdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgc2V0IGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcmllcyB3aGV0aGVyIGEgZ2l2ZW4gbWFyayB0eXBlIGlzXG4gICAgW2V4Y2x1ZGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgZXhjbHVkZXMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMTtcbiAgICB9XG59XG4vKipcbkEgZG9jdW1lbnQgc2NoZW1hLiBIb2xkcyBbbm9kZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlKSBhbmQgW21hcmtcbnR5cGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrVHlwZSkgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIGFuZCBtYXJrcyB0aGF0IG1heVxub2NjdXIgaW4gY29uZm9ybWluZyBkb2N1bWVudHMsIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuY3JlYXRpbmcgYW5kIGRlc2VyaWFsaXppbmcgc3VjaCBkb2N1bWVudHMuXG5cbldoZW4gZ2l2ZW4sIHRoZSB0eXBlIHBhcmFtZXRlcnMgcHJvdmlkZSB0aGUgbmFtZXMgb2YgdGhlIG5vZGVzIGFuZFxubWFya3MgaW4gdGhpcyBzY2hlbWEuXG4qL1xuY2xhc3MgU2NoZW1hIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBzY2hlbWEgZnJvbSBhIHNjaGVtYSBbc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNjaGVtYVNwZWMpLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIFtsaW5lYnJlYWtcbiAgICAgICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5saW5lYnJlYWtSZXBsYWNlbWVudCkgbm9kZSBkZWZpbmVkXG4gICAgICAgIGluIHRoaXMgc2NoZW1hLCBpZiBhbnkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQW4gb2JqZWN0IGZvciBzdG9yaW5nIHdoYXRldmVyIHZhbHVlcyBtb2R1bGVzIG1heSB3YW50IHRvXG4gICAgICAgIGNvbXB1dGUgYW5kIGNhY2hlIHBlciBzY2hlbWEuIChJZiB5b3Ugd2FudCB0byBzdG9yZSBzb21ldGhpbmdcbiAgICAgICAgaW4gaXQsIHRyeSB0byB1c2UgcHJvcGVydHkgbmFtZXMgdW5saWtlbHkgdG8gY2xhc2guKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBpbnN0YW5jZVNwZWMgPSB0aGlzLnNwZWMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKVxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjW3Byb3BdID0gc3BlY1twcm9wXTtcbiAgICAgICAgaW5zdGFuY2VTcGVjLm5vZGVzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubm9kZXMpLFxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLFxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmtUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm1hcmtzLCB0aGlzKTtcbiAgICAgICAgbGV0IGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHRoaXMubWFya3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlc1twcm9wXSwgY29udGVudEV4cHIgPSB0eXBlLnNwZWMuY29udGVudCB8fCBcIlwiLCBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICAgICAgICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHxcbiAgICAgICAgICAgICAgICAoY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gPSBDb250ZW50TWF0Y2gucGFyc2UoY29udGVudEV4cHIsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgIHR5cGUuaW5saW5lQ29udGVudCA9IHR5cGUuY29udGVudE1hdGNoLmlubGluZUNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodHlwZS5zcGVjLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgbGluZWJyZWFrIG5vZGVzIGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzSW5saW5lIHx8ICF0eXBlLmlzTGVhZilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lYnJlYWsgcmVwbGFjZW1lbnQgbm9kZXMgbXVzdCBiZSBpbmxpbmUgbGVhZiBub2Rlc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVicmVha1JlcGxhY2VtZW50ID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1hcmtzW3Byb3BdLCBleGNsID0gdHlwZS5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgICAgICAgdHlwZS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICAgICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBpbiB0aGlzIHNjaGVtYS4gVGhlIGB0eXBlYCBtYXkgYmUgYSBzdHJpbmcgb3IgYVxuICAgIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLFxuICAgIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLCBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZlxuICAgIG5vZGVzLlxuICAgICovXG4gICAgbm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuICAgIGFsbG93ZWQuXG4gICAgKi9cbiAgICB0ZXh0KHRleHQsIG1hcmtzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCB0ZXh0LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG5vZGVGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG1hcmtGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIl9cIiB8fCAobWFyay5zcGVjLmdyb3VwICYmIG1hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChvayA9IG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaXNUYWdSdWxlKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudGFnICE9IG51bGw7IH1cbmZ1bmN0aW9uIGlzU3R5bGVSdWxlKHJ1bGUpIHsgcmV0dXJuIHJ1bGUuc3R5bGUgIT0gbnVsbDsgfVxuLyoqXG5BIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG8gYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yIGlzXG5kZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkuXG4qL1xuY2xhc3MgRE9NUGFyc2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwYXJzZXIgdGhhdCB0YXJnZXRzIHRoZSBnaXZlbiBzY2hlbWEsIHVzaW5nIHRoZSBnaXZlblxuICAgIHBhcnNpbmcgcnVsZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIGludG8gd2hpY2ggdGhlIHBhcnNlciBwYXJzZXMuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgICB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVGFnUnVsZShydWxlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucHVzaChydWxlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3R5bGVSdWxlKHJ1bGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShyID0+IHtcbiAgICAgICAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG4gICAgKi9cbiAgICBwYXJzZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlLCBsaWtlXG4gICAgW2BwYXJzZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01QYXJzZXIucGFyc2UpLCBhbmQgdGFrZXMgdGhlIHNhbWUgc2V0IG9mXG4gICAgb3B0aW9ucy4gQnV0IHVubGlrZSB0aGF0IG1ldGhvZCwgd2hpY2ggcHJvZHVjZXMgYSB3aG9sZSBub2RlLFxuICAgIHRoaXMgb25lIHJldHVybnMgYSBzbGljZSB0aGF0IGlzIG9wZW4gYXQgdGhlIHNpZGVzLCBtZWFuaW5nIHRoYXRcbiAgICB0aGUgc2NoZW1hIGNvbnN0cmFpbnRzIGFyZW4ndCBhcHBsaWVkIHRvIHRoZSBzdGFydCBvZiBub2RlcyB0b1xuICAgIHRoZSBsZWZ0IG9mIHRoZSBpbnB1dCBhbmQgdGhlIGVuZCBvZiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgcGFyc2VTbGljZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnRhZ3MuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmXG4gICAgICAgICAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoU3R5bGUocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnN0eWxlc1tpXSwgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBzdHlsZSBzdHJpbmcgZWl0aGVyIHByZWNpc2VseSBtYXRjaGVzIHRoZSBwcm9wLFxuICAgICAgICAgICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubWFyayB8fCBydWxlLmlnbm9yZSB8fCBydWxlLmNsZWFyTWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubm9kZXNbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubm9kZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgRE9NIHBhcnNlciB1c2luZyB0aGUgcGFyc2luZyBydWxlcyBsaXN0ZWQgaW4gYVxuICAgIHNjaGVtYSdzIFtub2RlIHNwZWNzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbiAgICBbcHJpb3JpdHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUucHJpb3JpdHkpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxufVxuY29uc3QgYmxvY2tUYWdzID0ge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gICAgZGQ6IHRydWUsIGRpdjogdHJ1ZSwgZGw6IHRydWUsIGZpZWxkc2V0OiB0cnVlLCBmaWdjYXB0aW9uOiB0cnVlLCBmaWd1cmU6IHRydWUsXG4gICAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gICAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBvdXRwdXQ6IHRydWUsIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHRmb290OiB0cnVlLCB1bDogdHJ1ZVxufTtcbmNvbnN0IGlnbm9yZVRhZ3MgPSB7XG4gICAgaGVhZDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9iamVjdDogdHJ1ZSwgc2NyaXB0OiB0cnVlLCBzdHlsZTogdHJ1ZSwgdGl0bGU6IHRydWVcbn07XG5jb25zdCBsaXN0VGFncyA9IHsgb2w6IHRydWUsIHVsOiB0cnVlIH07XG4vLyBVc2luZyBhIGJpdGZpZWxkIGZvciBub2RlIGNvbnRleHQgb3B0aW9uc1xuY29uc3QgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcbmZ1bmN0aW9uIHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIGJhc2UpIHtcbiAgICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpXG4gICAgICAgIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfFxuICAgICAgICAgICAgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5jbGFzcyBOb2RlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIFxuICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhpcyBub2RlIGl0c2VsZlxuICAgIG1hcmtzLCBcbiAgICAvLyBNYXJrcyB0aGF0IGNhbid0IGFwcGx5IGhlcmUsIGJ1dCB3aWxsIGJlIHVzZWQgaW4gY2hpbGRyZW4gaWYgcG9zc2libGVcbiAgICBwZW5kaW5nTWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlblxuICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICAvLyBOZXN0ZWQgTWFya3Mgd2l0aCBzYW1lIHR5cGVcbiAgICAgICAgdGhpcy5zdGFzaE1hcmtzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICBmaW5kV3JhcHBpbmcobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBmaWxsID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZpbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCwgd3JhcDtcbiAgICAgICAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHsgLy8gU3RyaXAgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLCBtO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5pc1RleHQgJiYgKG0gPSAvWyBcXHRcXHJcXG5cXHUwMDBjXSskLy5leGVjKGxhc3QudGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsYXN0LnRleHQubGVuZ3RoID09IG1bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdID0gdGV4dC53aXRoVGV4dCh0ZXh0LnRleHQuc2xpY2UoMCwgdGV4dC50ZXh0Lmxlbmd0aCAtIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICghb3BlbkVuZCAmJiB0aGlzLm1hdGNoKVxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIHBvcEZyb21TdGFzaE1hcmsobWFyaykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFzaE1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKG1hcmsuZXEodGhpcy5zdGFzaE1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFzaE1hcmtzLnNwbGljZShpLCAxKVswXTtcbiAgICB9XG4gICAgYXBwbHlQZW5kaW5nKG5leHRUeXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nTWFya3M7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFyayA9IHBlbmRpbmdbaV07XG4gICAgICAgICAgICBpZiAoKHRoaXMudHlwZSA/IHRoaXMudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpIDogbWFya01heUFwcGx5KG1hcmsudHlwZSwgbmV4dFR5cGUpKSAmJlxuICAgICAgICAgICAgICAgICFtYXJrLmlzSW5TZXQodGhpcy5hY3RpdmVNYXJrcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiAhYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICAgIHBhcnNlciwgXG4gICAgLy8gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gICAgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gICAgICAgIGxldCB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG51bGwsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAwKSB8IChpc09wZW4gPyBPUFRfT1BFTl9MRUZUIDogMCk7XG4gICAgICAgIGlmICh0b3BOb2RlKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlIGlmIChpc09wZW4pXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChwYXJzZXIuc2NoZW1hLnRvcE5vZGVUeXBlLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICAgIC8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4gICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUsIGBhZGRFbGVtZW50V2l0aFN0eWxlc2AuXG4gICAgYWRkRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbSk7XG4gICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSk7XG4gICAgfVxuICAgIHdpdGhTdHlsZVJ1bGVzKGRvbSwgZikge1xuICAgICAgICBsZXQgc3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIGxldCBtYXJrcyA9IHRoaXMucmVhZFN0eWxlcyhkb20uc3R5bGUpO1xuICAgICAgICBpZiAoIW1hcmtzKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBBIHN0eWxlIHdpdGggaWdub3JlOiB0cnVlXG4gICAgICAgIGxldCBbYWRkTWFya3MsIHJlbW92ZU1hcmtzXSA9IG1hcmtzLCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0sIHRvcCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldKTtcbiAgICAgICAgZigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZE1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0pO1xuICAgIH1cbiAgICBhZGRUZXh0Tm9kZShkb20pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCB8fFxuICAgICAgICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gYSBoYXJkIGJyZWFrLCBvciBhIHRleHQgbm9kZSB0aGF0IGVuZHMgd2l0aCB3aGl0ZXNwYWNlLCBzdHJpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdGFnIGFuZCB1c2UgdGhhdCB0byBwYXJzZS4gSWZcbiAgICAvLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuICAgIGFkZEVsZW1lbnQoZG9tLCBtYXRjaEFmdGVyKSB7XG4gICAgICAgIGxldCBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgICAgICAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKVxuICAgICAgICAgICAgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgICBsZXQgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgICAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgICAgICAgaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICAgICAgbGV0IHN5bmMsIHRvcCA9IHRoaXMudG9wLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5za2lwKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQWxsKGRvbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53aXRoU3R5bGVSdWxlcyhkb20sICgpID0+IHRoaXMuYWRkQWxsKGRvbSkpO1xuICAgICAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jKHRvcCk7XG4gICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBvbGROZWVkc0Jsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aXRoU3R5bGVSdWxlcyhkb20sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UgPyBydWxlSUQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBsZWFmIERPTSBub2RlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBpZ25vcmVkXG4gICAgbGVhZkZhbGxiYWNrKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcbiAgICBpZ25vcmVGYWxsYmFjayhkb20pIHtcbiAgICAgICAgLy8gSWdub3JlZCBCUiBub2RlcyBzaG91bGQgYXQgbGVhc3QgY3JlYXRlIGFuIGlubGluZSBjb250ZXh0XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICghdGhpcy50b3AudHlwZSB8fCAhdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KSlcbiAgICAgICAgICAgIHRoaXMuZmluZFBsYWNlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KFwiLVwiKSk7XG4gICAgfVxuICAgIC8vIFJ1biBhbnkgc3R5bGUgcGFyc2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSdzIHN0eWxlcy4gRWl0aGVyXG4gICAgLy8gcmV0dXJuIGFuIGFycmF5IG9mIG1hcmtzLCBvciBudWxsIHRvIGluZGljYXRlIHNvbWUgb2YgdGhlIHN0eWxlc1xuICAgIC8vIGhhZCBhIHJ1bGUgd2l0aCBgaWdub3JlYCBzZXQuXG4gICAgcmVhZFN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgbGV0IGFkZCA9IE1hcmsubm9uZSwgcmVtb3ZlID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gc3R5bGVzLml0ZW0oaSk7XG4gICAgICAgICAgICBmb3IgKGxldCBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKG5hbWUsIHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MuY29uY2F0KHRoaXMudG9wLmFjdGl2ZU1hcmtzKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKG0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IG0uYWRkVG9TZXQocmVtb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXS5jcmVhdGUocnVsZS5hdHRycykuYWRkVG9TZXQoYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBydWxlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthZGQsIHJlbW92ZV07XG4gICAgfVxuICAgIC8vIExvb2sgdXAgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgbm9uZSBhcmUgZm91bmQsIHJldHVyblxuICAgIC8vIGZhbHNlLiBPdGhlcndpc2UsIGFwcGx5IGl0LCB1c2UgaXRzIHJldHVybiB2YWx1ZSB0byBkcml2ZSB0aGUgd2F5XG4gICAgLy8gdGhlIG5vZGUncyBjb250ZW50IGlzIHdyYXBwZWQsIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICBhZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgY29udGludWVBZnRlcikge1xuICAgICAgICBsZXQgc3luYywgbm9kZVR5cGUsIG1hcms7XG4gICAgICAgIGlmIChydWxlLm5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgICAgICBpZiAoIW5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIHN5bmMgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzIHx8IG51bGwsIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmluc2VydE5vZGUobm9kZVR5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya1R5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydEluID0gdGhpcy50b3A7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIGNvbnRpbnVlQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bGUuZ2V0Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQoZG9tLCB0aGlzLnBhcnNlci5zY2hlbWEpLmZvckVhY2gobm9kZSA9PiB0aGlzLmluc2VydE5vZGUobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRET00gPSBkb207XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gZG9tLnF1ZXJ5U2VsZWN0b3IocnVsZS5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuY29udGVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jICYmIHRoaXMuc3luYyhzdGFydEluKSlcbiAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFyaywgc3RhcnRJbik7XG4gICAgfVxuICAgIC8vIEFkZCBhbGwgY2hpbGQgbm9kZXMgYmV0d2VlbiBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgKG9yIHRoZVxuICAgIC8vIHdob2xlIG5vZGUsIGlmIG5vdCBnaXZlbikuIElmIGBzeW5jYCBpcyBwYXNzZWQsIHVzZSBpdCB0b1xuICAgIC8vIHN5bmNocm9uaXplIGFmdGVyIGV2ZXJ5IGJsb2NrIGVsZW1lbnQuXG4gICAgYWRkQWxsKHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICAgICAgICBmb3IgKGxldCBkb20gPSBzdGFydEluZGV4ID8gcGFyZW50LmNoaWxkTm9kZXNbc3RhcnRJbmRleF0gOiBwYXJlbnQuZmlyc3RDaGlsZCwgZW5kID0gZW5kSW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuY2hpbGROb2Rlc1tlbmRJbmRleF07IGRvbSAhPSBlbmQ7IGRvbSA9IGRvbS5uZXh0U2libGluZywgKytpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRE9NKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSB3YXkgdG8gZml0IHRoZSBnaXZlbiBub2RlIHR5cGUgaW50byB0aGUgY3VycmVudFxuICAgIC8vIGNvbnRleHQuIE1heSBhZGQgaW50ZXJtZWRpYXRlIHdyYXBwZXJzIGFuZC9vciBsZWF2ZSBub24tc29saWRcbiAgICAvLyBub2RlcyB0aGF0IHdlJ3JlIGluLlxuICAgIGZpbmRQbGFjZShub2RlKSB7XG4gICAgICAgIGxldCByb3V0ZSwgc3luYztcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY3guZmluZFdyYXBwaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICYmICghcm91dGUgfHwgcm91dGUubGVuZ3RoID4gZm91bmQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgc3luYyA9IGN4O1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjeC5zb2xpZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmVudGVySW5uZXIocm91dGVbaV0sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRyeSB0byBpbnNlcnQgdGhlIGdpdmVuIG5vZGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuIG5lZWRlZC5cbiAgICBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLnRleHRibG9ja0Zyb21Db250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maW5kUGxhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgdG9wLmFwcGx5UGVuZGluZyhub2RlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHRvcC5tYXRjaClcbiAgICAgICAgICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0b3AuYWN0aXZlTWFya3M7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSB8fCB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShub2RlLm1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG5vZGUubWFya3NbaV0uYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgdG9wLmNvbnRlbnQucHVzaChub2RlLm1hcmsobWFya3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbiAgICAvLyBuZWNlc3NhcnkuXG4gICAgZW50ZXIodHlwZSwgYXR0cnMsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgbGV0IG9rID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHR5cGUsIGF0dHJzLCB0cnVlLCBwcmVzZXJ2ZVdTKTtcbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH1cbiAgICAvLyBPcGVuIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgIGVudGVySW5uZXIodHlwZSwgYXR0cnMgPSBudWxsLCBzb2xpZCA9IGZhbHNlLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRvcC5hcHBseVBlbmRpbmcodHlwZSk7XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaCAmJiB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdTLCB0b3Aub3B0aW9ucyk7XG4gICAgICAgIGlmICgodG9wLm9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUKSAmJiB0b3AuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgdG9wLmFjdGl2ZU1hcmtzLCB0b3AucGVuZGluZ01hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgICB0aGlzLm9wZW4rKztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGFsbCBub2RlcyBhYm92ZSB0aGlzLm9wZW4gYXJlIGZpbmlzaGVkIGFuZCBhZGRlZCB0b1xuICAgIC8vIHRoZWlyIHBhcmVudHNcbiAgICBjbG9zZUV4dHJhKG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaSA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLmZpbmlzaCh0aGlzLmlzT3BlbiB8fCB0aGlzLm9wdGlvbnMudG9wT3Blbik7XG4gICAgfVxuICAgIHN5bmModG8pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb3MoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5ub2Rlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBjb250ZW50ICYmIHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAmIChiZWZvcmUgPyAyIDogNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluVGV4dCh0ZXh0Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gdGV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3MgLSAodGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIHRoaXMuZmluZFtpXS5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvbnRleHQgc3RyaW5nIG1hdGNoZXMgdGhpcyBjb250ZXh0LlxuICAgIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcyk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGxldCB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICAgICAgICBsZXQgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgICBsZXQgbWF0Y2ggPSAoaSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBkZXB0aCA+IDAgfHwgKGRlcHRoID09IDAgJiYgdXNlUm9vdCkgPyB0aGlzLm5vZGVzW2RlcHRoXS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbiAmJiBkZXB0aCA+PSBtaW5EZXB0aCA/IG9wdGlvbi5ub2RlKGRlcHRoIC0gbWluRGVwdGgpLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCAobmV4dC5uYW1lICE9IHBhcnQgJiYgbmV4dC5ncm91cHMuaW5kZXhPZihwYXJ0KSA9PSAtMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXRjaChwYXJ0cy5sZW5ndGggLSAxLCB0aGlzLm9wZW4pO1xuICAgIH1cbiAgICB0ZXh0YmxvY2tGcm9tQ29udGV4dCgpIHtcbiAgICAgICAgbGV0ICRjb250ZXh0ID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGlmICgkY29udGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVmbHQgPSAkY29udGV4dC5ub2RlKGQpLmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4QWZ0ZXIoZCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jayAmJiBkZWZsdC5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUGVuZGluZ01hcmsobWFyaykge1xuICAgICAgICBsZXQgZm91bmQgPSBmaW5kU2FtZU1hcmtJblNldChtYXJrLCB0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICB0aGlzLnRvcC5zdGFzaE1hcmtzLnB1c2goZm91bmQpO1xuICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gICAgfVxuICAgIHJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHVwdG8pIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gbGV2ZWwucGVuZGluZ01hcmtzLmxhc3RJbmRleE9mKG1hcmspO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwucGVuZGluZ01hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICBsZXQgc3Rhc2hNYXJrID0gbGV2ZWwucG9wRnJvbVN0YXNoTWFyayhtYXJrKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Rhc2hNYXJrICYmIGxldmVsLnR5cGUgJiYgbGV2ZWwudHlwZS5hbGxvd3NNYXJrVHlwZShzdGFzaE1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gc3Rhc2hNYXJrLmFkZFRvU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSB1cHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGRpcmVjdGx5IG5lc3RlZCBsaXN0IG5vZGVzIHByb2R1Y2VkIGJ5IHNvbWVcbi8vIHRvb2xzIGFuZCBhbGxvd2VkIGJ5IGJyb3dzZXJzIHRvIG1lYW4gdGhhdCB0aGUgbmVzdGVkIGxpc3QgaXNcbi8vIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgaXRlbSBhYm92ZSBpdC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgJiYgbGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcHJldkl0ZW0pIHtcbiAgICAgICAgICAgIHByZXZJdGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJldkl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQXBwbHkgYSBDU1Mgc2VsZWN0b3IuXG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyBVc2VkIHdoZW4gZmluZGluZyBhIG1hcmsgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZyYWdtZW50IHBhcnNlLlxuLy8gQ2hlY2tzIHdoZXRoZXIgaXQgd291bGQgYmUgcmVhc29uYWJsZSB0byBhcHBseSBhIGdpdmVuIG1hcmsgdHlwZSB0b1xuLy8gYSBnaXZlbiBub2RlLCBieSBsb29raW5nIGF0IHRoZSB3YXkgdGhlIG1hcmsgb2NjdXJzIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gICAgbGV0IG5vZGVzID0gbm9kZVR5cGUuc2NoZW1hLm5vZGVzO1xuICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHNlZW4gPSBbXSwgc2NhbiA9IChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpIDwgMCAmJiBzY2FuKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2FtZU1hcmtJblNldChtYXJrLCBzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWFyay5lcShzZXRbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG59XG5cbi8qKlxuQSBET00gc2VyaWFsaXplciBrbm93cyBob3cgdG8gY29udmVydCBQcm9zZU1pcnJvciBub2RlcyBhbmRcbm1hcmtzIG9mIHZhcmlvdXMgdHlwZXMgdG8gRE9NIG5vZGVzLlxuKi9cbmNsYXNzIERPTVNlcmlhbGl6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlcmlhbGl6ZXIuIGBub2Rlc2Agc2hvdWxkIG1hcCBub2RlIG5hbWVzIHRvIGZ1bmN0aW9uc1xuICAgIHRoYXQgdGFrZSBhIG5vZGUgYW5kIHJldHVybiBhIGRlc2NyaXB0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgRE9NLiBgbWFya3NgIGRvZXMgdGhlIHNhbWUgZm9yIG1hcmsgbmFtZXMsIGJ1dCBhbHNvIGdldHMgYW5cbiAgICBhcmd1bWVudCB0aGF0IHRlbGxzIGl0IHdoZXRoZXIgdGhlIG1hcmsncyBjb250ZW50IGlzIGJsb2NrIG9yXG4gICAgaW5saW5lIGNvbnRlbnQgKGZvciB0eXBpY2FsIHVzZSwgaXQnbGwgYWx3YXlzIGJlIGlubGluZSkuIEEgbWFya1xuICAgIHNlcmlhbGl6ZXIgbWF5IGJlIGBudWxsYCB0byBpbmRpY2F0ZSB0aGF0IG1hcmtzIG9mIHRoYXQgdHlwZVxuICAgIHNob3VsZCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbm9kZXMsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbWFya3MpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGlzIGZyYWdtZW50IHRvIGEgRE9NIGZyYWdtZW50LiBXaGVuXG4gICAgbm90IGluIHRoZSBicm93c2VyLCB0aGUgYGRvY3VtZW50YCBvcHRpb24sIGNvbnRhaW5pbmcgYSBET01cbiAgICBkb2N1bWVudCwgc2hvdWxkIGJlIHBhc3NlZCBzbyB0aGF0IHRoZSBzZXJpYWxpemVyIGNhbiBjcmVhdGVcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zID0ge30sIHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCB0b3AgPSB0YXJnZXQsIGFjdGl2ZSA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggfHwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQga2VlcCA9IDAsIHJlbmRlcmVkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0b3AgPSBhY3RpdmUucG9wKClbMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrRE9NID0gdGhpcy5zZXJpYWxpemVNYXJrKGFkZCwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChbYWRkLCB0b3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZChtYXJrRE9NLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQodGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgeyBkb20sIGNvbnRlbnRET00gfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRoaXMubm9kZXNbbm9kZS50eXBlLm5hbWVdKG5vZGUpKTtcbiAgICAgICAgaWYgKGNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIG5vZGUgdG8gYSBET00gbm9kZS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91XG4gICAgbmVlZCB0byBzZXJpYWxpemUgYSBwYXJ0IG9mIGEgZG9jdW1lbnQsIGFzIG9wcG9zZWQgdG8gdGhlIHdob2xlXG4gICAgZG9jdW1lbnQuIFRvIHNlcmlhbGl6ZSBhIHdob2xlIGRvY3VtZW50LCB1c2VcbiAgICBbYHNlcmlhbGl6ZUZyYWdtZW50YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQpIG9uXG4gICAgaXRzIFtjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5jb250ZW50KS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGUobm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGUubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHdyYXApIHtcbiAgICAgICAgICAgICAgICAod3JhcC5jb250ZW50RE9NIHx8IHdyYXAuZG9tKS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXAuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTWFyayhtYXJrLCBpbmxpbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdG9ET00gPSB0aGlzLm1hcmtzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHRvRE9NICYmIERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW5kZXIgYW4gW291dHB1dCBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NT3V0cHV0U3BlYykgdG8gYSBET00gbm9kZS4gSWZcbiAgICB0aGUgc3BlYyBoYXMgYSBob2xlICh6ZXJvKSBpbiBpdCwgYGNvbnRlbnRET01gIHdpbGwgcG9pbnQgYXQgdGhlXG4gICAgbm9kZSB3aXRoIHRoZSBob2xlLlxuICAgICovXG4gICAgc3RhdGljIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TID0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cnVjdHVyZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKSB9O1xuICAgICAgICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4geyBkb206IHN0cnVjdHVyZSB9O1xuICAgICAgICBpZiAoc3RydWN0dXJlLmRvbSAmJiBzdHJ1Y3R1cmUuZG9tLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgICAgICBsZXQgdGFnTmFtZSA9IHN0cnVjdHVyZVswXSwgc3BhY2UgPSB0YWdOYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgICAgICB4bWxOUyA9IHRhZ05hbWUuc2xpY2UoMCwgc3BhY2UpO1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudERPTTtcbiAgICAgICAgbGV0IGRvbSA9ICh4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICAgICAgICBsZXQgYXR0cnMgPSBzdHJ1Y3R1cmVbMV0sIHN0YXJ0ID0gMTtcbiAgICAgICAgaWYgKGF0dHJzICYmIHR5cGVvZiBhdHRycyA9PSBcIm9iamVjdFwiICYmIGF0dHJzLm5vZGVUeXBlID09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDI7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgICAgIGlmIChhdHRyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IG5hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlTlMobmFtZS5zbGljZSgwLCBzcGFjZSksIG5hbWUuc2xpY2Uoc3BhY2UgKyAxKSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBzdHJ1Y3R1cmVbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHN0cnVjdHVyZS5sZW5ndGggLSAxIHx8IGkgPiBzdGFydClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbXVzdCBiZSB0aGUgb25seSBjaGlsZCBvZiBpdHMgcGFyZW50IG5vZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NOiBkb20gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGRvbTogaW5uZXIsIGNvbnRlbnRET006IGlubmVyQ29udGVudCB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TKTtcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIHNlcmlhbGl6ZXIgdXNpbmcgdGhlIFtgdG9ET01gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMudG9ET00pXG4gICAgcHJvcGVydGllcyBpbiBhIHNjaGVtYSdzIG5vZGUgYW5kIG1hcmsgc3BlY3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciA9IG5ldyBET01TZXJpYWxpemVyKHRoaXMubm9kZXNGcm9tU2NoZW1hKHNjaGVtYSksIHRoaXMubWFya3NGcm9tU2NoZW1hKHNjaGVtYSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG5vZGUgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgVGhpcyBjYW4gYmUgdXNlZnVsIGFzIGEgYmFzZSB0byBidWlsZCBhIGN1c3RvbSBzZXJpYWxpemVyIGZyb20uXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZXNGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZ2F0aGVyVG9ET00oc2NoZW1hLm5vZGVzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHJlc3VsdC50ZXh0ID0gbm9kZSA9PiBub2RlLnRleHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBtYXJrIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIG1hcmtzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGdhdGhlclRvRE9NKHNjaGVtYS5tYXJrcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyVG9ET00ob2JqKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGxldCB0b0RPTSA9IG9ialtuYW1lXS5zcGVjLnRvRE9NO1xuICAgICAgICBpZiAodG9ET00pXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB0b0RPTTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xufVxuXG5leHBvcnQgeyBDb250ZW50TWF0Y2gsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIE1hcmtUeXBlLCBOb2RlLCBOb2RlUmFuZ2UsIE5vZGVUeXBlLCBSZXBsYWNlRXJyb3IsIFJlc29sdmVkUG9zLCBTY2hlbWEsIFNsaWNlIH07XG4iXSwibmFtZXMiOlsiT3JkZXJlZE1hcCIsImZpbmREaWZmU3RhcnQiLCJhIiwiYiIsInBvcyIsImkiLCJjaGlsZENvdW50IiwiY2hpbGRBIiwiY2hpbGQiLCJjaGlsZEIiLCJub2RlU2l6ZSIsInNhbWVNYXJrdXAiLCJpc1RleHQiLCJ0ZXh0IiwiaiIsImNvbnRlbnQiLCJzaXplIiwiaW5uZXIiLCJmaW5kRGlmZkVuZCIsInBvc0EiLCJwb3NCIiwiaUEiLCJpQiIsInNhbWUiLCJtaW5TaXplIiwiTWF0aCIsIm1pbiIsImxlbmd0aCIsIkZyYWdtZW50IiwiY29uc3RydWN0b3IiLCJub2Rlc0JldHdlZW4iLCJmcm9tIiwidG8iLCJmIiwibm9kZVN0YXJ0IiwicGFyZW50IiwiZW5kIiwic3RhcnQiLCJtYXgiLCJkZXNjZW5kYW50cyIsInRleHRCZXR3ZWVuIiwiYmxvY2tTZXBhcmF0b3IiLCJsZWFmVGV4dCIsImZpcnN0Iiwibm9kZSIsIm5vZGVUZXh0Iiwic2xpY2UiLCJpc0xlYWYiLCJ0eXBlIiwic3BlYyIsImlzQmxvY2siLCJpc1RleHRibG9jayIsImFwcGVuZCIsIm90aGVyIiwibGFzdCIsImxhc3RDaGlsZCIsImZpcnN0Q2hpbGQiLCJ3aXRoVGV4dCIsInB1c2giLCJjdXQiLCJyZXN1bHQiLCJjdXRCeUluZGV4IiwiZW1wdHkiLCJyZXBsYWNlQ2hpbGQiLCJpbmRleCIsImN1cnJlbnQiLCJjb3B5IiwiYWRkVG9TdGFydCIsImNvbmNhdCIsImFkZFRvRW5kIiwiZXEiLCJmb3VuZCIsIlJhbmdlRXJyb3IiLCJtYXliZUNoaWxkIiwiZm9yRWFjaCIsInAiLCJvdGhlclBvcyIsImZpbmRJbmRleCIsInJvdW5kIiwicmV0SW5kZXgiLCJjdXJQb3MiLCJjdXIiLCJ0b1N0cmluZyIsInRvU3RyaW5nSW5uZXIiLCJqb2luIiwidG9KU09OIiwibWFwIiwibiIsImZyb21KU09OIiwic2NoZW1hIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJub2RlRnJvbUpTT04iLCJmcm9tQXJyYXkiLCJhcnJheSIsImpvaW5lZCIsIm5vZGVzIiwiYXR0cnMiLCJvZmZzZXQiLCJjb21wYXJlRGVlcCIsIk1hcmsiLCJhZGRUb1NldCIsInNldCIsInBsYWNlZCIsImV4Y2x1ZGVzIiwicmFuayIsInJlbW92ZUZyb21TZXQiLCJpc0luU2V0Iiwib2JqIiwibmFtZSIsIl8iLCJqc29uIiwibWFya3MiLCJjcmVhdGUiLCJzYW1lU2V0Iiwic2V0RnJvbSIsIm5vbmUiLCJzb3J0IiwiUmVwbGFjZUVycm9yIiwiRXJyb3IiLCJTbGljZSIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJpbnNlcnRBdCIsImZyYWdtZW50IiwiaW5zZXJ0SW50byIsInJlbW92ZUJldHdlZW4iLCJyZW1vdmVSYW5nZSIsIm1heE9wZW4iLCJvcGVuSXNvbGF0aW5nIiwiaXNvbGF0aW5nIiwiaW5kZXhUbyIsIm9mZnNldFRvIiwiZGlzdCIsImluc2VydCIsImNhblJlcGxhY2UiLCJyZXBsYWNlIiwiJGZyb20iLCIkdG8iLCJkZXB0aCIsInJlcGxhY2VPdXRlciIsImNsb3NlIiwicmVwbGFjZVR3b1dheSIsInBhcmVudE9mZnNldCIsInByZXBhcmVTbGljZUZvclJlcGxhY2UiLCJyZXBsYWNlVGhyZWVXYXkiLCJjaGVja0pvaW4iLCJtYWluIiwic3ViIiwiY29tcGF0aWJsZUNvbnRlbnQiLCJqb2luYWJsZSIsIiRiZWZvcmUiLCIkYWZ0ZXIiLCJhZGROb2RlIiwidGFyZ2V0IiwiYWRkUmFuZ2UiLCIkc3RhcnQiLCIkZW5kIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwidGV4dE9mZnNldCIsIm5vZGVBZnRlciIsIm5vZGVCZWZvcmUiLCJjaGVja0NvbnRlbnQiLCIkYWxvbmciLCJleHRyYSIsInJlc29sdmVOb0NhY2hlIiwiUmVzb2x2ZWRQb3MiLCJwYXRoIiwicmVzb2x2ZURlcHRoIiwidmFsIiwiZG9jIiwiaW5kZXhBZnRlciIsImJlZm9yZSIsImFmdGVyIiwiZE9mZiIsInBvc0F0SW5kZXgiLCJ0bXAiLCJpbmNsdXNpdmUiLCJtYXJrc0Fjcm9zcyIsImlzSW5saW5lIiwibmV4dCIsInNoYXJlZERlcHRoIiwiYmxvY2tSYW5nZSIsInByZWQiLCJkIiwiaW5saW5lQ29udGVudCIsIk5vZGVSYW5nZSIsInNhbWVQYXJlbnQiLCJzdHIiLCJyZXNvbHZlIiwicmVtIiwicmVzb2x2ZUNhY2hlZCIsInJlc29sdmVDYWNoZSIsImNhY2hlZCIsInJlc29sdmVDYWNoZVBvcyIsInJlc29sdmVDYWNoZVNpemUiLCJlbXB0eUF0dHJzIiwiT2JqZWN0IiwiTm9kZSIsInN0YXJ0UG9zIiwidGV4dENvbnRlbnQiLCJoYXNNYXJrdXAiLCJkZWZhdWx0QXR0cnMiLCJtYXJrIiwiaW5jbHVkZVBhcmVudHMiLCJub2RlQXQiLCJjaGlsZEFmdGVyIiwiY2hpbGRCZWZvcmUiLCJyYW5nZUhhc01hcmsiLCJpc0F0b20iLCJ0b0RlYnVnU3RyaW5nIiwid3JhcE1hcmtzIiwiY29udGVudE1hdGNoQXQiLCJtYXRjaCIsImNvbnRlbnRNYXRjaCIsIm1hdGNoRnJhZ21lbnQiLCJyZXBsYWNlbWVudCIsIm9uZSIsInR3byIsInZhbGlkRW5kIiwiYWxsb3dzTWFya3MiLCJjYW5SZXBsYWNlV2l0aCIsIm1hdGNoVHlwZSIsImNhbkFwcGVuZCIsImNoZWNrIiwibSIsIm1hcmtGcm9tSlNPTiIsIm5vZGVUeXBlIiwicHJvdG90eXBlIiwidW5kZWZpbmVkIiwiVGV4dE5vZGUiLCJKU09OIiwic3RyaW5naWZ5IiwiYmFzZSIsIkNvbnRlbnRNYXRjaCIsIndyYXBDYWNoZSIsInBhcnNlIiwic3RyaW5nIiwibm9kZVR5cGVzIiwic3RyZWFtIiwiVG9rZW5TdHJlYW0iLCJleHByIiwicGFyc2VFeHByIiwiZXJyIiwiZGZhIiwibmZhIiwiY2hlY2tGb3JEZWFkRW5kcyIsImZyYWciLCJkZWZhdWx0VHlwZSIsImhhc1JlcXVpcmVkQXR0cnMiLCJjb21wYXRpYmxlIiwiZmlsbEJlZm9yZSIsInRvRW5kIiwic2VlbiIsInNlYXJjaCIsInR5cGVzIiwiZmluaXNoZWQiLCJ0cCIsImNyZWF0ZUFuZEZpbGwiLCJpbmRleE9mIiwiZmluZFdyYXBwaW5nIiwiY29tcHV0ZWQiLCJjb21wdXRlV3JhcHBpbmciLCJhY3RpdmUiLCJ2aWEiLCJzaGlmdCIsInJldmVyc2UiLCJlZGdlQ291bnQiLCJlZGdlIiwic2NhbiIsIm91dCIsImlubGluZSIsInRva2VucyIsInNwbGl0IiwicG9wIiwiZWF0IiwidG9rIiwiU3ludGF4RXJyb3IiLCJleHBycyIsInBhcnNlRXhwclNlcSIsInBhcnNlRXhwclN1YnNjcmlwdCIsInBhcnNlRXhwckF0b20iLCJwYXJzZUV4cHJSYW5nZSIsInBhcnNlTnVtIiwidGVzdCIsIk51bWJlciIsInJlc29sdmVOYW1lIiwidHlwZU5hbWUiLCJncm91cHMiLCJjb25uZWN0IiwiY29tcGlsZSIsInRlcm0iLCJlZGdlcyIsInJlZHVjZSIsImxvb3AiLCJjbXAiLCJudWxsRnJvbSIsImxhYmVsZWQiLCJleHBsb3JlIiwic3RhdGVzIiwic3RhdGUiLCJ3b3JrIiwiZGVhZCIsImRlZmF1bHRzIiwiYXR0ck5hbWUiLCJhdHRyIiwiaGFzRGVmYXVsdCIsImRlZmF1bHQiLCJjb21wdXRlQXR0cnMiLCJidWlsdCIsImdpdmVuIiwiaW5pdEF0dHJzIiwiQXR0cmlidXRlIiwiTm9kZVR5cGUiLCJtYXJrU2V0IiwiZ3JvdXAiLCJhdG9tIiwid2hpdGVzcGFjZSIsImNvZGUiLCJpc1JlcXVpcmVkIiwiY3JlYXRlQ2hlY2tlZCIsIm1hdGNoZWQiLCJ2YWxpZENvbnRlbnQiLCJhbGxvd3NNYXJrVHlwZSIsIm1hcmtUeXBlIiwiYWxsb3dlZE1hcmtzIiwidG9wVHlwZSIsInRvcE5vZGUiLCJvcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiTWFya1R5cGUiLCJleGNsdWRlZCIsImluc3RhbmNlIiwiU2NoZW1hIiwibGluZWJyZWFrUmVwbGFjZW1lbnQiLCJpbnN0YW5jZVNwZWMiLCJwcm9wIiwiY29udGVudEV4cHJDYWNoZSIsImNvbnRlbnRFeHByIiwibWFya0V4cHIiLCJnYXRoZXJNYXJrcyIsImV4Y2wiLCJiaW5kIiwidG9wTm9kZVR5cGUiLCJ3cmFwcGluZ3MiLCJvayIsImlzVGFnUnVsZSIsInJ1bGUiLCJ0YWciLCJpc1N0eWxlUnVsZSIsInN0eWxlIiwiRE9NUGFyc2VyIiwicnVsZXMiLCJ0YWdzIiwic3R5bGVzIiwibm9ybWFsaXplTGlzdHMiLCJzb21lIiwiciIsImRvbSIsImNvbnRleHQiLCJQYXJzZUNvbnRleHQiLCJhZGRBbGwiLCJmaW5pc2giLCJwYXJzZVNsaWNlIiwibWF0Y2hUYWciLCJtYXRjaGVzIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwibWF0Y2hlc0NvbnRleHQiLCJnZXRBdHRycyIsIm1hdGNoU3R5bGUiLCJjaGFyQ29kZUF0Iiwic2NoZW1hUnVsZXMiLCJwcmlvcml0eSIsIm5leHRQcmlvcml0eSIsInNwbGljZSIsInBhcnNlRE9NIiwiaWdub3JlIiwiY2xlYXJNYXJrIiwiZnJvbVNjaGVtYSIsImRvbVBhcnNlciIsImJsb2NrVGFncyIsImFkZHJlc3MiLCJhcnRpY2xlIiwiYXNpZGUiLCJibG9ja3F1b3RlIiwiY2FudmFzIiwiZGQiLCJkaXYiLCJkbCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImZvcm0iLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImxpIiwibm9zY3JpcHQiLCJvbCIsIm91dHB1dCIsInByZSIsInNlY3Rpb24iLCJ0YWJsZSIsInRmb290IiwidWwiLCJpZ25vcmVUYWdzIiwiaGVhZCIsIm9iamVjdCIsInNjcmlwdCIsInRpdGxlIiwibGlzdFRhZ3MiLCJPUFRfUFJFU0VSVkVfV1MiLCJPUFRfUFJFU0VSVkVfV1NfRlVMTCIsIk9QVF9PUEVOX0xFRlQiLCJ3c09wdGlvbnNGb3IiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJOb2RlQ29udGV4dCIsInBlbmRpbmdNYXJrcyIsInNvbGlkIiwiYWN0aXZlTWFya3MiLCJzdGFzaE1hcmtzIiwiZmlsbCIsIndyYXAiLCJleGVjIiwicG9wRnJvbVN0YXNoTWFyayIsImFwcGx5UGVuZGluZyIsIm5leHRUeXBlIiwicGVuZGluZyIsIm1hcmtNYXlBcHBseSIsImlubGluZUNvbnRleHQiLCJwYXJlbnROb2RlIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlciIsImlzT3BlbiIsIm9wZW4iLCJ0b3BDb250ZXh0IiwidG9wT3B0aW9ucyIsInRvcE1hdGNoIiwiZmluZCIsImZpbmRQb3NpdGlvbnMiLCJuZWVkc0Jsb2NrIiwidG9wIiwiYWRkRE9NIiwiYWRkVGV4dE5vZGUiLCJhZGRFbGVtZW50Iiwid2l0aFN0eWxlUnVsZXMiLCJyZWFkU3R5bGVzIiwiYWRkTWFya3MiLCJyZW1vdmVNYXJrcyIsInJlbW92ZVBlbmRpbmdNYXJrIiwiYWRkUGVuZGluZ01hcmsiLCJub2RlVmFsdWUiLCJkb21Ob2RlQmVmb3JlIiwicHJldmlvdXNTaWJsaW5nIiwiaW5zZXJ0Tm9kZSIsImZpbmRJblRleHQiLCJmaW5kSW5zaWRlIiwibWF0Y2hBZnRlciIsInJ1bGVJRCIsIm5vcm1hbGl6ZUxpc3QiLCJydWxlRnJvbU5vZGUiLCJpZ25vcmVGYWxsYmFjayIsInNraXAiLCJjbG9zZVBhcmVudCIsInN5bmMiLCJvbGROZWVkc0Jsb2NrIiwibGVhZkZhbGxiYWNrIiwiYWRkRWxlbWVudEJ5UnVsZSIsImNvbnN1bWluZyIsIm93bmVyRG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImZpbmRQbGFjZSIsImFkZCIsInJlbW92ZSIsImwiLCJpdGVtIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImNvbnRpbnVlQWZ0ZXIiLCJlbnRlciIsInN0YXJ0SW4iLCJnZXRDb250ZW50IiwiY29udGVudERPTSIsImNvbnRlbnRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImZpbmRBcm91bmQiLCJjaGlsZE5vZGVzIiwibmV4dFNpYmxpbmciLCJmaW5kQXRQb2ludCIsInJvdXRlIiwiY3giLCJlbnRlcklubmVyIiwiYmxvY2siLCJ0ZXh0YmxvY2tGcm9tQ29udGV4dCIsImNsb3NlRXh0cmEiLCJwcmVzZXJ2ZVdTIiwidG9wT3BlbiIsImN1cnJlbnRQb3MiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwidGV4dE5vZGUiLCJwYXJ0cyIsIm9wdGlvbiIsInVzZVJvb3QiLCJtaW5EZXB0aCIsInBhcnQiLCIkY29udGV4dCIsImRlZmx0IiwiZmluZFNhbWVNYXJrSW5TZXQiLCJ1cHRvIiwibGV2ZWwiLCJsYXN0SW5kZXhPZiIsInN0YXNoTWFyayIsInByZXZJdGVtIiwiYXBwZW5kQ2hpbGQiLCJzZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwiRE9NU2VyaWFsaXplciIsInNlcmlhbGl6ZUZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImtlZXAiLCJyZW5kZXJlZCIsInNwYW5uaW5nIiwibWFya0RPTSIsInNlcmlhbGl6ZU1hcmsiLCJzZXJpYWxpemVOb2RlSW5uZXIiLCJyZW5kZXJTcGVjIiwic2VyaWFsaXplTm9kZSIsInRvRE9NIiwic3RydWN0dXJlIiwieG1sTlMiLCJ0YWdOYW1lIiwic3BhY2UiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJpbm5lckNvbnRlbnQiLCJkb21TZXJpYWxpemVyIiwibm9kZXNGcm9tU2NoZW1hIiwibWFya3NGcm9tU2NoZW1hIiwiZ2F0aGVyVG9ET00iLCJkb2N1bWVudCIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-model/dist/index.js\n");

/***/ })

};
;