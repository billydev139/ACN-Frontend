"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-view";
exports.ids = ["vendor-chunks/prosemirror-view"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard),\n/* harmony export */   __serializeForClipboard: () => (/* binding */ __serializeForClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst domIndex = function(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n};\nconst parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function(node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\nconst clearReusedRange = function() {\n    reusedRange = null;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\") return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.contentEditable == \"false\") return false;\n            off = dir < 0 ? nodeSize(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset) return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) return node;\n        if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction isOnEdge(node, offset, parent) {\n    for(let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;){\n        if (node == parent) return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node) return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for(let cur = dom; cur; cur = cur.parentNode)if (desc = cur.pmViewDesc) break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) return {\n                node: pos.offsetNode,\n                offset: pos.offset\n            };\n        } catch (_) {}\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range) return {\n            node: range.startContainer,\n            offset: range.startOffset\n        };\n    }\n}\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = nav && nav.userAgent || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [\n    0,\n    0\n])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n    0,\n    0\n])[1] : 0;\nfunction windowRect(doc) {\n    let vp = doc.defaultView && doc.defaultView.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: doc.documentElement.clientWidth,\n        top: 0,\n        bottom: doc.documentElement.clientHeight\n    };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return {\n        left: rect.left,\n        right: rect.left + node.clientWidth * scaleX,\n        top: rect.top,\n        bottom: rect.top + node.clientHeight * scaleY\n    };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for(let parent = startDOM || view.dom;; parent = parentNode(parent)){\n        if (!parent) break;\n        if (parent.nodeType != 1) continue;\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\")) moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            } else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY) elt.scrollTop += moveY;\n                if (moveX) elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = {\n                    left: rect.left - dX,\n                    top: rect.top - dY,\n                    right: rect.right - dX,\n                    bottom: rect.bottom - dY\n                };\n            }\n        }\n        if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position)) break;\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for(let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5){\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return {\n        refDOM: refDOM,\n        refTop: refTop,\n        stack: scrollStack(view.dom)\n    };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for(let cur = dom; cur; cur = parentNode(cur)){\n        stack.push({\n            dom: cur,\n            top: cur.scrollTop,\n            left: cur.scrollLeft\n        });\n        if (dom == doc) break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for(let i = 0; i < stack.length; i++){\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left) dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for(let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++){\n        let rects;\n        if (child.nodeType == 1) rects = child.getClientRects();\n        else if (child.nodeType == 3) rects = textRange(child).getClientRects();\n        else continue;\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = {\n                    left: Math.max(rect.left, Math.min(rect.right, coords.left)),\n                    top: rect.top\n                };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1) return {\n        node,\n        offset\n    };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for(let i = 0; i < len; i++){\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom) continue;\n        if (inRect(coords, rect)) return {\n            node,\n            offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n        };\n    }\n    return {\n        node,\n        offset: 0\n    };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for(let cur = node, sawBlock = false;;){\n        if (cur == view.dom) break;\n        let desc = view.docView.nearestDesc(cur, true);\n        if (!desc) return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM)) {\n            let rect = desc.dom.getBoundingClientRect();\n            if (desc.node.isBlock && desc.parent) {\n                // Only apply the horizontal test to the innermost block. Vertical for any parent.\n                if (!sawBlock && rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;\n                else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;\n                sawBlock = true;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for(let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;){\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for(let j = 0; j < rects.length; j++){\n                    let rect = rects[j];\n                    if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI) break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret) ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box)) return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt) return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for(let p = elt; node && p; p = parentNode(p))if (p.draggable) node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top) offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top) offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\") pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null) pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return {\n        pos,\n        inside: desc ? desc.posAtStart - desc.border : -1\n    };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first)) return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        } else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            } else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            } else if (side < 0) {\n                from--;\n            } else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target) return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while(after.pmViewDesc && after.pmViewDesc.ignoreForCoords)after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n        if (target) return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0) return rect;\n    let x = left ? rect.left : rect.right;\n    return {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: x,\n        right: x\n    };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0) return rect;\n    let y = top ? rect.top : rect.bottom;\n    return {\n        top: y,\n        bottom: y,\n        left: rect.left,\n        right: rect.right\n    };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state) view.updateState(state);\n    if (active != view.dom) view.focus();\n    try {\n        return f();\n    } finally{\n        if (viewState != state) view.updateState(viewState);\n        if (active != view.dom && active) active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, ()=>{\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for(;;){\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest) break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for(let child = dom.firstChild; child; child = child.nextSibling){\n            let boxes;\n            if (child.nodeType == 1) boxes = child.getClientRects();\n            else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else continue;\n            for(let i = 0; i < boxes.length; i++){\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock) return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, ()=>{\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);\n        } catch (_) {}\n        if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir) return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM){\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n        return false;\n    }\n    matchesMark(mark) {\n        return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return false;\n    }\n    matchesHack(nodeName) {\n        return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n        return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n        return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for(let i = 0; i < this.children.length; i++)size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n        return 0;\n    }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;\n        for(let i = 0; i < this.children.length; i++)this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for(let i = 0, pos = this.posAtStart;; i++){\n            let cur = this.children[i];\n            if (cur == child) return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while(domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            } else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while(domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        } else if (this.dom.firstChild) {\n            if (offset == 0) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = false;\n                    break;\n                }\n                if (search.previousSibling) break;\n            }\n            if (atEnd == null && offset == dom.childNodes.length) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = true;\n                    break;\n                }\n                if (search.nextSibling) break;\n            }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for(let first = true, cur = dom; cur; cur = cur.parentNode){\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;\n                else return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for(let cur = desc; cur; cur = cur.parent)if (cur == this) return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for(let scan = dom; scan; scan = scan.parentNode){\n            let desc = this.getDesc(scan);\n            if (desc) return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while(!child.border && child.children.length)child = child.children[0];\n                return child;\n            }\n            if (pos < end) return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM) return {\n            node: this.dom,\n            offset: 0,\n            atom: pos + 1\n        };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for(let curPos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for(let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--){}\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for(;; i--, enter = false){\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM) break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom) return prev.domFromPos(prev.size, side);\n            return {\n                node: this.contentDOM,\n                offset: prev ? domIndex(prev.dom) + 1 : 0\n            };\n        } else {\n            let next, enter = true;\n            for(;; i++, enter = false){\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM) break;\n            }\n            if (next && enter && !next.border && !next.domAtom) return next.domFromPos(0, side);\n            return {\n                node: this.contentDOM,\n                offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length\n            };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0) return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset: 0,\n            toOffset: this.contentDOM.childNodes.length\n        };\n        let fromOffset = -1, toOffset = -1;\n        for(let offset = base, i = 0;; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);\n                from = offset;\n                for(let j = i; j > 0; j--){\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1) fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for(let j = i + 1; j < this.children.length; j++){\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset,\n            toOffset\n        };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length) return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, root, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = root.getSelection();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for(let scan = node, after; scan; scan = scan.parentNode){\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\") anchorDOM = headDOM = {\n                                node: after.parentNode,\n                                offset: domIndex(after) + 1\n                            };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock) break;\n                    }\n                }\n            } else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n            let after = domSel.focusNode.childNodes[domSel.focusOffset];\n            if (after && after.contentEditable == \"false\") force = true;\n        }\n        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !brKludge) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            } catch (_) {\n            // In some cases with Chrome the selection is empty after calling\n            // collapse, even when it should be valid. This appears to be a bug, but\n            // it is difficult to isolate. If this happens fallback to the old path\n            // without using extend.\n            // Similarly, this could crash on Safari if the editor is hidden, and\n            // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for(let offset = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;\n                    else child.markDirty(from - startInside, to - startInside);\n                    return;\n                } else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for(let node = this.parent; node; node = node.parent, level++){\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty) node.dirty = dirty;\n        }\n    }\n    get domAtom() {\n        return false;\n    }\n    get ignoreForCoords() {\n        return false;\n    }\n    isText(text) {\n        return false;\n    }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos){\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\") dom = dom(view, ()=>{\n            if (!self) return pos;\n            if (self.parent) return self.parent.posBeforeChild(self);\n        });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() {\n        return true;\n    }\n    get side() {\n        return this.widget.type.side;\n    }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text){\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() {\n        return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.textDOM,\n            offset: pos\n        };\n    }\n    ignoreMutation(mut) {\n        return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM){\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom) spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);\n    }\n    parseRule() {\n        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;\n        return {\n            mark: this.mark.type.name,\n            attrs: this.mark.attrs,\n            contentElement: this.contentDOM\n        };\n    }\n    matchesMark(mark) {\n        return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while(!parent.node)parent = parent.parent;\n            if (parent.dirty < this.dirty) parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size) nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0) nodes = replaceNodes(nodes, 0, from, view);\n        for(let i = 0; i < nodes.length; i++)nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos){\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, ()=>{\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj) return pos;\n            if (descObj.parent) return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom) dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\");\n        } else if (!dom) {\n            ({ dom, contentDOM } = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n            if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = \"false\";\n            if (node.type.spec.draggable) dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView) return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = {\n            node: this.node.type.name,\n            attrs: this.node.attrs\n        };\n        if (this.node.type.whitespace == \"pre\") rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = ()=>this.node.content;\n        } else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        } else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for(let i = this.children.length - 1; i >= 0; i--){\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement) rule.getContent = ()=>prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get border() {\n        return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode)=>{\n            if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i)=>{\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock) updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition) this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios) iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size) return null;\n        let textNode = view.input.compositionNode;\n        if (!textNode || !this.dom.contains(textNode.parentNode)) return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : {\n                node: textNode,\n                pos: textPos,\n                text\n            };\n        } else {\n            return {\n                node: textNode,\n                pos: -1,\n                text: \"\"\n            };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node)) return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for(;; topNode = topNode.parentNode){\n            if (topNode.parentNode == this.contentDOM) break;\n            while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);\n            while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM) this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco)) return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\");\n        }\n    }\n    get domAtom() {\n        return this.node.isAtom;\n    }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM) docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view){\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while(skip && skip != this.dom && !skip.pmIsDeco)skip = skip.parentNode;\n        return {\n            skip: skip || true\n        };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM) view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for(let n = this.nodeDOM; n; n = n.parentNode)if (n == parentDOM) return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.nodeDOM,\n            offset: pos\n        };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n        return false;\n    }\n    isText(text) {\n        return this.node.text == text;\n    }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    matchesHack(nodeName) {\n        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForCoords() {\n        return this.dom.nodeName == \"IMG\";\n    }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos){\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY) return false;\n        if (this.spec.update) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result) this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        } else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        } else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, root, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for(let i = 0; i < descs.length; i++){\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while(childDOM != dom){\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        } else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while(dom){\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM) view.trackWrites = null;\n}\nconst OuterDecoLevel = function(nodeName) {\n    if (nodeName) this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [\n    new OuterDecoLevel\n];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0) return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [\n        top\n    ];\n    for(let i = 0; i < outerDeco.length; i++){\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs) continue;\n        if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for(let name in attrs){\n            let val = attrs[name];\n            if (val == null) continue;\n            if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\") top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;\n    let curDOM = nodeDOM;\n    for(let i = 0; i < curComputed.length; i++){\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            } else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for(let name in prev)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur)) dom.removeAttribute(name);\n    for(let name in cur)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name]) dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for(let i = 0; i < prevList.length; i++)if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);\n        for(let i = 0; i < curList.length; i++)if (prevList.indexOf(curList[i]) == -1) dom.classList.add(curList[i]);\n        if (dom.classList.length == 0) dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while(m = prop.exec(prev.style))dom.style.removeProperty(m[1]);\n        }\n        if (cur.style) dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].type.eq(b[i].type)) return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view){\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end) return;\n        for(let i = start; i < end; i++)this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while(keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)keep++;\n        while(keep < depth){\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while(depth < marks.length){\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for(let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++){\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            } else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        } else {\n            for(let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++){\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0) return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view)) return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for(;;){\n            let parent = domNode.parentNode;\n            if (!parent) return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc) for(let i = this.index; i < this.top.children.length; i++){\n                    if (this.top.children[i] == desc) return i;\n                }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for(let i = this.index; i < this.top.children.length; i++){\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index) return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM) this.changed = true;\n                    this.index++;\n                    return true;\n                } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content)) return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM) desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        } else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while(lastChild instanceof MarkViewDesc){\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\") this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        } else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\") dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top) parent.children.push(hack);\n            else parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while(fI > 0){\n        let desc;\n        for(;;){\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                } else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            } else if (curDesc == parentDesc) {\n                break outer;\n            } else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node) continue;\n        if (node != frag.child(fI - 1)) break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return {\n        index: fI,\n        matched,\n        matches: matches.reverse()\n    };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for(let i = 0; i < parent.childCount; i++){\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for(let parentIndex = 0;;){\n        let widget, widgets;\n        while(decoIndex < locals.length && locals[decoIndex].to == offset){\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget) widget = next;\n                else (widgets || (widgets = [\n                    widget\n                ])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for(let i = 0; i < widgets.length; i++)onWidget(widgets[i], parentIndex, !!restNode);\n            } else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        } else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        } else {\n            break;\n        }\n        for(let i = 0; i < active.length; i++)if (active[i].to <= offset) active.splice(i--, 1);\n        while(decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;\n            for(let i = 0; i < active.length; i++)if (active[i].to < cutAt) cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        } else {\n            while(decoIndex < locals.length && locals[decoIndex].to < end)decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d)=>!d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for(let i = 0, pos = 0; i < frag.childCount && pos <= to;){\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText) continue;\n        let str = child.text;\n        while(i < frag.childCount){\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText) break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from) return childStart + found;\n            if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for(let i = 0, off = 0; i < nodes.length; i++){\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        } else {\n            if (start < from) result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to) result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode) return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0) return null;\n    let $head = doc.resolve(head), $anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        $anchor = $head;\n        while(nearestDesc && !nearestDesc.node)nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    } else {\n        let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        if (anchor < 0) return null;\n        $anchor = doc.resolve(anchor);\n    }\n    if (!selection) {\n        let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view)) return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    } else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view.root, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom) resetEditable(resetEditableFrom);\n            if (resetEditableTo) resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        } else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document) removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\") return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n        if (after) return setEditable(after);\n        else if (before) return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = ()=>{\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(()=>{\n                if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection(), range = document.createRange();\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img) range.setEnd(node.parentNode, domIndex(node) + 1);\n    else range.setEnd(node, 0);\n    range.collapse(false);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc) desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    } else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f)=>f(view, $anchor, $head)) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus()) return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf) return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        } else if (!sel.empty) {\n            return false;\n        } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n            return false;\n        } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText) return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            } else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            } else {\n                return false;\n            }\n        }\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next) return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;\n    for(;;){\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            } else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                } else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                } else break;\n            }\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let prev = node.previousSibling;\n            while(prev && isIgnorable(prev, -1)){\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = 0;\n            } else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force) setSelFocus(view, node, offset);\n    else if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for(;;){\n        if (offset < len) {\n            if (node.nodeType != 1) break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            } else break;\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let next = node.nextSibling;\n            while(next && isIgnorable(next, 1)){\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = len = 0;\n            } else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while(node && offset == node.childNodes.length && !hasBlockDesc(node)){\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while(node && offset < node.childNodes.length){\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while(node && !offset && !hasBlockDesc(node)){\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while(node && offset){\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        } else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    } else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(()=>{\n        if (view.state == state) selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false;\n    if (mac && mods.indexOf(\"m\") > -1) return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor)) return true;\n    if (!empty) return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0) return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(()=>switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey) result += \"c\";\n    if (event.metaKey) result += \"m\";\n    if (event.altKey) result += \"a\";\n    if (event.shiftKey) result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n        return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n        let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n        let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n        return true;\n    }\n    return false;\n}\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", (f)=>{\n        slice = f(slice, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice;\n    while(openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1){\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, {\n        document: doc\n    }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while(firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])){\n        for(let i = needsWrap.length - 1; i >= 0; i--){\n            let wrapper = doc.createElement(needsWrap[i]);\n            while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", (f)=>f(slice, view)) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return {\n        dom: wrap,\n        text,\n        slice\n    };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text) return null;\n    let asText = text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", (f)=>{\n            text = f(text, inCode || plainText, view);\n        });\n        if (inCode) return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n        let parsed = view.someProp(\"clipboardTextParser\", (f)=>f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        } else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach((block)=>{\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    } else {\n        view.someProp(\"transformPastedHTML\", (f)=>{\n            html = f(html, view);\n        });\n        dom = readHTML(html);\n        if (webkit) restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3]) for(let i = +sliceData[3]; i > 0; i--){\n        let child = dom.firstChild;\n        while(child && child.nodeType != 1)child = child.nextSibling;\n        if (!child) break;\n        dom = child;\n    }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode (dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {\n                    ignore: true\n                };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for(let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild){}\n            for(let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild){}\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", (f)=>{\n        slice = f(slice, view);\n    });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2) return fragment;\n    for(let d = $context.depth; d >= 0; d--){\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach((node)=>{\n            if (!result) return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap) return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            } else {\n                if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result) return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for(let i = wrap.length - 1; i >= from; i--)node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0) return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1) openEnd = 0;\n    if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\n        \"table\"\n    ],\n    tbody: [\n        \"table\"\n    ],\n    tfoot: [\n        \"table\"\n    ],\n    caption: [\n        \"table\"\n    ],\n    colgroup: [\n        \"table\"\n    ],\n    col: [\n        \"table\",\n        \"colgroup\"\n    ],\n    tr: [\n        \"table\",\n        \"tbody\"\n    ],\n    td: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ],\n    th: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas) html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map((n)=>\"<\" + n + \">\").join(\"\") + html + wrap.map((n)=>\"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = html;\n    if (wrap) for(let i = 0; i < wrap.length; i++)elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for(let i = 0; i < nodes.length; i++){\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\xa0\" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size) return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    } catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for(let i = array.length - 2; i >= 0; i -= 2){\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs()) break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = {\n    touchstart: true,\n    touchmove: true\n};\nclass InputState {\n    constructor(){\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = {\n            time: 0,\n            x: 0,\n            y: 0,\n            type: \"\"\n        };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastAndroidDelete = 0;\n        this.composing = false;\n        this.compositionNode = null;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for(let event in handlers){\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event)=>{\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);\n        }, passiveHandlers[event] ? {\n            passive: true\n        } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari) view.dom.addEventListener(\"input\", ()=>null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for(let type in view.input.eventHandlers)view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers)=>{\n        for(let type in currentHandlers)if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = (event)=>runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers)=>{\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target; node != view.dom; node = node.parentNode)if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event)) return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13) return;\n    if (event.keyCode != 229) view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(()=>{\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f)=>f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event)=>{\n    if (event.keyCode == 16) view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event)=>{\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;\n    if (view.someProp(\"handleKeyPress\", (f)=>f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f)=>f(view, sel.$from.pos, sel.$to.pos, text))) view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) {\n    return {\n        left: event.clientX,\n        top: event.clientY\n    };\n}\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        if (view.someProp(propName, (f)=>i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false))) return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused) view.focus();\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1) return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);\n            else selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f)=>f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f)=>f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f)=>f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0) return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n        if (view.input.lastClick.type == \"singleClick\") type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\") type = \"tripleClick\";\n    }\n    view.input.lastClick = {\n        time: now,\n        x: event.clientX,\n        y: event.clientY,\n        type\n    };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos) return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown) view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed){\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        } else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;\n        let { selection } = view.state;\n        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {\n            node: targetNode,\n            pos: targetPos,\n            addAttr: !!(this.target && !this.target.draggable),\n            setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.draggable = true;\n            if (this.mightDrag.setUneditable) setTimeout(()=>{\n                if (this.view.input.mouseDown == this) this.target.setAttribute(\"contentEditable\", \"false\");\n            }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync) setTimeout(()=>selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target)) return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n        // cursor, but still report that the node is selected\n        // when asked through getSelection. You'll then get a\n        // situation where clicking at the point where that\n        // (hidden) cursor is doesn't change the selection, and\n        // thus doesn't get a reaction from ProseMirror. This\n        // works around that.\n        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        } else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0) this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;\n    }\n}\nhandlers.touchstart = (view)=>{\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view)=>{\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view)=>forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view)=>{\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$from;\n        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m)=>m.type.spec.inclusive === false))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        } else {\n            endComposition(view);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for(let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;){\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before) break;\n                    if (before.nodeType == 3) {\n                        view.domSelection().collapse(before, before.nodeValue.length);\n                        break;\n                    } else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event)=>{\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        view.input.compositionNode = null;\n        if (view.input.compositionPendingChanges) Promise.resolve().then(()=>view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1) view.input.composingTimeout = setTimeout(()=>endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while(view.input.compositionNodes.length > 0)view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n        if (textBefore == lastChanged || textAfter == lastChanged) return lastChanged;\n        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n            return textAfter;\n        } else if (view.input.compositionNode == textAfter) {\n            let descBefore = textBefore.pmViewDesc;\n            if (!(!descBefore || !descBefore.isText(textBefore.nodeValue))) return textAfter;\n        }\n    }\n    return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/ function endComposition(view, forceUpdate = false) {\n    if (android && view.domObserver.flushingSoon >= 0) return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (forceUpdate || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view);\n        if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));\n        else view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode) return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(()=>{\n        if (wrap.parentNode) wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event)=>{\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty) return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    } else {\n        captureCopy(view, dom);\n    }\n    if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode) return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText) target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(()=>{\n        view.focus();\n        if (target.parentNode) target.parentNode.removeChild(target);\n        if (plainText) doPaste(view, target.value, null, plain, event);\n        else doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty))) return true;\n    if (!slice) return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text) return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event)=>{\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android) return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event)) event.preventDefault();\n    else capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node){\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nhandlers.dragstart = (view, _event)=>{\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown) mouseDown.done();\n    if (!event.dataTransfer) return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n    event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI) event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, !event[dragCopyModifier], node);\n};\nhandlers.dragend = (view)=>{\n    let dragging = view.dragging;\n    window.setTimeout(()=>{\n        if (view.dragging == dragging) view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e)=>e.preventDefault();\neditHandlers.drop = (view, _event)=>{\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer) return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos) return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", (f)=>{\n            slice = f(slice, view);\n        });\n    } else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && !event[dragCopyModifier]);\n    if (view.someProp(\"handleDrop\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice) return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null) insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node) node.replace(tr);\n        else tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert)) return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    } else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo)=>end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\nhandlers.focus = (view)=>{\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(()=>{\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event)=>{\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event)=>{\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(()=>{\n            if (view.input.domChangeCount != domChangeCount) return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor(let prop in editHandlers)handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n    if (a == b) return true;\n    for(let p in a)if (a[p] !== b[p]) return false;\n    for(let p in b)if (!(p in a)) return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec){\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n        return true;\n    }\n    eq(other) {\n        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n        if (this.spec.destroy) this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) {\n        return span.from < span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n        return span.type instanceof InlineType;\n    }\n    destroy() {}\n}\nclass NodeType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted) return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos) return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {}\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variantssee the static members of this class for details.\n*/ class Decoration {\n    /**\n    @internal\n    */ constructor(/**\n    The start position of the decoration.\n    */ from, /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */ to, /**\n    @internal\n    */ type){\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */ copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */ eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */ map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */ static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */ static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */ static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */ get spec() {\n        return this.type.spec;\n    }\n    /**\n    @internal\n    */ get inline() {\n        return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */ get widget() {\n        return this.type instanceof WidgetType;\n    }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structureit is not modified,\nupdates create a new value.\n*/ class DecorationSet {\n    /**\n    @internal\n    */ constructor(local, children){\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */ static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */ find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for(let i = 0; i < this.local.length; i++){\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for(let i = 0; i < this.children.length; i += 3){\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */ map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0) return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */ mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for(let i = 0; i < this.local.length; i++){\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove) options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */ add(doc, decorations) {\n        if (!decorations.length) return this;\n        if (this == empty) return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset)=>{\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;\n            if (!children) children = this.children.slice();\n            while(childIndex < children.length && children[childIndex] < childOffset)childIndex += 3;\n            if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for(let i = 0; i < local.length; i++)if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */ remove(decorations) {\n        if (decorations.length == 0 || this == empty) return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for(let i = 0; i < children.length; i += 3){\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for(let j = 0, span; j < decorations.length; j++)if (span = decorations[j]) {\n                if (span.from > from && span.to < to) {\n                    decorations[j] = null;\n                    (found || (found = [])).push(span);\n                }\n            }\n            if (!found) continue;\n            if (children == this.children) children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            } else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length) {\n            for(let i = 0, span; i < decorations.length; i++)if (span = decorations[i]) {\n                for(let j = 0; j < local.length; j++)if (local[j].eq(span, offset)) {\n                    if (local == this.local) local = this.local.slice();\n                    local.splice(j--, 1);\n                }\n            }\n        }\n        if (children == this.children && local == this.local) return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n        if (this == empty) return this;\n        if (node.isLeaf) return DecorationSet.empty;\n        let child, local;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] >= offset) {\n            if (this.children[i] == offset) child = this.children[i + 2];\n            break;\n        }\n        let start = offset + 1, end = start + node.content.size;\n        for(let i = 0; i < this.local.length; i++){\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to) (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([\n                localSet,\n                child\n            ]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */ eq(other) {\n        if (this == other) return true;\n        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;\n        for(let i = 0; i < this.local.length; i++)if (!this.local[i].eq(other.local[i])) return false;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2])) return false;\n        return true;\n    }\n    /**\n    @internal\n    */ locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */ localsInner(node) {\n        if (this == empty) return none;\n        if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;\n        let result = [];\n        for(let i = 0; i < this.local.length; i++){\n            if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);\n        }\n        return result;\n    }\n}\n/**\nThe empty set of decorations.\n*/ DecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/ DecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members){\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map((member)=>member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf) return DecorationSet.empty;\n        let found = [];\n        for(let i = 0; i < this.members.length; i++){\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty) continue;\n            if (result instanceof DecorationGroup) found = found.concat(result.members);\n            else found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;\n        for(let i = 0; i < this.members.length; i++)if (!this.members[i].eq(other.members[i])) return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for(let i = 0; i < this.members.length; i++){\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length) continue;\n            if (!result) {\n                result = locals;\n            } else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for(let j = 0; j < locals.length; j++)result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch(members.length){\n            case 0:\n                return empty;\n            case 1:\n                return members[0];\n            default:\n                return new DecorationGroup(members.every((m)=>m instanceof DecorationSet) ? members : members.reduce((r, m)=>r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for(let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++){\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd)=>{\n            let dSize = newEnd - newStart - (oldEnd - oldStart);\n            for(let i = 0; i < children.length; i += 3){\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved) continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                } else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n            mustRebuild = true;\n            children[i + 1] = -1;\n            continue;\n        }\n        let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n            mustRebuild = true;\n            continue;\n        }\n        // Must read oldChildren because children was tagged with -1\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n            let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n            if (mapped != empty) {\n                children[i] = fromLocal;\n                children[i + 1] = toLocal;\n                children[i + 2] = mapped;\n            } else {\n                children[i + 1] = -2;\n                mustRebuild = true;\n            }\n        } else {\n            mustRebuild = true;\n        }\n    }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n            children.splice(i, 3);\n            i -= 3;\n        }\n        for(let i = 0, j = 0; i < built.children.length; i += 3){\n            let from = built.children[i];\n            while(j < children.length && children[j] < from)j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length) return spans;\n    let result = [];\n    for(let i = 0; i < spans.length; i++){\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for(let i = 0; i < set.local.length; i++){\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped) decorations.push(mapped);\n            else if (options.onRemove) options.onRemove(set.local[i].spec);\n        }\n        for(let i = 0; i < set.children.length; i += 3)gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf) return null;\n    let end = offset + node.nodeSize, found = null;\n    for(let i = 0, span; i < spans.length; i++){\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for(let i = 0; i < array.length; i++)if (array[i] != null) result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart)=>{\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for(let i = 0; i < locals.length; i++)if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove) options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n    }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for(let i = 0; i < working.length - 1; i++){\n        let span = working[i];\n        if (span.from != span.to) for(let j = i + 1; j < working.length; j++){\n            let next = working[j];\n            if (next.from == span.from) {\n                if (next.to != span.to) {\n                    if (working == spans) working = spans.slice();\n                    // Followed by a partially overlapping larger span. Split that\n                    // span.\n                    working[j] = next.copy(next.from, span.to);\n                    insertAhead(working, j + 1, next.copy(span.to, next.to));\n                }\n                continue;\n            } else {\n                if (next.from < span.to) {\n                    if (working == spans) working = spans.slice();\n                    // The end of this one overlaps with a subsequent span. Split\n                    // this one.\n                    working[i] = span.copy(span.from, next.from);\n                    insertAhead(working, j, span.copy(next.from, span.to));\n                }\n                break;\n            }\n        }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while(i < array.length && byPos(deco, array[i]) > 0)i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", (f)=>{\n        let result = f(view.state);\n        if (result && result != empty) found.push(result);\n    });\n    if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [\n        view.cursorWrapper.deco\n    ]));\n    return DecorationGroup.from(found);\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange){\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.lastChangedTextNode = null;\n        this.observer = window.MutationObserver && new window.MutationObserver((mutations)=>{\n            for(let i = 0; i < mutations.length; i++)this.queue.push(mutations[i]);\n            // IE11 will sometimes (on backspacing out a single character\n            // text node after a BR node) call the observer callback\n            // before actually updating the DOM, which will cause\n            // ProseMirror to miss the change (see #930)\n            if (ie && ie_version <= 11 && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) {\n            this.onCharData = (e)=>{\n                this.queue.push({\n                    target: e.target,\n                    type: \"characterData\",\n                    oldValue: e.prevValue\n                });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(()=>{\n            this.flushingSoon = -1;\n            this.flush();\n        }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData) this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for(let i = 0; i < take.length; i++)this.queue.push(take[i]);\n                window.setTimeout(()=>this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(()=>this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view)) return;\n        if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode) return true;\n        let ancestors = new Set, container;\n        for(let scan = sel.focusNode; scan; scan = parentNode(scan))ancestors.add(scan);\n        for(let scan = sel.anchorNode; scan; scan = parentNode(scan))if (ancestors.has(scan)) {\n            container = scan;\n            break;\n        }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer) for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1) return;\n        let mutations = this.pendingRecords();\n        if (mutations.length) this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for(let i = 0; i < mutations.length; i++){\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver) typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length) {\n            let brs = added.filter((n)=>n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let [a, b] = brs;\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();\n                else a.remove();\n            } else {\n                let { focusNode } = this.currentSelection;\n                for (let br of brs){\n                    let parent = br.parentNode;\n                    if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent)) br.remove();\n                }\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        } else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty) view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel)) selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1) return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n        mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))) return null;\n        if (!desc || desc.ignoreMutation(mut)) return null;\n        if (mut.type == \"childList\") {\n            for(let i = 0; i < mut.addedNodes.length; i++){\n                let node = mut.addedNodes[i];\n                added.push(node);\n                if (node.nodeType == 3) this.lastChangedTextNode = node;\n            }\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {\n                from: desc.posBefore,\n                to: desc.posAfter\n            };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for(let i = 0; i < mut.addedNodes.length; i++){\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return {\n                from,\n                to\n            };\n        } else if (mut.type == \"attributes\") {\n            return {\n                from: desc.posAtStart - desc.border,\n                to: desc.posAtEnd + desc.border\n            };\n        } else {\n            this.lastChangedTextNode = mut.target;\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view)) return;\n    cssChecked.set(view, null);\n    if ([\n        \"normal\",\n        \"nowrap\",\n        \"pre-line\"\n    ].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned) return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\nfunction rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return rangeToSelectionRange(view, range);\n    }\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found ? rangeToSelectionRange(view, found) : null;\n}\nfunction blockParent(view, node) {\n    for(let p = node.parentNode; p && p != view.dom; p = p.parentNode){\n        let desc = view.docView.nearestDesc(p, true);\n        if (desc && desc.node.isBlock) return p;\n    }\n    return null;\n}\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [\n            {\n                node: anchor,\n                offset: domSel.anchorOffset\n            }\n        ];\n        if (!selectionCollapsed(domSel)) find.push({\n            node: domSel.focusNode,\n            offset: domSel.focusOffset\n        });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for(let off = toOffset; off > fromOffset; off--){\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size) break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null) head = anchor;\n        sel = {\n            anchor: anchor + from,\n            head: head + from\n        };\n    }\n    return {\n        doc,\n        sel,\n        from,\n        to\n    };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return {\n                skip\n            };\n        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return {\n                ignore: true\n            };\n        }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return {\n            ignore: true\n        };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\") tr.scrollIntoView();\n            if (compositionID) tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    } else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n)=>n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = {\n                start: sel.from,\n                endA: sel.to,\n                endB: sel.to\n            };\n        } else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID) tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    view.input.domChangeCount++;\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n            change.endB += view.state.selection.to - change.endA;\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xa0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    let nextSel;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n)=>n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome) view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome Android will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(()=>{\n            view.someProp(\"handleKeyDown\", function(f) {\n                return f(view, keyEvent(13, \"Enter\"));\n            });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let tr, storedMarks, markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) {\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(()=>selectionToDOM(view), 20);\n            }\n            tr = view.state.tr.delete(chFrom, chTo);\n            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            tr = view.state.tr;\n            if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark);\n            else tr.removeMark(chFrom, chTo, markChange.mark);\n        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            if (view.someProp(\"handleTextInput\", (f)=>f(view, chFrom, chTo, text))) return;\n            tr = view.state.tr.insertText(text, chFrom, chTo);\n        }\n    }\n    if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n    if (parse.sel) {\n        let sel = resolveSelection(view, tr.doc, parse.sel);\n        // Chrome Android will sometimes, during composition, report the\n        // selection in the wrong place. If it looks like that is\n        // happening, don't update the selection.\n        // Edge just doesn't move the cursor forward when you start typing\n        // in an empty block or between br nodes.\n        if (sel && !(chrome && android && view.composing && sel.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) || ie && sel.empty && sel.head == chFrom)) tr.setSelection(sel);\n    }\n    if (storedMarks) tr.ensureMarks(storedMarks);\n    if (compositionID) tr.setMeta(\"composition\", compositionID);\n    view.dispatch(tr.scrollIntoView());\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for(let i = 0; i < prevMarks.length; i++)added = prevMarks[i].removeFromSet(added);\n    for(let i = 0; i < curMarks.length; i++)removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node)=>node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node)=>node.mark(mark.removeFromSet(node.marks));\n    } else {\n        return null;\n    }\n    let updated = [];\n    for(let i = 0; i < prev.childCount; i++)updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur)) return {\n        mark,\n        type\n    };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if (end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n    skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;\n    let $start = old.resolve(start);\n    // Handle the case where, rather than joining blocks, the change just removed an entire block\n    if (!$newStart.parent.isTextblock) {\n        let after = $start.nodeAfter;\n        return after != null && end == start + after.nodeSize;\n    }\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while(depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)){\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while(next && !next.isLeaf){\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null) return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    } else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return {\n        start,\n        endA,\n        endB\n    };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2) return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n/**\n@internal\n*/ const __serializeForClipboard = serializeForClipboard;\n/**\n@internal\n*/ const __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/ const __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/ class EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */ constructor(place, props){\n        this._root = null;\n        /**\n        @internal\n        */ this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */ this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */ this.markCursor = null;\n        /**\n        @internal\n        */ this.cursorWrapper = null;\n        /**\n        @internal\n        */ this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */ this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */ this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */ this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = place && place.mount || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild) place.appendChild(this.dom);\n            else if (typeof place == \"function\") place(this.dom);\n            else if (place.mount) this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added)=>readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */ get composing() {\n        return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */ get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for(let name in prev)this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */ update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */ setProps(props) {\n        let updated = {};\n        for(let name in this._props)updated[name] = this._props[name];\n        updated.state = this.state;\n        for(let name in props)updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */ updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n                if (this.composing) this.input.compositionNode = findCompositionNode(this);\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco(outerDeco);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites) forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            } else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        } else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        } else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */ scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (this.someProp(\"handleScrollToSelection\", (f)=>f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        } else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while(view = this.pluginViews.pop())if (view.destroy) view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for(let i = 0; i < this.directPlugins.length; i++){\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n            for(let i = 0; i < this.state.plugins.length; i++){\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n        } else {\n            for(let i = 0; i < this.pluginViews.length; i++){\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update) pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        } else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node) found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop)) return value;\n        for(let i = 0; i < this.directPlugins.length; i++){\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins) for(let i = 0; i < plugins.length; i++){\n            let prop = plugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */ hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom) return true;\n            if (!node || !this.dom.contains(node)) return false;\n            while(node && this.dom != node && this.dom.contains(node)){\n                if (node.contentEditable == \"false\") return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */ focus() {\n        this.domObserver.stop();\n        if (this.editable) focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */ get root() {\n        let cached = this._root;\n        if (cached == null) for(let search = this.dom.parentNode; search; search = search.parentNode){\n            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n                if (!search.getSelection) Object.getPrototypeOf(search).getSelection = ()=>search.ownerDocument.getSelection();\n                return this._root = search;\n            }\n        }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */ updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */ posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */ coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */ domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */ nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimesfor example when interpreting an event\n    targetyou don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */ posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null) throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */ endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */ pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */ pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */ destroy() {\n        if (!this.docView) return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        } else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n        clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */ get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */ dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    Dispatch a transaction. Will call\n    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)\n    when given, and otherwise defaults to applying the transaction to\n    the current state and calling\n    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.\n    This method is bound to the view instance, so that it can be\n    easily passed around.\n    */ dispatch(tr) {\n        let dispatchTransaction = this._props.dispatchTransaction;\n        if (dispatchTransaction) dispatchTransaction.call(this, tr);\n        else this.updateState(this.state.apply(tr));\n    }\n    /**\n    @internal\n    */ domSelectionRange() {\n        let sel = this.domSelection();\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */ domSelection() {\n        return this.root.getSelection();\n    }\n}\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value)=>{\n        if (typeof value == \"function\") value = value(view.state);\n        if (value) for(let attr in value){\n            if (attr == \"class\") attrs.class += \" \" + value[attr];\n            else if (attr == \"style\") attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n            else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\") attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate) attrs.translate = \"no\";\n    return [\n        Decoration.node(0, view.state.doc.content.size, attrs)\n    ];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = {\n            dom,\n            deco: Decoration.widget(view.state.selection.head, dom, {\n                raw: true,\n                marks: view.markCursor\n            })\n        };\n    } else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", (value)=>value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for(let prop in obj)if (!Object.prototype.hasOwnProperty.call(result, prop)) result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for(let prop in a){\n        if (a[prop] != b[prop]) return true;\n        nA++;\n    }\n    for(let _ in b)nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRjtBQUNOO0FBQ2xDO0FBRWxELE1BQU1VLFdBQVcsU0FBVUMsSUFBSTtJQUMzQixJQUFLLElBQUlDLFFBQVEsSUFBSUEsUUFBUztRQUMxQkQsT0FBT0EsS0FBS0UsZUFBZTtRQUMzQixJQUFJLENBQUNGLE1BQ0QsT0FBT0M7SUFDZjtBQUNKO0FBQ0EsTUFBTUUsYUFBYSxTQUFVSCxJQUFJO0lBQzdCLElBQUlJLFNBQVNKLEtBQUtLLFlBQVksSUFBSUwsS0FBS0csVUFBVTtJQUNqRCxPQUFPQyxVQUFVQSxPQUFPRSxRQUFRLElBQUksS0FBS0YsT0FBT0csSUFBSSxHQUFHSDtBQUMzRDtBQUNBLElBQUlJLGNBQWM7QUFDbEIsc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSw0QkFBNEI7QUFDNUIsTUFBTUMsWUFBWSxTQUFVVCxJQUFJLEVBQUVVLElBQUksRUFBRUMsRUFBRTtJQUN0QyxJQUFJQyxRQUFRSixlQUFnQkEsQ0FBQUEsY0FBY0ssU0FBU0MsV0FBVyxFQUFDO0lBQy9ERixNQUFNRyxNQUFNLENBQUNmLE1BQU1XLE1BQU0sT0FBT1gsS0FBS2dCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHTjtJQUN4REMsTUFBTU0sUUFBUSxDQUFDbEIsTUFBTVUsUUFBUTtJQUM3QixPQUFPRTtBQUNYO0FBQ0EsTUFBTU8sbUJBQW1CO0lBQ3JCWCxjQUFjO0FBQ2xCO0FBQ0EscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSw2Q0FBNkM7QUFDN0MsTUFBTVksdUJBQXVCLFNBQVVwQixJQUFJLEVBQUVxQixHQUFHLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUNuRSxPQUFPRCxjQUFlRSxDQUFBQSxRQUFReEIsTUFBTXFCLEtBQUtDLFlBQVlDLFdBQVcsQ0FBQyxNQUM3REMsUUFBUXhCLE1BQU1xQixLQUFLQyxZQUFZQyxXQUFXLEVBQUM7QUFD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QzB2QixpQkFBaUIsRUFDbkYsTUFBTSxJQUFJbnhCLFdBQVc7QUFDN0I7QUFFa0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzPzRlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uLCBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgU2xpY2UsIERPTVBhcnNlciB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGRvbUluZGV4ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn07XG5jb25zdCBwYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExID8gcGFyZW50Lmhvc3QgOiBwYXJlbnQ7XG59O1xubGV0IHJldXNlZFJhbmdlID0gbnVsbDtcbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByYW5nZSwgYmVjYXVzZSBET00gcmFuZ2Vcbi8vIG9iamVjdHMgYXJlIGV2ZXJ5IGV4cGVuc2l2ZSwgYW5kIGtlZXAgc2xvd2luZyBkb3duIHN1YnNlcXVlbnQgRE9NXG4vLyB1cGRhdGVzLCBmb3Igc29tZSByZWFzb24uXG5jb25zdCB0ZXh0UmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgcmFuZ2UgPSByZXVzZWRSYW5nZSB8fCAocmV1c2VkUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8gPT0gbnVsbCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICAgIHJldHVybiByYW5nZTtcbn07XG5jb25zdCBjbGVhclJldXNlZFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldXNlZFJhbmdlID0gbnVsbDtcbn07XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5jb25zdCBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpO1xufTtcbmNvbnN0IGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlJDEobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZVNpemUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlciQxKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgICBmb3IgKGxldCBhdFN0YXJ0ID0gb2Zmc2V0ID09IDAsIGF0RW5kID0gb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpOyBhdFN0YXJ0IHx8IGF0RW5kOykge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICAgICAgYXRFbmQgPSBhdEVuZCAmJiBpbmRleCA9PSBub2RlU2l6ZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNCbG9ja0Rlc2MoZG9tKSB7XG4gICAgbGV0IGRlc2M7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrICYmIChkZXNjLmRvbSA9PSBkb20gfHwgZGVzYy5jb250ZW50RE9NID09IGRvbSk7XG59XG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxuY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gZnVuY3Rpb24gKGRvbVNlbCkge1xuICAgIHJldHVybiBkb21TZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufTtcbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwia2V5ZG93blwiLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgICBldmVudC5rZXkgPSBldmVudC5jb2RlID0ga2V5O1xuICAgIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcG9zLm9mZnNldE5vZGUsIG9mZnNldDogcG9zLm9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICB9XG4gICAgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCB9O1xuICAgIH1cbn1cblxuY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgYWdlbnQgPSAobmF2ICYmIG5hdi51c2VyQWdlbnQpIHx8IFwiXCI7XG5jb25zdCBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy5leGVjKGFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGllX3ZlcnNpb24gPSBpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuY29uc3QgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICEhX2Nocm9tZTtcbmNvbnN0IGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAhIW5hdiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG4vLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCkgfHwgISFuYXYgJiYgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbmNvbnN0IHdpbmRvd3MgPSBuYXYgPyAvV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZTtcbmNvbnN0IGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gISFkb2MgJiYgXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gICAgbGV0IHZwID0gZG9jLmRlZmF1bHRWaWV3ICYmIGRvYy5kZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydDtcbiAgICBpZiAodnApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCByaWdodDogdnAud2lkdGgsXG4gICAgICAgICAgICB0b3A6IDAsIGJvdHRvbTogdnAuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZSh2YWx1ZSwgc2lkZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0KG5vZGUpIHtcbiAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgICBsZXQgc2NhbGVYID0gKHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoKSB8fCAxO1xuICAgIGxldCBzY2FsZVkgPSAocmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbm9kZS5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICAgIGxldCBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7IHBhcmVudCA9IHBhcmVudE5vZGUocGFyZW50KSkge1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgbGV0IGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgICAgICBsZXQgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgID8gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikgLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA6IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRUb3AgfHwgL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8vIFN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcywgYWxvbmcgd2l0aFxuLy8gdGhlIHRvcCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IG5lYXIgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCB3aGljaFxuLy8gd2lsbCBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgdmlzaWJsZSB2aWV3cG9ydCByZW1haW5zIHN0YWJsZSBldmVuXG4vLyB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGFib3ZlIGNoYW5nZXMuXG5mdW5jdGlvbiBzdG9yZVNjcm9sbFBvcyh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICAgIGxldCByZWZET00sIHJlZlRvcDtcbiAgICBmb3IgKGxldCB4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgeSA9IHN0YXJ0WSArIDE7IHkgPCBNYXRoLm1pbihpbm5lckhlaWdodCwgcmVjdC5ib3R0b20pOyB5ICs9IDUpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgICAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgICAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZET006IHJlZkRPTSwgcmVmVG9wOiByZWZUb3AsIHN0YWNrOiBzY3JvbGxTdGFjayh2aWV3LmRvbSkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICAgIGxldCBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyBkb206IGN1ciwgdG9wOiBjdXIuc2Nyb2xsVG9wLCBsZWZ0OiBjdXIuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgaWYgKGRvbSA9PSBkb2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzIHRvIHRoYXQgd2hhdFxuLy8gaXQgd2FzIGJlZm9yZSwgd2hlbiBzdG9yZVNjcm9sbFBvcyB3YXMgY2FsbGVkLlxuZnVuY3Rpb24gcmVzZXRTY3JvbGxQb3MoeyByZWZET00sIHJlZlRvcCwgc3RhY2sgfSkge1xuICAgIGxldCBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIG5ld1JlZlRvcCA9PSAwID8gMCA6IG5ld1JlZlRvcCAtIHJlZlRvcCk7XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGRvbSwgdG9wLCBsZWZ0IH0gPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcm93Qm90ID0gY29vcmRzLnRvcCwgcm93VG9wID0gY29vcmRzLnRvcDtcbiAgICBsZXQgZmlyc3RCZWxvdywgY29vcmRzQmVsb3c7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgIGxldCByZWN0cztcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPD0gcm93Qm90ICYmIHJlY3QuYm90dG9tID49IHJvd1RvcCkge1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gcmVjdC5sZWZ0IC0gY29vcmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8IGR4Q2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNDbG9zZXN0ID0gZHggJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC50b3AgPiBjb29yZHMudG9wICYmICFmaXJzdEJlbG93ICYmIHJlY3QubGVmdCA8PSBjb29yZHMubGVmdCAmJiByZWN0LnJpZ2h0ID49IGNvb3Jkcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RCZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvb3Jkc0JlbG93ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIE1hdGgubWluKHJlY3QucmlnaHQsIGNvb3Jkcy5sZWZ0KSksIHRvcDogcmVjdC50b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8XG4gICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdCAmJiBmaXJzdEJlbG93KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBmaXJzdEJlbG93O1xuICAgICAgICBjb29yZHNDbG9zZXN0ID0gY29vcmRzQmVsb3c7XG4gICAgICAgIGR4Q2xvc2VzdCA9IDA7XG4gICAgfVxuICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGZpbmRPZmZzZXRJblRleHQoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG4gICAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSlcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG4gICAgcmV0dXJuIGZpbmRPZmZzZXRJbk5vZGUoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBpICsgMSk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QocmFuZ2UsIDEpO1xuICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiAwIH07XG59XG5mdW5jdGlvbiBpblJlY3QoY29vcmRzLCByZWN0KSB7XG4gICAgcmV0dXJuIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAtIDEgJiYgY29vcmRzLmxlZnQgPD0gcmVjdC5yaWdodCArIDEgJiZcbiAgICAgICAgY29vcmRzLnRvcCA+PSByZWN0LnRvcCAtIDEgJiYgY29vcmRzLnRvcCA8PSByZWN0LmJvdHRvbSArIDE7XG59XG5mdW5jdGlvbiB0YXJnZXRLbHVkZ2UoZG9tLCBjb29yZHMpIHtcbiAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIHJldHVybiBkb207XG59XG5mdW5jdGlvbiBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gZmluZE9mZnNldEluTm9kZShlbHQsIGNvb3JkcyksIGJpYXMgPSAtMTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmICFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBiaWFzID0gcmVjdC5sZWZ0ICE9IHJlY3QucmlnaHQgJiYgY29vcmRzLmxlZnQgPiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcykge1xuICAgIC8vIEJyb3dzZXIgKGluIGNhcmV0UG9zaXRpb24vUmFuZ2VGcm9tUG9pbnQpIHdpbGwgYWdyZXNzaXZlbHlcbiAgICAvLyBub3JtYWxpemUgdG93YXJkcyBuZWFyYnkgaW5saW5lIG5vZGVzLiBTaW5jZSB3ZSBhcmUgaW50ZXJlc3RlZCBpblxuICAgIC8vIHBvc2l0aW9ucyBiZXR3ZWVuIGJsb2NrIG5vZGVzIHRvbywgd2UgZmlyc3Qgd2FsayB1cCB0aGUgaGllcmFyY2h5XG4gICAgLy8gb2Ygbm9kZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBibG9jayBub2RlcyB0aGF0IHRoZSBjb29yZGluYXRlc1xuICAgIC8vIGZhbGwgb3V0c2lkZSBvZi4gSWYgc28sIHdlIHRha2UgdGhlIHBvc2l0aW9uIGJlZm9yZS9hZnRlciB0aGF0XG4gICAgLy8gYmxvY2suIElmIG5vdCwgd2UgY2FsbCBgcG9zRnJvbURPTWAgb24gdGhlIHJhdyBub2RlL29mZnNldC5cbiAgICBsZXQgb3V0c2lkZUJsb2NrID0gLTE7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZSwgc2F3QmxvY2sgPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gdmlldy5kb20pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY3VyLCB0cnVlKTtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChkZXNjLmRvbS5ub2RlVHlwZSA9PSAxICYmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCB8fCAhZGVzYy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBkZXNjLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgdGhlIGhvcml6b250YWwgdGVzdCB0byB0aGUgaW5uZXJtb3N0IGJsb2NrLiBWZXJ0aWNhbCBmb3IgYW55IHBhcmVudC5cbiAgICAgICAgICAgICAgICBpZiAoIXNhd0Jsb2NrICYmIHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNhd0Jsb2NrICYmIHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHJvb3QsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBicktsdWRnZSA9IGZhbHNlO1xuICAgICAgICAvLyBPbiBGaXJlZm94LCB1c2luZyBTZWxlY3Rpb24uY29sbGFwc2UgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgYVxuICAgICAgICAvLyBCUiBub2RlIGZvciBzb21lIHJlYXNvbiBkb2Vzbid0IGFsd2F5cyB3b3JrICgjMTA3MykuIE9uIFNhZmFyaSxcbiAgICAgICAgLy8gdGhlIGN1cnNvciBzb21ldGltZXMgaW5leHBsaWNhYmxlIHZpc3VhbGx5IGxhZ3MgYmVoaW5kIGl0c1xuICAgICAgICAvLyByZXBvcnRlZCBwb3NpdGlvbiBpbiBzdWNoIHNpdHVhdGlvbnMgKCMxMDkyKS5cbiAgICAgICAgaWYgKChnZWNrbyB8fCBzYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9ICEhKG9mZnNldCAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSA9PSBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgICAgICAgICAgIGlmIChicktsdWRnZSAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBhZnRlcjsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyID0gc2Nhbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET00gPSB7IG5vZGU6IGFmdGVyLnBhcmVudE5vZGUsIG9mZnNldDogZG9tSW5kZXgoYWZ0ZXIpICsgMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBzY2FuLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveCBjYW4gYWN0IHN0cmFuZ2VseSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gZnJvbnQgb2YgYW5cbiAgICAgICAgLy8gdW5lZGl0YWJsZSBub2RlLiBTZWUgIzExNjMgYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDk1MzZcbiAgICAgICAgaWYgKGdlY2tvICYmIGRvbVNlbC5mb2N1c05vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZSAhPSBoZWFkRE9NLm5vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21TZWwuZm9jdXNOb2RlLmNoaWxkTm9kZXNbZG9tU2VsLmZvY3VzT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmb3JjZSB8fCBicktsdWRnZSAmJiBzYWZhcmkpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICBsZXQgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhYnJLbHVkZ2UpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc1RleHQodGV4dCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlO1xuICAgICAgICBpZiAoIXRleHROb2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyh0ZXh0Tm9kZS5wYXJlbnROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRleHQgaW4gdGhlIGZvY3VzZWQgbm9kZSBpbiB0aGUgbm9kZSwgc3RvcCBpZiBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gdGhlcmUgKG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgdGhyb3VnaCBvdGhlciBtZWFucywgaW4gd2hpY2hcbiAgICAgICAgICAgIC8vIGNhc2UgaXQgc2hvdWxkIG92ZXJ3cml0dGVuKVxuICAgICAgICAgICAgbGV0IHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICBsZXQgdGV4dFBvcyA9IGZpbmRUZXh0SW5GcmFnbWVudCh0aGlzLm5vZGUuY29udGVudCwgdGV4dCwgZnJvbSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHRQb3MgPCAwID8gbnVsbCA6IHsgbm9kZTogdGV4dE5vZGUsIHBvczogdGV4dFBvcywgdGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGV4dE5vZGUsIHBvczogLTEsIHRleHQ6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCB7IG5vZGUsIHBvcywgdGV4dCB9KSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIGFscmVhZHkgcGFydCBvZiBhIGxvY2FsIHZpZXcgZGVzYywgbGVhdmUgaXQgdGhlcmVcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGVzYyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tcG9zaXRpb24gdmlldyBmb3IgdGhlIG9ycGhhbmVkIG5vZGVzXG4gICAgICAgIGxldCB0b3BOb2RlID0gbm9kZTtcbiAgICAgICAgZm9yICg7OyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucG1WaWV3RGVzYylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBuZXcgQ29tcG9zaXRpb25WaWV3RGVzYyh0aGlzLCB0b3BOb2RlLCBub2RlLCB0ZXh0KTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnB1c2goZGVzYyk7XG4gICAgICAgIC8vIFBhdGNoIHVwIHRoaXMuY2hpbGRyZW4gdG8gY29udGFpbiB0aGUgY29tcG9zaXRpb24gdmlld1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gcmVwbGFjZU5vZGVzKHRoaXMuY2hpbGRyZW4sIHBvcywgcG9zICsgdGV4dC5sZW5ndGgsIHZpZXcsIGRlc2MpO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIGRlc2MgbXVzdCBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gICAgLy8gZG8gc28gYW5kIHJldHVybiB0cnVlLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICAgIHVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pIHtcbiAgICAgICAgaWYgKHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICAgICAgbGV0IG9sZERPTSA9IHRoaXMuZG9tO1xuICAgICAgICB0aGlzLmRvbSA9IHBhdGNoT3V0ZXJEZWNvKHRoaXMuZG9tLCB0aGlzLm5vZGVET00sIGNvbXB1dGVPdXRlckRlY28odGhpcy5vdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSwgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSBvbGRET00pIHtcbiAgICAgICAgICAgIG9sZERPTS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgfVxuICAgIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBub2RlIG1hcmtpbmcgZnJvbSB0aGlzIG5vZGUuXG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzQXRvbTsgfVxufVxuLy8gQ3JlYXRlIGEgdmlldyBkZXNjIGZvciB0aGUgdG9wLWxldmVsIGRvY3VtZW50IG5vZGUsIHRvIGJlIGV4cG9ydGVkXG4vLyBhbmQgdXNlZCBieSB0aGUgdmlldyBjbGFzcy5cbmZ1bmN0aW9uIGRvY1ZpZXdEZXNjKGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgdmlldykge1xuICAgIGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBkb2MpO1xuICAgIGxldCBkb2NWaWV3ID0gbmV3IE5vZGVWaWV3RGVzYyh1bmRlZmluZWQsIGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgZG9tLCBkb20sIHZpZXcsIDApO1xuICAgIGlmIChkb2NWaWV3LmNvbnRlbnRET00pXG4gICAgICAgIGRvY1ZpZXcudXBkYXRlQ2hpbGRyZW4odmlldywgMCk7XG4gICAgcmV0dXJuIGRvY1ZpZXc7XG59XG5jbGFzcyBUZXh0Vmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG51bGwsIG5vZGVET00sIHZpZXcsIDApO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGxldCBza2lwID0gdGhpcy5ub2RlRE9NLnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChza2lwICYmIHNraXAgIT0gdGhpcy5kb20gJiYgIXNraXAucG1Jc0RlY28pXG4gICAgICAgICAgICBza2lwID0gc2tpcC5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4geyBza2lwOiAoc2tpcCB8fCB0cnVlKSB9O1xuICAgIH1cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fCAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgJiYgIXRoaXMuaW5QYXJlbnQoKSkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgaWYgKCh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSB8fCBub2RlLnRleHQgIT0gdGhpcy5ub2RlLnRleHQpICYmIG5vZGUudGV4dCAhPSB0aGlzLm5vZGVET00ubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00ubm9kZVZhbHVlID0gbm9kZS50ZXh0O1xuICAgICAgICAgICAgaWYgKHZpZXcudHJhY2tXcml0ZXMgPT0gdGhpcy5ub2RlRE9NKVxuICAgICAgICAgICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpblBhcmVudCgpIHtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9IHRoaXMucGFyZW50LmNvbnRlbnRET007XG4gICAgICAgIGZvciAobGV0IG4gPSB0aGlzLm5vZGVET007IG47IG4gPSBuLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBpZiAobiA9PSBwYXJlbnRET00pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5ub2RlRE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgTWF0aC5taW4ob2Zmc2V0LCB0aGlzLm5vZGUudGV4dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gc3VwZXIubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiO1xuICAgIH1cbiAgICBzbGljZShmcm9tLCB0bywgdmlldykge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZS5jdXQoZnJvbSwgdG8pLCBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyh0aGlzLnBhcmVudCwgbm9kZSwgdGhpcy5vdXRlckRlY28sIHRoaXMuaW5uZXJEZWNvLCBkb20sIGRvbSwgdmlldyk7XG4gICAgfVxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBzdXBlci5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5kb20gIT0gdGhpcy5ub2RlRE9NICYmIChmcm9tID09IDAgfHwgdG8gPT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IE5PREVfRElSVFk7XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc1RleHQodGV4dCkgeyByZXR1cm4gdGhpcy5ub2RlLnRleHQgPT0gdGV4dDsgfVxufVxuLy8gQSBkdW1teSBkZXNjIHVzZWQgdG8gdGFnIHRyYWlsaW5nIEJSIG9yIElNRyBub2RlcyBjcmVhdGVkIHRvIHdvcmtcbi8vIGFyb3VuZCBjb250ZW50RWRpdGFibGUgdGVycmlibGVuZXNzLlxuY2xhc3MgVHJhaWxpbmdIYWNrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZTsgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBcIklNR1wiOyB9XG59XG4vLyBBIHNlcGFyYXRlIHN1YmNsYXNzIGlzIHVzZWQgZm9yIGN1c3RvbWl6ZWQgbm9kZSB2aWV3cywgc28gdGhhdCB0aGVcbi8vIGV4dHJhIGNoZWNrcyBvbmx5IGhhdmUgdG8gYmUgbWFkZSBmb3Igbm9kZXMgdGhhdCBhcmUgYWN0dWFsbHlcbi8vIGN1c3RvbWl6ZWQuXG5jbGFzcyBDdXN0b21Ob2RlVmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gICAgLy8gdGhyb3VnaC4gSWYgaXQgZG9lcywgYW5kIHRoZXJlJ3MgYSBgY29udGVudERPTWAgbm9kZSwgb3VyIGxvZ2ljXG4gICAgLy8gdXBkYXRlcyB0aGUgY2hpbGRyZW4uXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2hlbiBhIG5vZGUgd2l0aCBjb250ZW50IGlzIHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IG5vZGUgd2l0aFxuICAgIC8vIGlkZW50aWNhbCBjb250ZW50LCBtb3ZlIG92ZXIgaXRzIGNoaWxkcmVuLlxuICAgIHJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGlmIChuZXh0LmRpcnR5IHx8IG5vZGUuaXNBdG9tIHx8ICFuZXh0LmNoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgIW5leHQubm9kZS5jb250ZW50LmVxKG5vZGUuY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKHdyYXBwZXIuY29udGVudERPTSkge1xuICAgICAgICAgICAgd3JhcHBlci5jaGlsZHJlbiA9IG5leHQuY2hpbGRyZW47XG4gICAgICAgICAgICBuZXh0LmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiB3cmFwcGVyLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLnBhcmVudCA9IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cbiAgICBhZGROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSlcbiAgICAgICAgICAgIGRlc2MudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmXG4gICAgICAgICAgICAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhIHRleHRibG9jayBsb29rcyBhbmQgYmVoYXZlcyBjb3JyZWN0bHkgaW5cbiAgICAvLyBjb250ZW50RWRpdGFibGUuXG4gICAgYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sIHBhcmVudCA9IHRoaXMudG9wO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IC8vIEVtcHR5IHRleHRibG9ja1xuICAgICAgICAgICAgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8XG4gICAgICAgICAgICAvXFxuJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMudmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgJiYgL1xccyQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgICAgICAgICBpZiAoKHNhZmFyaSB8fCBjaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIkJSXCIsIHRoaXMudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiO1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jayAmJiAobm9kZSA9PSB0aGlzLmxvY2sgfHwgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKTtcbiAgICB9XG59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBwYXJlbnREZXNjKSB7XG4gICAgbGV0IGN1ckRlc2MgPSBwYXJlbnREZXNjLCBkZXNjSSA9IGN1ckRlc2MuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBmSSA9IGZyYWcuY2hpbGRDb3VudCwgbWF0Y2hlZCA9IG5ldyBNYXAsIG1hdGNoZXMgPSBbXTtcbiAgICBvdXRlcjogd2hpbGUgKGZJID4gMCkge1xuICAgICAgICBsZXQgZGVzYztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRlc2NJKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJEZXNjLmNoaWxkcmVuW2Rlc2NJIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJID0gbmV4dC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0ktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyRGVzYyA9PSBwYXJlbnREZXNjKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIGRlc2NJID0gY3VyRGVzYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjdXJEZXNjKTtcbiAgICAgICAgICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLS1mSTtcbiAgICAgICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgICAgICBtYXRjaGVzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBmSSwgbWF0Y2hlZCwgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKCkgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gYWJzdHJhY3RzIGl0ZXJhdGluZyBvdmVyIHRoZSBub2RlcyBhbmQgZGVjb3JhdGlvbnMgaW5cbi8vIGEgZnJhZ21lbnQuIENhbGxzIGBvbk5vZGVgIGZvciBlYWNoIG5vZGUsIHdpdGggaXRzIGxvY2FsIGFuZCBjaGlsZFxuLy8gZGVjb3JhdGlvbnMuIFNwbGl0cyB0ZXh0IG5vZGVzIHdoZW4gdGhlcmUgaXMgYSBkZWNvcmF0aW9uIHN0YXJ0aW5nXG4vLyBvciBlbmRpbmcgaW5zaWRlIG9mIHRoZW0uIENhbGxzIGBvbldpZGdldGAgZm9yIGVhY2ggd2lkZ2V0LlxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gICAgLy8gU2ltcGxlLCBjaGVhcCB2YXJpYW50IGZvciB3aGVuIHRoZXJlIGFyZSBubyBsb2NhbCBkZWNvcmF0aW9uc1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICAgICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVjb0luZGV4ID0gMCwgYWN0aXZlID0gW10sIHJlc3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgICAgICBsZXQgd2lkZ2V0LCB3aWRnZXRzO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbG9jYWxzW2RlY29JbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChuZXh0LndpZGdldCkge1xuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tpXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0LCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkLCBpbmRleDtcbiAgICAgICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY2hpbGQgPSByZXN0Tm9kZTtcbiAgICAgICAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQocGFyZW50SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpXG4gICAgICAgICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgY3V0QXQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8IGN1dEF0KVxuICAgICAgICAgICAgICAgICAgICBjdXRBdCA9IGFjdGl2ZVtpXS50bztcbiAgICAgICAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3ROb2RlID0gY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIGRlY29JbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG4vLyBGaW5kIGEgcGllY2Ugb2YgdGV4dCBpbiBhbiBpbmxpbmUgZnJhZ21lbnQsIG92ZXJsYXBwaW5nIGZyb20tdG9cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgZnJhZy5jaGlsZENvdW50ICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZy5jaGlsZChpKyspLCBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmICghY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzdHIgPSBjaGlsZC50ZXh0O1xuICAgICAgICB3aGlsZSAoaSA8IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnLmNoaWxkKGkrKyk7XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmICghbmV4dC5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdHIgKz0gbmV4dC50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0byAmJiBzdHIuc2xpY2UodG8gLSB0ZXh0Lmxlbmd0aCAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG8gLSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGNoaWxkU3RhcnQgPCB0byA/IHN0ci5sYXN0SW5kZXhPZih0ZXh0LCB0byAtIGNoaWxkU3RhcnQgLSAxKSA6IC0xO1xuICAgICAgICAgICAgaWYgKGZvdW5kID49IDAgJiYgZm91bmQgKyB0ZXh0Lmxlbmd0aCArIGNoaWxkU3RhcnQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRTdGFydCArIGZvdW5kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgc3RyLmxlbmd0aCA+PSAodG8gKyB0ZXh0Lmxlbmd0aCkgLSBjaGlsZFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgc3RyLnNsaWNlKHRvIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0ICsgdGV4dC5sZW5ndGgpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJlcGxhY2UgcmFuZ2UgZnJvbS10byBpbiBhbiBhcnJheSBvZiB2aWV3IGRlc2NzIHdpdGggcmVwbGFjZW1lbnRcbi8vIChtYXkgYmUgbnVsbCB0byBqdXN0IGRlbGV0ZSkuIFRoaXMgZ29lcyB2ZXJ5IG11Y2ggYWdhaW5zdCB0aGUgZ3JhaW5cbi8vIG9mIHRoZSByZXN0IG9mIHRoaXMgY29kZSwgd2hpY2ggdGVuZHMgdG8gY3JlYXRlIG5vZGVzIHdpdGggdGhlXG4vLyByaWdodCBzaGFwZSBpbiBvbmUgZ28sIHJhdGhlciB0aGFuIG1lc3Npbmcgd2l0aCB0aGVtIGFmdGVyXG4vLyBjcmVhdGlvbiwgYnV0IGlzIG5lY2Vzc2FyeSBpbiB0aGUgY29tcG9zaXRpb24gaGFjay5cbmZ1bmN0aW9uIHJlcGxhY2VOb2Rlcyhub2RlcywgZnJvbSwgdG8sIHZpZXcsIHJlcGxhY2VtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKDAsIGZyb20gLSBzdGFydCwgdmlldykpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbiA9IG51bGwpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBuZWFyZXN0RGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb21TZWwuZm9jdXNOb2RlKSwgaW5XaWRnZXQgPSBuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzYy5zaXplID09IDA7XG4gICAgbGV0IGhlYWQgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIDEpO1xuICAgIGlmIChoZWFkIDwgMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUoaGVhZCksICRhbmNob3IsIHNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpXG4gICAgICAgICAgICBuZWFyZXN0RGVzYyA9IG5lYXJlc3REZXNjLnBhcmVudDtcbiAgICAgICAgbGV0IG5lYXJlc3REZXNjTm9kZSA9IG5lYXJlc3REZXNjLm5vZGU7XG4gICAgICAgIGlmIChuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzY05vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5lYXJlc3REZXNjTm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICAgICAmJiAhKG5lYXJlc3REZXNjTm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoYW5jaG9yIDwgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgICAgIGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFRoZSBkZWxheWVkIGRyYWcgc2VsZWN0aW9uIGNhdXNlcyBpc3N1ZXMgd2l0aCBDZWxsIFNlbGVjdGlvbnNcbiAgICAvLyBpbiBTYWZhcmkuIEFuZCB0aGUgZHJhZyBzZWxlY3Rpb24gZGVsYXkgaXMgdG8gd29ya2Fyb25kIGlzc3Vlc1xuICAgIC8vIHdoaWNoIG9ubHkgcHJlc2VudCBpbiBDaHJvbWUuXG4gICAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICYmIGN1clNlbC5hbmNob3JOb2RlICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICAgICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IGFuY2hvciwgaGVhZCB9ID0gc2VsLCByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVUbyA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kb2NWaWV3LnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcucm9vdCwgZm9yY2UpO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSlcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlVG8pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChcIm9uc2VsZWN0aW9uY2hhbmdlXCIgaW4gZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY29ubmVjdFNlbGVjdGlvbigpO1xufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuY29uc3QgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSBzYWZhcmkgfHwgY2hyb21lICYmIGNocm9tZV92ZXJzaW9uIDwgNjM7XG5mdW5jdGlvbiB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBwb3MpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgbGV0IGFmdGVyID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIDogbnVsbDtcbiAgICBsZXQgYmVmb3JlID0gb2Zmc2V0ID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdIDogbnVsbDtcbiAgICBpZiAoc2FmYXJpICYmIGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKCFiZWZvcmUgfHwgYmVmb3JlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpKSB7XG4gICAgICAgIGlmIChhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIGlmIChzYWZhcmkgJiYgZWxlbWVudC5kcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHJlc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IGRvbVNlbC5hbmNob3JOb2RlLCBvZmZzZXQgPSBkb21TZWwuYW5jaG9yT2Zmc2V0O1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkID0gKCkgPT4ge1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBkb21TZWwuYW5jaG9yT2Zmc2V0ICE9IG9mZnNldCkge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGxldCBub2RlID0gdmlldy5jdXJzb3JXcmFwcGVyLmRvbSwgaW1nID0gbm9kZS5ub2RlTmFtZSA9PSBcIklNR1wiO1xuICAgIGlmIChpbWcpXG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLnBhcmVudE5vZGUsIGRvbUluZGV4KG5vZGUpICsgMSk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgMCk7XG4gICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIC8vIEtsdWRnZSB0byBraWxsICdjb250cm9sIHNlbGVjdGlvbicgaW4gSUUxMSB3aGVuIHNlbGVjdGluZyBhblxuICAgIC8vIGludmlzaWJsZSBjdXJzb3Igd3JhcHBlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gdGhvc2Ugd2VpcmRcbiAgICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgICAvLyBwb3NpdGlvbmVkIHdyYXBwZXIsIHJhdGhlciB0aGFuIHRoZSByb290IGVkaXRhYmxlIG5vZGUsIHRoZVxuICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICAgICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgZGVzYy5zZWxlY3ROb2RlKCk7XG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gZGVzYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgIH1cbn1cbi8vIENsZWFyIGFsbCBET00gc3RhdGVmdWxuZXNzIG9mIHRoZSBsYXN0IG5vZGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpXG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZiA9PiBmKHZpZXcsICRhbmNob3IsICRoZWFkKSlcbiAgICAgICAgfHwgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5lZGl0YWJsZSAmJiAhdmlldy5oYXNGb2N1cygpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJlxuICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgICBsZXQgYW5jaG9yRE9NID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCAwKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQmxvY2soc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRhbmNob3IsICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgICBsZXQgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgICByZXR1cm4gJHN0YXJ0ICYmIFNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7ICRoZWFkIH0gPSBzZWwsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0IHx8ICFub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJG5ld0hlYWQgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyArIG5vZGUubm9kZVNpemUgKiAoZGlyIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHNlbC4kYW5jaG9yLCAkbmV3SGVhZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzZWwuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tLCBkaXIpIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkaXIgPCAwIHx8IGRvbS5uZXh0U2libGluZyB8fCBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKTtcbn1cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKSB7XG4gICAgcmV0dXJuIGRpciA8IDAgPyBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIDogc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldCwgZm9yY2UgPSBmYWxzZTtcbiAgICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gICAgLy8gb2YgYSBub24tZWRpdGFibGUgbm9kZSwgc28gaW4gdGhhdCBjYXNlLCBtb3ZlIGl0IGludG8gdGhlIG5leHRcbiAgICAvLyBub2RlIGlmIHBvc3NpYmxlLiBJc3N1ZSBwcm9zZW1pcnJvci9wcm9zZW1pcnJvciM4MzIuXG4gICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlTGVuKG5vZGUpICYmIGlzSWdub3JhYmxlKG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCAtMSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSAtLW9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBpc0lnbm9yYWJsZShwcmV2LCAtMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgocHJldik7XG4gICAgICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBiZWZvcmUgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGFmdGVyLCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gKytvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgaXNJZ25vcmFibGUobmV4dCwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgobmV4dCkgKyAxO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVuID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tOb2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmICFvZmZzZXQgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciA9IHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGFmdGVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbC5leHRlbmQpIHtcbiAgICAgICAgc2VsLmV4dGVuZChub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBlbmRzIHVwIGhhcHBlbmluZywgcmVzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUgPT0gc3RhdGUpXG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uKHZpZXcsIHBvcykge1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghKGNocm9tZSB8fCB3aW5kb3dzKSAmJiAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBjb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiAkcG9zLnN0YXJ0KCkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyAtIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChiZWZvcmUudG9wICsgYmVmb3JlLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhiZWZvcmUubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS5sZWZ0IDwgY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgJHBvcy5lbmQoKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdmlldy5jb29yZHNBdFBvcyhwb3MgKyAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYWZ0ZXIudG9wICsgYWZ0ZXIuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGFmdGVyLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlci5sZWZ0ID4gY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS5kaXJlY3Rpb247XG4gICAgcmV0dXJuIGNvbXB1dGVkID09IFwicnRsXCIgPyBcInJ0bFwiIDogXCJsdHJcIjtcbn1cbi8vIENoZWNrIHdoZXRoZXIgdmVydGljYWwgc2VsZWN0aW9uIG1vdGlvbiB3b3VsZCBpbnZvbHZlIG5vZGVcbi8vIHNlbGVjdGlvbnMuIElmIHNvLCBhcHBseSBpdCAoaWYgbm90LCB0aGUgcmVzdWx0IGlzIGxlZnQgdG8gdGhlXG4vLyBicm93c2VyKVxuZnVuY3Rpb24gc2VsZWN0VmVydGljYWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyIDwgMCA/IFwidXBcIiA6IFwiZG93blwiKSkge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBzaWRlID0gZGlyIDwgMCA/ICRmcm9tIDogJHRvO1xuICAgICAgICBsZXQgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uID8gU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IFNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgICAgICByZXR1cm4gYmV5b25kID8gYXBwbHkodmlldywgYmV5b25kKSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCBkaXIpIHtcbiAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciwgZW1wdHkgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBuZXh0Tm9kZSA9ICEkaGVhZC50ZXh0T2Zmc2V0ICYmIChkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcik7XG4gICAgaWYgKG5leHROb2RlICYmICFuZXh0Tm9kZS5pc1RleHQpIHtcbiAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zIC0gbmV4dE5vZGUubm9kZVNpemUsICRoZWFkLnBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBub2RlLCBzdGF0ZSkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gc3RhdGU7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xufVxuLy8gSXNzdWUgIzg2NyAvICMxMDkwIC8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTAzODIxXG4vLyBJbiB3aGljaCBTYWZhcmkgKGFuZCBhdCBzb21lIHBvaW50IGluIHRoZSBwYXN0LCBDaHJvbWUpIGRvZXMgcmVhbGx5XG4vLyB3cm9uZyB0aGluZ3Mgd2hlbiB0aGUgZG93biBhcnJvdyBpcyBwcmVzc2VkIHdoZW4gdGhlIGN1cnNvciBpc1xuLy8gZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrIGFuZCBoYXMgYW4gdW5lZGl0YWJsZSBub2RlXG4vLyBhZnRlciBpdFxuZnVuY3Rpb24gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHtcbiAgICBpZiAoIXNhZmFyaSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJlxuICAgICAgICBmb2N1c05vZGUuZmlyc3RDaGlsZCAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgICAgICBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJ0cnVlXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcImZhbHNlXCIpLCAyMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIEEgYmFja2Ryb3Aga2V5IG1hcHBpbmcgdXNlZCB0byBtYWtlIHN1cmUgd2UgYWx3YXlzIHN1cHByZXNzIGtleXNcbi8vIHRoYXQgaGF2ZSBhIGRhbmdlcm91cyBkZWZhdWx0IGVmZmVjdCwgZXZlbiBpZiB0aGUgY29tbWFuZHMgdGhleSBhcmVcbi8vIGJvdW5kIHRvIHJldHVybiBmYWxzZSwgYW5kIHRvIG1ha2Ugc3VyZSB0aGF0IGN1cnNvci1tb3Rpb24ga2V5c1xuLy8gZmluZCBhIGN1cnNvciAoYXMgb3Bwb3NlZCB0byBhIG5vZGUgc2VsZWN0aW9uKSB3aGVuIHByZXNzZWQuIEZvclxuLy8gY3Vyc29yLW1vdGlvbiBrZXlzLCB0aGUgY29kZSBpbiB0aGUgaGFuZGxlcnMgYWxzbyB0YWtlcyBjYXJlIG9mXG4vLyBibG9jayBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZ2V0TW9kcyhldmVudCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJjXCI7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcIm1cIjtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJhXCI7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJzXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGNvZGUgPSBldmVudC5rZXlDb2RlLCBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG4gICAgaWYgKGNvZGUgPT0gOCB8fCAobWFjICYmIGNvZGUgPT0gNzIgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gQmFja3NwYWNlLCBDdHJsLWggb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAtMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChjb2RlID09IDQ2ICYmICFldmVudC5zaGlmdEtleSkgfHwgKG1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERlbGV0ZSwgQ3RybC1kIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAxMyB8fCBjb2RlID09IDI3KSB7IC8vIEVudGVyLCBFc2NcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzcgfHwgKG1hYyAmJiBjb2RlID09IDY2ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIExlZnQgYXJyb3csIEN0cmwtYiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzcgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gLTEgOiAxKSA6IC0xO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM5IHx8IChtYWMgJiYgY29kZSA9PSA3MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBSaWdodCBhcnJvdywgQ3RybC1mIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzOSA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAxIDogLTEpIDogMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOCB8fCAobWFjICYmIGNvZGUgPT0gODAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gVXAgYXJyb3csIEN0cmwtcCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDQwIHx8IChtYWMgJiYgY29kZSA9PSA3OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEb3duIGFycm93LCBDdHJsLW4gb24gTWFjXG4gICAgICAgIHJldHVybiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykgfHwgc2VsZWN0VmVydGljYWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RzID09IChtYWMgPyBcIm1cIiA6IFwiY1wiKSAmJlxuICAgICAgICAoY29kZSA9PSA2NiB8fCBjb2RlID09IDczIHx8IGNvZGUgPT0gODkgfHwgY29kZSA9PSA5MCkpIHsgLy8gTW9kLVtiaXl6XVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtQ29waWVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICBsZXQgY29udGV4dCA9IFtdLCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUudHlwZS5uYW1lLCBub2RlLmF0dHJzICE9IG5vZGUudHlwZS5kZWZhdWx0QXR0cnMgPyBub2RlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemVyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFNlcmlhbGl6ZXJcIikgfHwgRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgZG9jID0gZGV0YWNoZWREb2MoKSwgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudChjb250ZW50LCB7IGRvY3VtZW50OiBkb2MgfSkpO1xuICAgIGxldCBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkLCBuZWVkc1dyYXAsIHdyYXBwZXJzID0gMDtcbiAgICB3aGlsZSAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgKG5lZWRzV3JhcCA9IHdyYXBNYXBbZmlyc3RDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5lZWRzV3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChuZWVkc1dyYXBbaV0pO1xuICAgICAgICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgd3JhcHBlcnMrKztcbiAgICAgICAgfVxuICAgICAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICAgIH1cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgIGZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiLCBgJHtvcGVuU3RhcnR9ICR7b3BlbkVuZH0ke3dyYXBwZXJzID8gYCAtJHt3cmFwcGVyc31gIDogXCJcIn0gJHtKU09OLnN0cmluZ2lmeShjb250ZXh0KX1gKTtcbiAgICBsZXQgdGV4dCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLCBmID0+IGYoc2xpY2UsIHZpZXcpKSB8fFxuICAgICAgICBzbGljZS5jb250ZW50LnRleHRCZXR3ZWVuKDAsIHNsaWNlLmNvbnRlbnQuc2l6ZSwgXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuIHsgZG9tOiB3cmFwLCB0ZXh0LCBzbGljZSB9O1xufVxuLy8gUmVhZCBhIHNsaWNlIG9mIGNvbnRlbnQgZnJvbSB0aGUgY2xpcGJvYXJkIChvciBkcm9wIGRhdGEpLlxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgICBsZXQgaW5Db2RlID0gJGNvbnRleHQucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCBkb20sIHNsaWNlO1xuICAgIGlmICghaHRtbCAmJiAhdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFzVGV4dCA9IHRleHQgJiYgKHBsYWluVGV4dCB8fCBpbkNvZGUgfHwgIWh0bWwpO1xuICAgIGlmIChhc1RleHQpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZiA9PiB7IHRleHQgPSBmKHRleHQsIGluQ29kZSB8fCBwbGFpblRleHQsIHZpZXcpOyB9KTtcbiAgICAgICAgaWYgKGluQ29kZSlcbiAgICAgICAgICAgIHJldHVybiB0ZXh0ID8gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odmlldy5zdGF0ZS5zY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpKSwgMCwgMCkgOiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0UGFyc2VyXCIsIGYgPT4gZih0ZXh0LCAkY29udGV4dCwgcGxhaW5UZXh0LCB2aWV3KSk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gJGNvbnRleHQubWFya3MoKTtcbiAgICAgICAgICAgIGxldCB7IHNjaGVtYSB9ID0gdmlldy5zdGF0ZSwgc2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRleHQuc3BsaXQoLyg/Olxcclxcbj98XFxuKSsvKS5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICBwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplTm9kZShzY2hlbWEudGV4dChibG9jaywgbWFya3MpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZEhUTUxcIiwgZiA9PiB7IGh0bWwgPSBmKGh0bWwsIHZpZXcpOyB9KTtcbiAgICAgICAgZG9tID0gcmVhZEhUTUwoaHRtbCk7XG4gICAgICAgIGlmICh3ZWJraXQpXG4gICAgICAgICAgICByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICAgIGxldCBzbGljZURhdGEgPSBjb250ZXh0Tm9kZSAmJiAvXihcXGQrKSAoXFxkKykoPzogLShcXGQrKSk/ICguKikvLmV4ZWMoY29udGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiKSB8fCBcIlwiKTtcbiAgICBpZiAoc2xpY2VEYXRhICYmIHNsaWNlRGF0YVszXSlcbiAgICAgICAgZm9yIChsZXQgaSA9ICtzbGljZURhdGFbM107IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkb20gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIGlmICghc2xpY2UpIHtcbiAgICAgICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRQYXJzZXJcIikgfHwgdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgICAgIHNsaWNlID0gcGFyc2VyLnBhcnNlU2xpY2UoZG9tLCB7XG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICEhKGFzVGV4dCB8fCBzbGljZURhdGEpLFxuICAgICAgICAgICAgY29udGV4dDogJGNvbnRleHQsXG4gICAgICAgICAgICBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRvbS5uZXh0U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBkb20ucGFyZW50Tm9kZSAmJiAhaW5saW5lUGFyZW50cy50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2xpY2VEYXRhKSB7XG4gICAgICAgIHNsaWNlID0gYWRkQ29udGV4dChjbG9zZVNsaWNlKHNsaWNlLCArc2xpY2VEYXRhWzFdLCArc2xpY2VEYXRhWzJdKSwgc2xpY2VEYXRhWzRdKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIEhUTUwgd2Fzbid0IGNyZWF0ZWQgYnkgUHJvc2VNaXJyb3IuIE1ha2Ugc3VyZSB0b3AtbGV2ZWwgc2libGluZ3MgYXJlIGNvaGVyZW50XG4gICAgICAgIHNsaWNlID0gU2xpY2UubWF4T3Blbihub3JtYWxpemVTaWJsaW5ncyhzbGljZS5jb250ZW50LCAkY29udGV4dCksIHRydWUpO1xuICAgICAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5sYXN0Q2hpbGQ7IG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5FbmQrKywgbm9kZSA9IG5vZGUubGFzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBpbmxpbmVQYXJlbnRzID0gL14oYXxhYmJyfGFjcm9ueW18YnxjaXRlfGNvZGV8ZGVsfGVtfGl8aW5zfGtiZHxsYWJlbHxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzcGFufHN0cm9uZ3xzdWJ8c3VwfHRpbWV8dXx0dHx2YXIpJC9pO1xuLy8gVGFrZXMgYSBzbGljZSBwYXJzZWQgd2l0aCBwYXJzZVNsaWNlLCB3aGljaCBtZWFucyB0aGVyZSBoYXNuJ3QgYmVlblxuLy8gYW55IGNvbnRlbnQtZXhwcmVzc2lvbiBjaGVja2luZyBkb25lIG9uIHRoZSB0b3Agbm9kZXMsIHRyaWVzIHRvXG4vLyBmaW5kIGEgcGFyZW50IG5vZGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dCB0aGF0IG1pZ2h0IGZpdCB0aGUgbm9kZXMsXG4vLyBhbmQgaWYgc3VjY2Vzc2Z1bCwgcmVidWlsZHMgdGhlIHNsaWNlIHNvIHRoYXQgaXQgZml0cyBpbnRvIHRoYXQgcGFyZW50LlxuLy9cbi8vIFRoaXMgYWRkcmVzc2VzIHRoZSBwcm9ibGVtIHRoYXQgVHJhbnNmb3JtLnJlcGxhY2UgZXhwZWN0cyBhXG4vLyBjb2hlcmVudCBzbGljZSwgYW5kIHdpbGwgZmFpbCB0byBwbGFjZSBhIHNldCBvZiBzaWJsaW5ncyB0aGF0IGRvbid0XG4vLyBmaXQgYW55d2hlcmUgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50IDwgMilcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleChkKSk7XG4gICAgICAgIGxldCBsYXN0V3JhcCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgd3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpLCBpbkxhc3Q7XG4gICAgICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBpbkxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlZCA9IHdpdGhXcmFwcGVycyhub2RlLCB3cmFwKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh3cmFwcGVkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxhc3RXcmFwID0gd3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZnJvbSA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IGZyb207IGktLSlcbiAgICAgICAgbm9kZSA9IHdyYXBbaV0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiBub2RlO1xufVxuLy8gVXNlZCB0byBncm91cCBhZGphY2VudCBub2RlcyB3cmFwcGVkIGluIHNpbWlsYXIgcGFyZW50cyBieVxuLy8gbm9ybWFsaXplU2libGluZ3MgaW50byB0aGUgc2FtZSBwYXJlbnQgbm9kZVxuZnVuY3Rpb24gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA8IHdyYXAubGVuZ3RoICYmIGRlcHRoIDwgbGFzdFdyYXAubGVuZ3RoICYmIHdyYXBbZGVwdGhdID09IGxhc3RXcmFwW2RlcHRoXSkge1xuICAgICAgICBsZXQgaW5uZXIgPSBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcubGFzdENoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5yZXBsYWNlQ2hpbGQoc2libGluZy5jaGlsZENvdW50IC0gMSwgaW5uZXIpKTtcbiAgICAgICAgbGV0IG1hdGNoID0gc2libGluZy5jb250ZW50TWF0Y2hBdChzaWJsaW5nLmNoaWxkQ291bnQpO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZGVwdGggKyAxKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZVJpZ2h0KG5vZGUsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnbWVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQobm9kZS5jaGlsZENvdW50IC0gMSwgY2xvc2VSaWdodChub2RlLmxhc3RDaGlsZCwgZGVwdGggLSAxKSk7XG4gICAgbGV0IGZpbGwgPSBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnbWVudC5hcHBlbmQoZmlsbCkpO1xufVxuZnVuY3Rpb24gY2xvc2VSYW5nZShmcmFnbWVudCwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoLCBvcGVuRW5kKSB7XG4gICAgbGV0IG5vZGUgPSBzaWRlIDwgMCA/IGZyYWdtZW50LmZpcnN0Q2hpbGQgOiBmcmFnbWVudC5sYXN0Q2hpbGQsIGlubmVyID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgaWYgKGRlcHRoIDwgdG8gLSAxKVxuICAgICAgICBpbm5lciA9IGNsb3NlUmFuZ2UoaW5uZXIsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCArIDEsIG9wZW5FbmQpO1xuICAgIGlmIChkZXB0aCA+PSBmcm9tKVxuICAgICAgICBpbm5lciA9IHNpZGUgPCAwID8gbm9kZS5jb250ZW50TWF0Y2hBdCgwKS5maWxsQmVmb3JlKGlubmVyLCBvcGVuRW5kIDw9IGRlcHRoKS5hcHBlbmQoaW5uZXIpXG4gICAgICAgICAgICA6IGlubmVyLmFwcGVuZChub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoc2lkZSA8IDAgPyAwIDogZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIG5vZGUuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAtMSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuU3RhcnQsIDAsIHNsaWNlLm9wZW5FbmQpLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICAgIGlmIChvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG4vLyBUcmljayBmcm9tIGpRdWVyeSAtLSBzb21lIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBvdGhlclxuLy8gZWxlbWVudHMgZm9yIGlubmVySFRNTCB0byB3b3JrLiBJLmUuIGlmIHlvdSBkbyBgZGl2LmlubmVySFRNTCA9XG4vLyBcIjx0ZD4uLjwvdGQ+XCJgIHRoZSB0YWJsZSBjZWxscyBhcmUgaWdub3JlZC5cbmNvbnN0IHdyYXBNYXAgPSB7XG4gICAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICAgIHRib2R5OiBbXCJ0YWJsZVwiXSxcbiAgICB0Zm9vdDogW1widGFibGVcIl0sXG4gICAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gICAgY29sZ3JvdXA6IFtcInRhYmxlXCJdLFxuICAgIGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcbiAgICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgICB0ZDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdLFxuICAgIHRoOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl1cbn07XG5sZXQgX2RldGFjaGVkRG9jID0gbnVsbDtcbmZ1bmN0aW9uIGRldGFjaGVkRG9jKCkge1xuICAgIHJldHVybiBfZGV0YWNoZWREb2MgfHwgKF9kZXRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBodG1sO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiIH07XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSAwO1xuICAgICAgICB0aGlzLmxhc3RBbmRyb2lkRGVsZXRlID0gMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvc2luZ1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbklEID0gMTtcbiAgICAgICAgLy8gU2V0IHRvIGEgY29tcG9zaXRpb24gSUQgd2hlbiB0aGVyZSBhcmUgcGVuZGluZyBjaGFuZ2VzIGF0IGNvbXBvc2l0aW9uZW5kXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmhpZGVTZWxlY3Rpb25HdWFyZCA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdElucHV0KHZpZXcpIHtcbiAgICBmb3IgKGxldCBldmVudCBpbiBoYW5kbGVycykge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkgJiYgIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICB9LCBwYXNzaXZlSGFuZGxlcnNbZXZlbnRdID8geyBwYXNzaXZlOiB0cnVlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBPbiBTYWZhcmksIGZvciByZWFzb25zIGJleW9uZCBteSB1bmRlcnN0YW5kaW5nLCBhZGRpbmcgYW4gaW5wdXRcbiAgICAvLyBldmVudCBoYW5kbGVyIG1ha2VzIGFuIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuXG4gICAgLy8geW91IHByZXNzIGVudGVyIGdvIGF3YXkuXG4gICAgaWYgKHNhZmFyaSlcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgIGVuc3VyZUxpc3RlbmVycyh2aWV3KTtcbn1cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG59XG5mdW5jdGlvbiBkZXN0cm95SW5wdXQodmlldykge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIGZvciAobGV0IHR5cGUgaW4gdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzKVxuICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVycyh2aWV3KSB7XG4gICAgdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBjdXJyZW50SGFuZGxlcnMgPT4ge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGN1cnJlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGlmICghdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKVxuICAgICAgICAgICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdID0gZXZlbnQgPT4gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGhhbmRsZXJzID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldDsgbm9kZSAhPSB2aWV3LmRvbTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHxcbiAgICAgICAgICAgIChub2RlLnBtVmlld0Rlc2MgJiYgbm9kZS5wbVZpZXdEZXNjLnN0b3BFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh2aWV3LCBldmVudCkge1xuICAgIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiZcbiAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICBoYW5kbGVyc1tldmVudC50eXBlXSh2aWV3LCBldmVudCk7XG59XG5lZGl0SGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LmtleUNvZGUgPT0gMTYgfHwgZXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFN1cHByZXNzIGVudGVyIGtleSBldmVudHMgb24gQ2hyb21lIEFuZHJvaWQsIGJlY2F1c2UgdGhvc2UgdGVuZFxuICAgIC8vIHRvIGJlIHBhcnQgb2YgYSBjb25mdXNlZCBzZXF1ZW5jZSBvZiBjb21wb3NpdGlvbiBldmVudHMgZmlyZWQsXG4gICAgLy8gYW5kIGhhbmRsaW5nIHRoZW0gZWFnZXJseSB0ZW5kcyB0byBjb3JydXB0IHRoZSBpbnB1dC5cbiAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgZXZlbnQua2V5Q29kZSA9PSAxMylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSlcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgLy8gT24gaU9TLCBpZiB3ZSBwcmV2ZW50RGVmYXVsdCBlbnRlciBrZXkgcHJlc3NlcywgdGhlIHZpcnR1YWxcbiAgICAvLyBrZXlib2FyZCBnZXRzIGNvbmZ1c2VkLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHNldCBhIGZsYWcgdGhhdFxuICAgIC8vIG1ha2VzIHRoZSBET00gY2hhbmdlIGNvZGUgcmVjb2duaXplIHRoYXQgd2hhdCBqdXN0IGhhcHBlbnMgc2hvdWxkXG4gICAgLy8gYmUgcmVwbGFjZWQgYnkgd2hhdGV2ZXIgdGhlIEVudGVyIGtleSBoYW5kbGVycyBkby5cbiAgICBpZiAoaW9zICYmIGV2ZW50LmtleUNvZGUgPT0gMTMgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSBub3c7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPT0gbm93KSB7XG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSk7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywgZXZlbnQpKSB8fCBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcImtleVwiKTtcbiAgICB9XG59O1xuZWRpdEhhbmRsZXJzLmtleXVwID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTYpXG4gICAgICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBmYWxzZTtcbn07XG5lZGl0SGFuZGxlcnMua2V5cHJlc3MgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHxcbiAgICAgICAgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8IG1hYyAmJiBldmVudC5tZXRhS2V5KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlQcmVzc1wiLCBmID0+IGYodmlldywgZXZlbnQpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICAgICAgbGV0IHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlKTtcbiAgICAgICAgaWYgKCEvW1xcclxcbl0vLnRlc3QodGV4dCkgJiYgIXZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIHNlbC4kZnJvbS5wb3MsIHNlbC4kdG8ucG9zLCB0ZXh0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZXZlbnRDb29yZHMoZXZlbnQpIHsgcmV0dXJuIHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH07IH1cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgICBsZXQgZHggPSBjbGljay54IC0gZXZlbnQuY2xpZW50WCwgZHkgPSBjbGljay55IC0gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPCAxMDA7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKHByb3BOYW1lLCBmID0+IGkgPiAkcG9zLmRlcHRoID8gZih2aWV3LCBwb3MsICRwb3Mubm9kZUFmdGVyLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIHRydWUpXG4gICAgICAgICAgICA6IGYodmlldywgcG9zLCAkcG9zLm5vZGUoaSksICRwb3MuYmVmb3JlKGkpLCBldmVudCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24odmlldywgc2VsZWN0aW9uLCBvcmlnaW4pIHtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZClcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICBpZiAobm9kZSAmJiBub2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sIHNlbGVjdGVkTm9kZSwgc2VsZWN0QXQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pXG4gICAgICAgIHNlbGVjdGVkTm9kZSA9IHNlbC5ub2RlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBzZWwuJGZyb20uZGVwdGggPiAwICYmXG4gICAgICAgICAgICAgICAgaSA+PSBzZWwuJGZyb20uZGVwdGggJiYgJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoICsgMSkgPT0gc2VsLiRmcm9tLnBvcylcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RBdCAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgc2VsZWN0QXQpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCwgc2VsZWN0Tm9kZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIChzZWxlY3ROb2RlID8gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSA6IHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVEb3VibGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZURvdWJsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSk7XG59XG5mdW5jdGlvbiBoYW5kbGVUcmlwbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZVRyaXBsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVHJpcGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoaW5zaWRlID09IC0xKSB7XG4gICAgICAgIGlmIChkb2MuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgMCwgZG9jLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGxldCBub2RlUG9zID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zICsgMSwgbm9kZVBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZSBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9yY2VET01GbHVzaCh2aWV3KSB7XG4gICAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xufVxuY29uc3Qgc2VsZWN0Tm9kZU1vZGlmaWVyID0gbWFjID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGxldCBmbHVzaGVkID0gZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKSwgdHlwZSA9IFwic2luZ2xlQ2xpY2tcIjtcbiAgICBpZiAobm93IC0gdmlldy5pbnB1dC5sYXN0Q2xpY2sudGltZSA8IDUwMCAmJiBpc05lYXIoZXZlbnQsIHZpZXcuaW5wdXQubGFzdENsaWNrKSAmJiAhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXSkge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUgfTtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghcG9zKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lm1vdXNlRG93bilcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRvbmUoKTtcbiAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24gPSBuZXcgTW91c2VEb3duKHZpZXcsIHBvcywgZXZlbnQsICEhZmx1c2hlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0eXBlID09IFwiZG91YmxlQ2xpY2tcIiA/IGhhbmRsZURvdWJsZUNsaWNrIDogaGFuZGxlVHJpcGxlQ2xpY2spKHZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG59O1xuY2xhc3MgTW91c2VEb3duIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBwb3MsIGV2ZW50LCBmbHVzaGVkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuZmx1c2hlZCA9IGZsdXNoZWQ7XG4gICAgICAgIHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taWdodERyYWcgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZSA9ICEhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXTtcbiAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgICAgbGV0IHRhcmdldE5vZGUsIHRhcmdldFBvcztcbiAgICAgICAgaWYgKHBvcy5pbnNpZGUgPiAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IHBvcy5pbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcyk7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gJHBvcy5wYXJlbnQ7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSAkcG9zLmRlcHRoID8gJHBvcy5iZWZvcmUoKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmx1c2hlZCA/IG51bGwgOiBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldERlc2MgPSB0YXJnZXQgPyB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2ModGFyZ2V0LCB0cnVlKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0RGVzYyAmJiB0YXJnZXREZXNjLmRvbS5ub2RlVHlwZSA9PSAxID8gdGFyZ2V0RGVzYy5kb20gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmXG4gICAgICAgICAgICAoc3RhdGUuc3RvcmVkTWFya3MgfHxcbiAgICAgICAgICAgICAgICAoISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UpKSkpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kb21TZWxlY3Rpb24oKS5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCkpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQrKztcbiAgICAgICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgaWYgKGRlbGF5ID4gLTEpXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZW5kQ29tcG9zaXRpb24odmlldyksIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpO1xuICAgIH1cbiAgICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRleHRCZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZSQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHRBZnRlciA9IHRleHROb2RlQWZ0ZXIkMShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmICh0ZXh0QmVmb3JlICYmIHRleHRBZnRlciAmJiB0ZXh0QmVmb3JlICE9IHRleHRBZnRlcikge1xuICAgICAgICBsZXQgZGVzY0FmdGVyID0gdGV4dEFmdGVyLnBtVmlld0Rlc2MsIGxhc3RDaGFuZ2VkID0gdmlldy5kb21PYnNlcnZlci5sYXN0Q2hhbmdlZFRleHROb2RlO1xuICAgICAgICBpZiAodGV4dEJlZm9yZSA9PSBsYXN0Q2hhbmdlZCB8fCB0ZXh0QWZ0ZXIgPT0gbGFzdENoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdENoYW5nZWQ7XG4gICAgICAgIGlmICghZGVzY0FmdGVyIHx8ICFkZXNjQWZ0ZXIuaXNUZXh0KHRleHRBZnRlci5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlID09IHRleHRBZnRlcikge1xuICAgICAgICAgICAgbGV0IGRlc2NCZWZvcmUgPSB0ZXh0QmVmb3JlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAoISghZGVzY0JlZm9yZSB8fCAhZGVzY0JlZm9yZS5pc1RleHQodGV4dEJlZm9yZS5ub2RlVmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0QmVmb3JlIHx8IHRleHRBZnRlcjtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXA7XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYW5kcm9pZCAmJiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoaW5nU29vbiA+PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgY2xlYXJDb21wb3NpdGlvbih2aWV3KTtcbiAgICBpZiAoZm9yY2VVcGRhdGUgfHwgdmlldy5kb2NWaWV3ICYmIHZpZXcuZG9jVmlldy5kaXJ0eSkge1xuICAgICAgICBsZXQgc2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KTtcbiAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCBkb20pIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHdyYXAgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICB3cmFwLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhkb20pO1xuICAgIC8vIERvbmUgYmVjYXVzZSBJRSB3aWxsIGZpcmUgYSBzZWxlY3Rpb25jaGFuZ2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAvLyB0byBpdHMgc3RhcnQgd2hlbiByZW1vdmVBbGxSYW5nZXMgaXMgY2FsbGVkIGFuZCB0aGUgZWRpdG9yIHN0aWxsXG4gICAgLy8gaGFzIGZvY3VzICh3aGljaCB3aWxsIG1lc3MgdXAgdGhlIGVkaXRvcidzIHNlbGVjdGlvbiBzdGF0ZSkuXG4gICAgdmlldy5kb20uYmx1cigpO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAod3JhcC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgd3JhcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXApO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGllICYmIGllX3ZlcnNpb24gPCAxNSkgfHxcbiAgICAoaW9zICYmIHdlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmhhbmRsZXJzLmNvcHkgPSBlZGl0SGFuZGxlcnMuY3V0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sIGN1dCA9IGV2ZW50LnR5cGUgPT0gXCJjdXRcIjtcbiAgICBpZiAoc2VsLmVtcHR5KVxuICAgICAgICByZXR1cm47XG4gICAgLy8gSUUgYW5kIEVkZ2UncyBjbGlwYm9hcmQgaW50ZXJmYWNlIGlzIGNvbXBsZXRlbHkgYnJva2VuXG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgc2xpY2UgPSBzZWwuY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L2h0bWxcIiwgZG9tLmlubmVySFRNTCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCBkb20pO1xuICAgIH1cbiAgICBpZiAoY3V0KVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcImN1dFwiKSk7XG59O1xuZnVuY3Rpb24gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKSB7XG4gICAgcmV0dXJuIHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMSA/IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCA6IG51bGw7XG59XG5mdW5jdGlvbiBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgcGxhaW5UZXh0ID0gdmlldy5pbnB1dC5zaGlmdEtleSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IHRhcmdldCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChwbGFpblRleHQgPyBcInRleHRhcmVhXCIgOiBcImRpdlwiKSk7XG4gICAgaWYgKCFwbGFpblRleHQpXG4gICAgICAgIHRhcmdldC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgbGV0IHBsYWluID0gdmlldy5pbnB1dC5zaGlmdEtleSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlICE9IDQ1O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIGlmIChwbGFpblRleHQpXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSwgbnVsbCwgcGxhaW4sIGV2ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudGV4dENvbnRlbnQsIHRhcmdldC5pbm5lckhUTUwsIHBsYWluLCBldmVudCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgZXZlbnQpIHtcbiAgICBsZXQgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tKTtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZVBhc3RlXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHkpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFzbGljZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzaW5nbGVOb2RlID0gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKTtcbiAgICBsZXQgdHIgPSBzaW5nbGVOb2RlXG4gICAgICAgID8gdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChzaW5nbGVOb2RlLCBwcmVmZXJQbGFpbilcbiAgICAgICAgOiB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKFwicGFzdGVcIiwgdHJ1ZSkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJwYXN0ZVwiKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRUZXh0KGNsaXBib2FyZERhdGEpIHtcbiAgICBsZXQgdGV4dCA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICBpZiAodGV4dClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgbGV0IHVyaXMgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3VyaS1saXN0XCIpO1xuICAgIHJldHVybiB1cmlzID8gdXJpcy5yZXBsYWNlKC9cXHI/XFxuL2csIFwiIFwiKSA6IFwiXCI7XG59XG5lZGl0SGFuZGxlcnMucGFzdGUgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIC8vIEhhbmRsaW5nIHBhc3RlIGZyb20gSmF2YVNjcmlwdCBkdXJpbmcgY29tcG9zaXRpb24gaXMgdmVyeSBwb29ybHlcbiAgICAvLyBoYW5kbGVkIGJ5IGJyb3dzZXJzLCBzbyBhcyBhIGRvZGd5IGJ1dCBwcmVmZXJhYmxlIGtsdWRnZSwgd2UganVzdFxuICAgIC8vIGxldCB0aGUgYnJvd3NlciBkbyBpdHMgbmF0aXZlIHRoaW5nIHRoZXJlLCBleGNlcHQgb24gQW5kcm9pZCxcbiAgICAvLyB3aGVyZSB0aGUgZWRpdG9yIGlzIGFsbW9zdCBhbHdheXMgY29tcG9zaW5nLlxuICAgIGlmICh2aWV3LmNvbXBvc2luZyAmJiAhYW5kcm9pZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHBsYWluID0gdmlldy5pbnB1dC5zaGlmdEtleSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlICE9IDQ1O1xuICAgIGlmIChkYXRhICYmIGRvUGFzdGUodmlldywgZ2V0VGV4dChkYXRhKSwgZGF0YS5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBwbGFpbiwgZXZlbnQpKVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVsc2VcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KTtcbn07XG5jbGFzcyBEcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3Ioc2xpY2UsIG1vdmUsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLm1vdmUgPSBtb3ZlO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbn1cbmNvbnN0IGRyYWdDb3B5TW9kaWZpZXIgPSBtYWMgPyBcImFsdEtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBtb3VzZURvd24gPSB2aWV3LmlucHV0Lm1vdXNlRG93bjtcbiAgICBpZiAobW91c2VEb3duKVxuICAgICAgICBtb3VzZURvd24uZG9uZSgpO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwb3MgPSBzZWwuZW1wdHkgPyBudWxsIDogdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChwb3MgJiYgcG9zLnBvcyA+PSBzZWwuZnJvbSAmJiBwb3MucG9zIDw9IChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uID8gc2VsLnRvIC0gMSA6IHNlbC50bykpIDtcbiAgICBlbHNlIGlmIChtb3VzZURvd24gJiYgbW91c2VEb3duLm1pZ2h0RHJhZykge1xuICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIGRlc2MgIT0gdmlldy5kb2NWaWV3KVxuICAgICAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSk7XG4gICAgfVxuICAgIGxldCBkcmFnZ2VkU2xpY2UgPSAobm9kZSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbikuY29udGVudCgpO1xuICAgIGxldCB7IGRvbSwgdGV4dCwgc2xpY2UgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBkcmFnZ2VkU2xpY2UpO1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzExNTZcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSlcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoc2xpY2UsICFldmVudFtkcmFnQ29weU1vZGlmaWVyXSwgbm9kZSk7XG59O1xuaGFuZGxlcnMuZHJhZ2VuZCA9IHZpZXcgPT4ge1xuICAgIGxldCBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5kcmFnZ2luZyA9PSBkcmFnZ2luZylcbiAgICAgICAgICAgIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIH0sIDUwKTtcbn07XG5lZGl0SGFuZGxlcnMuZHJhZ292ZXIgPSBlZGl0SGFuZGxlcnMuZHJhZ2VudGVyID0gKF8sIGUpID0+IGUucHJldmVudERlZmF1bHQoKTtcbmVkaXRIYW5kbGVycy5kcm9wID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGV2ZW50UG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghZXZlbnRQb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJG1vdXNlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShldmVudFBvcy5wb3MpO1xuICAgIGxldCBzbGljZSA9IGRyYWdnaW5nICYmIGRyYWdnaW5nLnNsaWNlO1xuICAgIGlmIChzbGljZSkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIGdldFRleHQoZXZlbnQuZGF0YVRyYW5zZmVyKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgICB9XG4gICAgbGV0IG1vdmUgPSAhIShkcmFnZ2luZyAmJiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgICAgbGV0IHsgbm9kZSB9ID0gZHJhZ2dpbmc7XG4gICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgbm9kZS5yZXBsYWNlKHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c+KAlHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgV2lkZ2V0VHlwZTsgfVxufVxuY29uc3Qgbm9uZSA9IFtdLCBub1NwZWMgPSB7fTtcbi8qKlxuQSBjb2xsZWN0aW9uIG9mIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbiksIG9yZ2FuaXplZCBpbiBzdWNoXG5hIHdheSB0aGF0IHRoZSBkcmF3aW5nIGFsZ29yaXRobSBjYW4gZWZmaWNpZW50bHkgdXNlIGFuZCBjb21wYXJlXG50aGVtLiBUaGlzIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzIG5vdCBtb2RpZmllZCxcbnVwZGF0ZXMgY3JlYXRlIGEgbmV3IHZhbHVlLlxuKi9cbmNsYXNzIERlY29yYXRpb25TZXQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbiA6IG5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucywgdXNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gVGhpcyB3aWxsIGNvbnN1bWUgKG1vZGlmeSkgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXksIHNvXG4gICAgeW91IG11c3QgbWFrZSBhIGNvcHkgaWYgeW91IHdhbnQgbmVlZCB0byBwcmVzZXJ2ZSB0aGF0LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIENvbnN1bWVzIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LiBOZWVkc1xuICAgIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRyZWVcbiAgICBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBjaGlsZCwgbG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVjID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChkZWMuZnJvbSA8IGVuZCAmJiBkZWMudG8gPiBzdGFydCAmJiAoZGVjLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgIChsb2NhbCB8fCAobG9jYWwgPSBbXSkpLnB1c2goZGVjLmNvcHkoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIGxldCBsb2NhbFNldCA9IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLnNvcnQoYnlQb3MpLCBub25lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09IG90aGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgfHxcbiAgICAgICAgICAgIHRoaXMubG9jYWwubGVuZ3RoICE9IG90aGVyLmxvY2FsLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggIT0gb3RoZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYWxbaV0uZXEob3RoZXIubG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gIT0gb3RoZXIuY2hpbGRyZW5baV0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAxXSAhPSBvdGhlci5jaGlsZHJlbltpICsgMV0gfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5jaGlsZHJlbltpICsgMl0uZXEob3RoZXIuY2hpbGRyZW5baSArIDJdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVPdmVybGFwKHRoaXMubG9jYWxzSW5uZXIobm9kZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fsc0lubmVyKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbm9uZTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudCB8fCAhdGhpcy5sb2NhbC5zb21lKElubGluZVR5cGUuaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWw7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxvY2FsW2ldLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uU2V0LmVtcHR5ID0gbmV3IERlY29yYXRpb25TZXQoW10sIFtdKTtcbi8qKlxuQGludGVybmFsXG4qL1xuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcbmNvbnN0IGVtcHR5ID0gRGVjb3JhdGlvblNldC5lbXB0eTtcbi8vIEFuIGFic3RyYWN0aW9uIHRoYXQgYWxsb3dzIHRoZSBjb2RlIGRlYWxpbmcgd2l0aCBkZWNvcmF0aW9ucyB0b1xuLy8gdHJlYXQgbXVsdGlwbGUgRGVjb3JhdGlvblNldCBvYmplY3RzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUgb2JqZWN0XG4vLyB3aXRoIChhIHN1YnNldCBvZikgdGhlIHNhbWUgaW50ZXJmYWNlLlxuY2xhc3MgRGVjb3JhdGlvbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBkb2MpIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGVjb3MgPSB0aGlzLm1lbWJlcnMubWFwKG1lbWJlciA9PiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShtYXBwZWREZWNvcyk7XG4gICAgfVxuICAgIGZvckNoaWxkKG9mZnNldCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKSB8fFxuICAgICAgICAgICAgb3RoZXIubWVtYmVycy5sZW5ndGggIT0gdGhpcy5tZW1iZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICBsZXQgcmVzdWx0LCBzb3J0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxvY2FscyA9IHRoaXMubWVtYmVyc1tpXS5sb2NhbHNJbm5lcihub2RlKTtcbiAgICAgICAgICAgIGlmICghbG9jYWxzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbG9jYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsb2NhbHNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZW1vdmVPdmVybGFwKHNvcnRlZCA/IHJlc3VsdCA6IHJlc3VsdC5zb3J0KGJ5UG9zKSkgOiBub25lO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBncm91cCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb24gc2V0cywgb3IgcmV0dXJuXG4gICAgLy8gYSBzaW5nbGUgc2V0IHdoZW4gcG9zc2libGUuXG4gICAgc3RhdGljIGZyb20obWVtYmVycykge1xuICAgICAgICBzd2l0Y2ggKG1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBlbXB0eTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG1lbWJlcnNbMF07XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzLmV2ZXJ5KG0gPT4gbSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpID8gbWVtYmVycyA6XG4gICAgICAgICAgICAgICAgbWVtYmVycy5yZWR1Y2UoKHIsIG0pID0+IHIuY29uY2F0KG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0ID8gbSA6IG0ubWVtYmVycyksIFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gb2xkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICAvLyBNYXJrIHRoZSBjaGlsZHJlbiB0aGF0IGFyZSBkaXJlY3RseSB0b3VjaGVkIGJ5IGNoYW5nZXMsIGFuZFxuICAgIC8vIG1vdmUgdGhvc2UgdGhhdCBhcmUgYWZ0ZXIgdGhlIGNoYW5nZXMuXG4gICAgZm9yIChsZXQgaSA9IDAsIGJhc2VPZmZzZXQgPSBvbGRPZmZzZXQ7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgbWFwcGluZy5tYXBzW2ldLmZvckVhY2goKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpID0+IHtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IChuZXdFbmQgLSBuZXdTdGFydCkgLSAob2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8IDAgfHwgb2xkU3RhcnQgPiBlbmQgKyBiYXNlT2Zmc2V0IC0gbW92ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGNoaWxkcmVuW2ldICsgYmFzZU9mZnNldCAtIG1vdmVkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbmQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gb2xkU3RhcnQgPD0gc3RhcnQgPyAtMiA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGFydCA+PSBiYXNlT2Zmc2V0ICYmIGRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZWQgKz0gZFNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlT2Zmc2V0ID0gbWFwcGluZy5tYXBzW2ldLm1hcChiYXNlT2Zmc2V0LCAtMSk7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGNoaWxkIG5vZGVzIHRoYXQgc3RpbGwgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBub2RlLFxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgbWFwSW5uZXIgb24gdGhlbSBhbmQgdXBkYXRlIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBsZXQgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkgeyAvLyBUb3VjaGVkIG5vZGVzXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0yKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZnJvbUxvY2FsIDwgMCB8fCBmcm9tTG9jYWwgPj0gbm9kZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICAgICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2kgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0OiBjaGlsZE9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChmcm9tTG9jYWwpO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoaWxkcmVuW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gZnJvbUxvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSB0b0xvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFJlbWFpbmluZyBjaGlsZHJlbiBtdXN0IGJlIGNvbGxlY3RlZCBhbmQgcmVidWlsdCBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmVcbiAgICBpZiAobXVzdFJlYnVpbGQpIHtcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgYnVpbHQgPSBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIG5vZGUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBuZXdMb2NhbCA9IGJ1aWx0LmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBidWlsdC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWlsdC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2pdIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAxXSwgYnVpbHQuY2hpbGRyZW5baSArIDJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIG1vdmVTcGFucyhzcGFucywgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNwYW5zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHNwYW5zO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEZWNvcmF0aW9uKHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCwgc3Bhbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGRlY29yYXRpb25zLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICAgIGZ1bmN0aW9uIGdhdGhlcihzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUoc2V0LmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgZ2F0aGVyKHNldC5jaGlsZHJlbltpICsgMl0sIHNldC5jaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0xKVxuICAgICAgICAgICAgZ2F0aGVyKGNoaWxkcmVuW2kgKyAyXSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5mdW5jdGlvbiB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKHNwYW4gPSBzcGFuc1tpXSkgJiYgc3Bhbi5mcm9tID4gb2Zmc2V0ICYmIHNwYW4udG8gPCBlbmQpIHtcbiAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICBzcGFuc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gd2l0aG91dE51bGxzKGFycmF5KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSAhPSBudWxsKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBCdWlsZCB1cCBhIHRyZWUgdGhhdCBjb3JyZXNwb25kcyB0byBhIHNldCBvZiBkZWNvcmF0aW9ucy4gYG9mZnNldGBcbi8vIGlzIGEgYmFzZSBvZmZzZXQgdGhhdCBzaG91bGQgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBgZnJvbWAgYW5kIGB0b2Bcbi8vIHBvc2l0aW9ucyBpbiB0aGUgc3BhbnMgKHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBhbGxvY2F0ZSBuZXcgc3BhbnNcbi8vIGZvciByZWN1cnNpdmUgY2FsbHMpLlxuZnVuY3Rpb24gYnVpbGRUcmVlKHNwYW5zLCBub2RlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgaGFzTnVsbHMgPSBmYWxzZTtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBjaGlsZE5vZGUsIGxvY2FsU3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIGhhc051bGxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzdWJ0cmVlID0gYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIG9mZnNldCArIGxvY2FsU3RhcnQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlICE9IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobG9jYWxTdGFydCwgbG9jYWxTdGFydCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgc3VidHJlZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbG9jYWxzID0gbW92ZVNwYW5zKGhhc051bGxzID8gd2l0aG91dE51bGxzKHNwYW5zKSA6IHNwYW5zLCAtb2Zmc2V0KS5zb3J0KGJ5UG9zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2Fscy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFsb2NhbHNbaV0udHlwZS52YWxpZChub2RlLCBsb2NhbHNbaV0pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKGxvY2Fsc1tpXS5zcGVjKTtcbiAgICAgICAgICAgIGxvY2Fscy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBsb2NhbHMubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FscywgY2hpbGRyZW4pIDogZW1wdHk7XG59XG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudG8gLSBiLnRvO1xufVxuLy8gU2NhbiBhIHNvcnRlZCBhcnJheSBvZiBkZWNvcmF0aW9ucyBmb3IgcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zLFxuLy8gYW5kIHNwbGl0IHRob3NlIHNvIHRoYXQgb25seSBmdWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgbGVmdCAodG9cbi8vIG1ha2Ugc3Vic2VxdWVudCByZW5kZXJpbmcgZWFzaWVyKS4gV2lsbCByZXR1cm4gdGhlIGlucHV0IGFycmF5IGlmXG4vLyBubyBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGZvdW5kICh0aGUgY29tbW9uIGNhc2UpLlxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcChzcGFucykge1xuICAgIGxldCB3b3JraW5nID0gc3BhbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHdvcmtpbmdbaV07XG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gc3Bhbi50bylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHdvcmtpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHdvcmtpbmdbal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xsb3dlZCBieSBhIHBhcnRpYWxseSBvdmVybGFwcGluZyBsYXJnZXIgc3Bhbi4gU3BsaXQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Bhbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGogKyAxLCBuZXh0LmNvcHkoc3Bhbi50bywgbmV4dC50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGlzIG9uZSBvdmVybGFwcyB3aXRoIGEgc3Vic2VxdWVudCBzcGFuLiBTcGxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGosIHNwYW4uY29weShuZXh0LmZyb20sIHNwYW4udG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JraW5nO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWhlYWQoYXJyYXksIGksIGRlY28pIHtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKVxuICAgICAgICBpKys7XG4gICAgYXJyYXkuc3BsaWNlKGksIDAsIGRlY28pO1xufVxuLy8gR2V0IHRoZSBkZWNvcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcHJvcHMgb2YgYSB2aWV3LlxuZnVuY3Rpb24gdmlld0RlY29yYXRpb25zKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiZGVjb3JhdGlvbnNcIiwgZiA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCAhPSBlbXB0eSlcbiAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgICAgICBmb3VuZC5wdXNoKERlY29yYXRpb25TZXQuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBbdmlldy5jdXJzb3JXcmFwcGVyLmRlY29dKSk7XG4gICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXG5jb25zdCB1c2VDaGFyRGF0YSA9IGllICYmIGllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgc2V0KHNlbCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVxKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5hbmNob3JOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT0gdGhpcy5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgPT0gdGhpcy5mb2N1c05vZGUgJiYgc2VsLmZvY3VzT2Zmc2V0ID09IHRoaXMuZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhhbmRsZURPTUNoYW5nZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZSA9IGhhbmRsZURPTUNoYW5nZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgJiZcbiAgICAgICAgICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCBub2RlIGFmdGVyIGEgQlIgbm9kZSkgY2FsbCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTSwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGUudGFyZ2V0LCB0eXBlOiBcImNoYXJhY3RlckRhdGFcIiwgb2xkVmFsdWU6IGUucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uIDwgMClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmZsdXNoaW5nU29vbiA9IC0xOyB0aGlzLmZsdXNoKCk7IH0sIDIwKTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5mbHVzaGluZ1Nvb24pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXcuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmNvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCB0YWtlID0gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFrZVtpXSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2UsIDUwKTtcbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIGlmICghaGFzRm9jdXNBbmRTZWxlY3Rpb24odGhpcy52aWV3KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMudmlldyk7XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRVxuICAgICAgICAgICAgaWYgKHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBzZXRDdXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpO1xuICAgIH1cbiAgICBpZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKSB7XG4gICAgICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgYW5jZXN0b3JzID0gbmV3IFNldCwgY29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmZvY3VzTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBhbmNlc3RvcnMuYWRkKHNjYW4pO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmFuY2hvck5vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgaWYgKGFuY2VzdG9ycy5oYXMoc2NhbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzY2FuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IGNvbnRhaW5lciAmJiB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjb250YWluZXIpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLmlnbm9yZU11dGF0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbnRhaW5lci5ub2RlVHlwZSA9PSAzID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXJcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpXG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmICghdmlldy5kb2NWaWV3IHx8IHRoaXMuZmx1c2hpbmdTb29uID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtdXRhdGlvbnMgPSB0aGlzLnBlbmRpbmdSZWNvcmRzKCk7XG4gICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3U2VsID0gIXRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzICYmICF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSAmJiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSAmJiAhdGhpcy5pZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgICAgICAgaWYgKHZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVnaXN0ZXJNdXRhdGlvbihtdXRhdGlvbnNbaV0sIGFkZGVkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBmcm9tIDwgMCA/IHJlc3VsdC5mcm9tIDogTWF0aC5taW4ocmVzdWx0LmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdC50byA6IE1hdGgubWF4KHJlc3VsdC50bywgdG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2Vja28gJiYgYWRkZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYnJzID0gYWRkZWQuZmlsdGVyKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkJSXCIpO1xuICAgICAgICAgICAgaWYgKGJycy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBbYSwgYl0gPSBicnM7XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZm9jdXNOb2RlIH0gPSB0aGlzLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYnIgb2YgYnJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBici5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PSBcIkxJXCIgJiYgKCFmb2N1c05vZGUgfHwgYmxvY2tQYXJlbnQodmlldywgZm9jdXNOb2RlKSAhPSBwYXJlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG11dC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGxldCBhbmNob3JOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSByYW5nZS5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gYmxvY2tQYXJlbnQodmlldywgbm9kZSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudE5vZGU7IHAgJiYgcCAhPSB2aWV3LmRvbTsgcCA9IHAucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhwLCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE5vdGUgdGhhdCBhbGwgcmVmZXJlbmNpbmcgYW5kIHBhcnNpbmcgaXMgZG9uZSB3aXRoIHRoZVxuLy8gc3RhcnQtb2Ytb3BlcmF0aW9uIHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQsIHNpbmNlIHRoYXQncyB0aGUgb25lXG4vLyB0aGF0IHRoZSBET00gcmVwcmVzZW50cy4gSWYgYW55IGNoYW5nZXMgY2FtZSBpbiBpbiB0aGUgbWVhbnRpbWUsXG4vLyB0aGUgbW9kaWZpY2F0aW9uIGlzIG1hcHBlZCBvdmVyIHRob3NlIGJlZm9yZSBpdCBpcyBhcHBsaWVkLCBpblxuLy8gcmVhZERPTUNoYW5nZS5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gICAgbGV0IHsgbm9kZTogcGFyZW50LCBmcm9tT2Zmc2V0LCB0b09mZnNldCwgZnJvbSwgdG8gfSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGZpbmQ7XG4gICAgbGV0IGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgZmluZCA9IFt7IG5vZGU6IGFuY2hvciwgb2Zmc2V0OiBkb21TZWwuYW5jaG9yT2Zmc2V0IH1dO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgICAgICAgZmluZC5wdXNoKHsgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSwgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXQgfSk7XG4gICAgfVxuICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIGluIENocm9tZSB3aGVyZSBiYWNrc3BhY2luZyBzb21ldGltZXMgcmVwbGFjZXNcbiAgICAvLyB0aGUgZGVsZXRlZCBjb250ZW50IHdpdGggYSByYW5kb20gQlIgbm9kZSAoaXNzdWVzICM3OTksICM4MzEpXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykge1xuICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0ICRmcm9tID0gc3RhcnREb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2VsID0gbnVsbCwgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgICAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgICAgIHRvcE1hdGNoOiAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSksXG4gICAgICAgIHRvcE9wZW46IHRydWUsXG4gICAgICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgICAgIHRvOiB0b09mZnNldCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgICAgIHJ1bGVGcm9tTm9kZSxcbiAgICAgICAgY29udGV4dDogJGZyb21cbiAgICB9KTtcbiAgICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBmaW5kWzBdLnBvcywgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgICAgIGlmIChoZWFkID09IG51bGwpXG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yO1xuICAgICAgICBzZWwgPSB7IGFuY2hvcjogYW5jaG9yICsgZnJvbSwgaGVhZDogaGVhZCArIGZyb20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9jLCBzZWwsIGZyb20sIHRvIH07XG59XG5mdW5jdGlvbiBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICBpZiAoZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy5wYXJzZVJ1bGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgcmVwbGFjZXMgdGhlIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsIHdpdGggYSBCUlxuICAgICAgICAvLyBkaXJlY3RseSBpbiB0aGUgbGlzdCBub2RlICg/ISkgaWYgeW91IGRlbGV0ZSB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICAgICAgaWYgKHNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNraXAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT0gZG9tIHx8IHNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzSW5saW5lID0gL14oYXxhYmJyfGFjcm9ueW18YnxiZFtpb118YmlnfGJyfGJ1dHRvbnxjaXRlfGNvZGV8ZGF0YShsaXN0KT98ZGVsfGRmbnxlbXxpfGluc3xrYmR8bGFiZWx8bWFwfG1hcmt8bWV0ZXJ8b3V0cHV0fHF8cnVieXxzfHNhbXB8c21hbGx8c3BhbnxzdHJvbmd8c3VbYnBdfHRpbWV8dXx0dHx2YXIpJC9pO1xuZnVuY3Rpb24gcmVhZERPTUNoYW5nZSh2aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkTm9kZXMpIHtcbiAgICBsZXQgY29tcG9zaXRpb25JRCA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyB8fCAodmlldy5jb21wb3NpbmcgPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwKTtcbiAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBsZXQgb3JpZ2luID0gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCA/IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA6IG51bGw7XG4gICAgICAgIGxldCBuZXdTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbik7XG4gICAgICAgIGlmIChuZXdTZWwgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKG5ld1NlbCkpIHtcbiAgICAgICAgICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJlxuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDEzICYmIERhdGUubm93KCkgLSAxMDAgPCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ld1NlbCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luID09IFwia2V5XCIpXG4gICAgICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0ICRiZWZvcmUgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzaGFyZWQgPSAkYmVmb3JlLnNoYXJlZERlcHRoKHRvKTtcbiAgICBmcm9tID0gJGJlZm9yZS5iZWZvcmUoc2hhcmVkICsgMSk7XG4gICAgdG8gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRvKS5hZnRlcihzaGFyZWQgKyAxKTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBhcnNlID0gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb20sIHRvKTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2MsIGNvbXBhcmUgPSBkb2Muc2xpY2UocGFyc2UuZnJvbSwgcGFyc2UudG8pO1xuICAgIGxldCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGU7XG4gICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZFxuICAgIGlmICh2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4ICYmIERhdGUubm93KCkgLSAxMDAgPCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSkge1xuICAgICAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJzdGFydFwiO1xuICAgIH1cbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICBsZXQgY2hhbmdlID0gZmluZERpZmYoY29tcGFyZS5jb250ZW50LCBwYXJzZS5kb2MuY29udGVudCwgcGFyc2UuZnJvbSwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKTtcbiAgICBpZiAoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgfHwgYW5kcm9pZCkgJiZcbiAgICAgICAgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlVHlwZSA9PSAxICYmICFpc0lubGluZS50ZXN0KG4ubm9kZU5hbWUpKSAmJlxuICAgICAgICAoIWNoYW5nZSB8fCBjaGFuZ2UuZW5kQSA+PSBjaGFuZ2UuZW5kQikgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmXG4gICAgICAgICAgICAhdmlldy5jb21wb3NpbmcgJiYgIShwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciAhPSBwYXJzZS5zZWwuaGVhZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgc3RhcnQ6IHNlbC5mcm9tLCBlbmRBOiBzZWwudG8sIGVuZEI6IHNlbC50byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50Kys7XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIG92ZXJ3cml0aW5nIGEgc2VsZWN0aW9uIGJ5IHR5cGluZyBtYXRjaGVzXG4gICAgLy8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgc2VsZWN0ZWQgY29udGVudCwgY3JlYXRpbmcgYSBjaGFuZ2VcbiAgICAvLyB0aGF0J3Mgc21hbGxlciB0aGFuIHdoYXQgd2FzIGFjdHVhbGx5IG92ZXJ3cml0dGVuLlxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiZcbiAgICAgICAgY2hhbmdlLnN0YXJ0ID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAoY2hhbmdlLnN0YXJ0ID4gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAmJiBjaGFuZ2Uuc3RhcnQgPD0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPj0gcGFyc2UuZnJvbSkge1xuICAgICAgICAgICAgY2hhbmdlLnN0YXJ0ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UuZW5kQSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmIGNoYW5nZS5lbmRBID49IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPD0gcGFyc2UudG8pIHtcbiAgICAgICAgICAgIGNoYW5nZS5lbmRCICs9ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIGNoYW5nZS5lbmRBKTtcbiAgICAgICAgICAgIGNoYW5nZS5lbmRBID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSUUxMSB3aWxsIGluc2VydCBhIG5vbi1icmVha2luZyBzcGFjZSBfYWhlYWRfIG9mIHRoZSBzcGFjZSBhZnRlclxuICAgIC8vIHRoZSBjdXJzb3Igc3BhY2Ugd2hlbiBhZGRpbmcgYSBzcGFjZSBiZWZvcmUgYW5vdGhlciBzcGFjZS4gV2hlblxuICAgIC8vIHRoYXQgaGFwcGVuZWQsIGFkanVzdCB0aGUgY2hhbmdlIHRvIGNvdmVyIHRoZSBzcGFjZSBpbnN0ZWFkLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydCArIDEgJiZcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLnN0YXJ0ICYmIGNoYW5nZS5zdGFydCA+IHBhcnNlLmZyb20gJiZcbiAgICAgICAgcGFyc2UuZG9jLnRleHRCZXR3ZWVuKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gLSAxLCBjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tICsgMSkgPT0gXCIgXFx1MDBhMFwiKSB7XG4gICAgICAgIGNoYW5nZS5zdGFydC0tO1xuICAgICAgICBjaGFuZ2UuZW5kQS0tO1xuICAgICAgICBjaGFuZ2UuZW5kQi0tO1xuICAgIH1cbiAgICBsZXQgJGZyb20gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkZnJvbUEgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpO1xuICAgIGxldCBpbmxpbmVDaGFuZ2UgPSAkZnJvbS5zYW1lUGFyZW50KCR0bykgJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJGZyb21BLmVuZCgpID49IGNoYW5nZS5lbmRBO1xuICAgIGxldCBuZXh0U2VsO1xuICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSB0aGUgZWZmZWN0IG9mIHByZXNzaW5nIEVudGVyIChvciB3YXMgcmVjb3JkZWRcbiAgICAvLyBhcyBiZWluZyBhbiBpT1MgZW50ZXIgcHJlc3MpLCBqdXN0IGRpc3BhdGNoIGFuIEVudGVyIGtleSBpbnN0ZWFkLlxuICAgIGlmICgoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgJiZcbiAgICAgICAgKCFpbmxpbmVDaGFuZ2UgfHwgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkRJVlwiIHx8IG4ubm9kZU5hbWUgPT0gXCJQXCIpKSkgfHxcbiAgICAgICAgKCFpbmxpbmVDaGFuZ2UgJiYgJGZyb20ucG9zIDwgcGFyc2UuZG9jLmNvbnRlbnQuc2l6ZSAmJiAhJGZyb20uc2FtZVBhcmVudCgkdG8pICYmXG4gICAgICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgICAgICBuZXh0U2VsLmhlYWQgPT0gJHRvLnBvcykpICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKSB7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTYW1lIGZvciBiYWNrc3BhY2VcbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID4gY2hhbmdlLnN0YXJ0ICYmXG4gICAgICAgIGxvb2tzTGlrZUJhY2tzcGFjZShkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKSB7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IC8vICM4MjBcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IHRyLCBzdG9yZWRNYXJrcywgbWFya0NoYW5nZTtcbiAgICBpZiAoaW5saW5lQ2hhbmdlKSB7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykgeyAvLyBEZWxldGlvblxuICAgICAgICAgICAgLy8gSUUxMSBzb21ldGltZXMgd2VpcmRseSBtb3ZlcyB0aGUgRE9NIHNlbGVjdGlvbiBhcm91bmQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHRleHRibG9ja1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odmlldyksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5kZWxldGUoY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgICAgIHN0b3JlZE1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAvLyBBZGRpbmcgb3IgcmVtb3ZpbmcgYSBtYXJrXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBvc2l0aW9ucyBpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgLS0gc2ltcGx5IGluc2VydCB0ZXh0XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIGNoRnJvbSwgY2hUbywgdGV4dCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cilcbiAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG4gICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIGFuZHJvaWQgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkTWFya3MpXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUJhY2tzcGFjZShvbGQsIHN0YXJ0LCBlbmQsICRuZXdTdGFydCwgJG5ld0VuZCkge1xuICAgIGlmICggLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgIGVuZCAtIHN0YXJ0IDw9ICRuZXdFbmQucG9zIC0gJG5ld1N0YXJ0LnBvcyB8fFxuICAgICAgICAvLyBuZXdFbmQgbXVzdCBwb2ludCBkaXJlY3RseSBhdCBvciBhZnRlciB0aGUgZW5kIG9mIHRoZSBibG9jayB0aGF0IG5ld1N0YXJ0IHBvaW50cyBpbnRvXG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV3U3RhcnQsIHRydWUsIGZhbHNlKSA8ICRuZXdFbmQucG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRzdGFydCA9IG9sZC5yZXNvbHZlKHN0YXJ0KTtcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUsIHJhdGhlciB0aGFuIGpvaW5pbmcgYmxvY2tzLCB0aGUgY2hhbmdlIGp1c3QgcmVtb3ZlZCBhbiBlbnRpcmUgYmxvY2tcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgbGV0IGFmdGVyID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyICE9IG51bGwgJiYgZW5kID09IHN0YXJ0ICsgYWZ0ZXIubm9kZVNpemU7XG4gICAgfVxuICAgIC8vIFN0YXJ0IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBhIGJsb2NrXG4gICAgaWYgKCRzdGFydC5wYXJlbnRPZmZzZXQgPCAkc3RhcnQucGFyZW50LmNvbnRlbnQuc2l6ZSB8fCAhJHN0YXJ0LnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkbmV4dCA9IG9sZC5yZXNvbHZlKHNraXBDbG9zaW5nQW5kT3BlbmluZygkc3RhcnQsIHRydWUsIHRydWUpKTtcbiAgICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICAgIGlmICghJG5leHQucGFyZW50LmlzVGV4dGJsb2NrIHx8ICRuZXh0LnBvcyA+IGVuZCB8fFxuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5leHQsIHRydWUsIGZhbHNlKSA8IGVuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFRoZSBmcmFnbWVudHMgYWZ0ZXIgdGhlIGpvaW4gcG9pbnQgbXVzdCBtYXRjaFxuICAgIHJldHVybiAkbmV3U3RhcnQucGFyZW50LmNvbnRlbnQuY3V0KCRuZXdTdGFydC5wYXJlbnRPZmZzZXQpLmVxKCRuZXh0LnBhcmVudC5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aCwgZW5kID0gZnJvbUVuZCA/ICRwb3MuZW5kKCkgOiAkcG9zLnBvcztcbiAgICB3aGlsZSAoZGVwdGggPiAwICYmIChmcm9tRW5kIHx8ICRwb3MuaW5kZXhBZnRlcihkZXB0aCkgPT0gJHBvcy5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBlbmQrKztcbiAgICAgICAgZnJvbUVuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWF5T3Blbikge1xuICAgICAgICBsZXQgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuaXNMZWFmKSB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHBvcywgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gYS5maW5kRGlmZlN0YXJ0KGIsIHBvcyk7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGE6IGVuZEEsIGI6IGVuZEIgfSA9IGEuZmluZERpZmZFbmQoYiwgcG9zICsgYS5zaXplLCBwb3MgKyBiLnNpemUpO1xuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gTWF0aC5taW4oZW5kQSwgZW5kQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gZW5kQSArIGFkanVzdCAtIHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQSA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYi5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihiLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRCID0gc3RhcnQgKyAoZW5kQiAtIGVuZEEpO1xuICAgICAgICBlbmRBID0gc3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYS5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihhLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRBID0gc3RhcnQgKyAoZW5kQSAtIGVuZEIpO1xuICAgICAgICBlbmRCID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmRBLCBlbmRCIH07XG59XG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggIT0gMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhID0gc3RyLmNoYXJDb2RlQXQoMCksIGIgPSBzdHIuY2hhckNvZGVBdCgxKTtcbiAgICByZXR1cm4gYSA+PSAweERDMDAgJiYgYSA8PSAweERGRkYgJiYgYiA+PSAweEQ4MDAgJiYgYiA8PSAweERCRkY7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19zZXJpYWxpemVGb3JDbGlwYm9hcmQgPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fcGFyc2VGcm9tQ2xpcGJvYXJkID0gcGFyc2VGcm9tQ2xpcGJvYXJkO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX2VuZENvbXBvc2l0aW9uID0gZW5kQ29tcG9zaXRpb247XG4vKipcbkFuIGVkaXRvciB2aWV3IG1hbmFnZXMgdGhlIERPTSBzdHJ1Y3R1cmUgdGhhdCByZXByZXNlbnRzIGFuXG5lZGl0YWJsZSBkb2N1bWVudC4gSXRzIHN0YXRlIGFuZCBiZWhhdmlvciBhcmUgZGV0ZXJtaW5lZCBieSBpdHNcbltwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0RWRpdG9yUHJvcHMpLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHZpZXcuIGBwbGFjZWAgbWF5IGJlIGEgRE9NIG5vZGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZFxuICAgIGJlIGFwcGVuZGVkIHRvLCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwbGFjZSBpdCBpbnRvIHRoZSBkb2N1bWVudCxcbiAgICBvciBhbiBvYmplY3Qgd2hvc2UgYG1vdW50YCBwcm9wZXJ0eSBob2xkcyB0aGUgbm9kZSB0byB1c2UgYXMgdGhlXG4gICAgZG9jdW1lbnQgY29udGFpbmVyLiBJZiBpdCBpcyBgbnVsbGAsIHRoZSBlZGl0b3Igd2lsbCBub3QgYmVcbiAgICBhZGRlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwbGFjZSwgcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBLbHVkZ2UgdXNlZCB0byB3b3JrIGFyb3VuZCBhIENocm9tZSBidWcgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tXcml0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlucHV0ID0gbmV3IElucHV0U3RhdGU7XG4gICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5WaWV3cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgSG9sZHMgYHRydWVgIHdoZW4gYSBoYWNrIG5vZGUgaXMgbmVlZGVkIGluIEZpcmVmb3ggdG8gcHJldmVudCB0aGVcbiAgICAgICAgW3NwYWNlIGlzIGVhdGVuIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzY1MSlcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWlyZXNHZWNrb0hhY2tOb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaGVuIGVkaXRvciBjb250ZW50IGlzIGJlaW5nIGRyYWdnZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zXG4gICAgICAgIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnZ2VkIHNsaWNlIGFuZCB3aGV0aGVyIGl0IGlzIGJlaW5nXG4gICAgICAgIGNvcGllZCBvciBtb3ZlZC4gQXQgYW55IG90aGVyIHRpbWUsIGl0IGlzIG51bGwuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnMgfHwgW107XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbSA9IChwbGFjZSAmJiBwbGFjZS5tb3VudCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHBsYWNlKSB7XG4gICAgICAgICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpXG4gICAgICAgICAgICAgICAgcGxhY2UuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBsYWNlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBwbGFjZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChwbGFjZS5tb3VudClcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2ModGhpcy5zdGF0ZS5kb2MsIGNvbXB1dGVEb2NEZWNvKHRoaXMpLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzLCAoZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkgPT4gcmVhZERPTUNoYW5nZSh0aGlzLCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgaW5pdElucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEhvbGRzIGB0cnVlYCB3aGVuIGFcbiAgICBbY29tcG9zaXRpb25dKGh0dHBzOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzKVxuICAgIGlzIGFjdGl2ZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0LmNvbXBvc2luZzsgfVxuICAgIC8qKlxuICAgIFRoZSB2aWV3J3MgY3VycmVudCBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKS5cbiAgICAqL1xuICAgIGdldCBwcm9wcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3BzLnN0YXRlICE9IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5fcHJvcHM7XG4gICAgICAgICAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW25hbWVdID0gcHJldltuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldydzIHByb3BzLiBXaWxsIGltbWVkaWF0ZWx5IGNhdXNlIGFuIHVwZGF0ZSB0b1xuICAgIHRoZSBET00uXG4gICAgKi9cbiAgICB1cGRhdGUocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpXG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGxldCBwcmV2UHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKHByb3BzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHByb3BzLnBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHByb3BzLnN0YXRlLCBwcmV2UHJvcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgYnkgdXBkYXRpbmcgZXhpc3RpbmcgcHJvcHMgb2JqZWN0IHdpdGggdGhlIG9iamVjdFxuICAgIGdpdmVuIGFzIGFyZ3VtZW50LiBFcXVpdmFsZW50IHRvIGB2aWV3LnVwZGF0ZShPYmplY3QuYXNzaWduKHt9LFxuICAgIHZpZXcucHJvcHMsIHByb3BzKSlgLlxuICAgICovXG4gICAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9wcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSB0aGlzLl9wcm9wc1tuYW1lXTtcbiAgICAgICAgdXBkYXRlZC5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gcHJvcHNbbmFtZV07XG4gICAgICAgIHRoaXMudXBkYXRlKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIGVkaXRvcidzIGBzdGF0ZWAgcHJvcCwgd2l0aG91dCB0b3VjaGluZyBhbnkgb2YgdGhlXG4gICAgb3RoZXIgcHJvcHMuXG4gICAgKi9cbiAgICB1cGRhdGVTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHRoaXMuX3Byb3BzKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgcHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YXRlLCByZWRyYXcgPSBmYWxzZSwgdXBkYXRlU2VsID0gZmFsc2U7XG4gICAgICAgIC8vIFdoZW4gc3RvcmVkIG1hcmtzIGFyZSBhZGRlZCwgc3RvcCBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAvLyBiZSBkaXNwbGF5ZWQuXG4gICAgICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgY2xlYXJDb21wb3NpdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBsZXQgcGx1Z2luc0NoYW5nZWQgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5ub2RlVmlld3MgIT0gcHJldlByb3BzLm5vZGVWaWV3cykge1xuICAgICAgICAgICAgbGV0IG5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IG5vZGVWaWV3cztcbiAgICAgICAgICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCBwcmV2UHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cykge1xuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGV0IGlubmVyRGVjbyA9IHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgb3V0ZXJEZWNvID0gY29tcHV0ZURvY0RlY28odGhpcyk7XG4gICAgICAgIGxldCBzY3JvbGwgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSA/IFwicmVzZXRcIlxuICAgICAgICAgICAgOiBzdGF0ZS5zY3JvbGxUb1NlbGVjdGlvbiA+IHByZXYuc2Nyb2xsVG9TZWxlY3Rpb24gPyBcInRvIHNlbGVjdGlvblwiIDogXCJwcmVzZXJ2ZVwiO1xuICAgICAgICBsZXQgdXBkYXRlRG9jID0gcmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcubWF0Y2hlc05vZGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGlmICh1cGRhdGVEb2MgfHwgIXN0YXRlLnNlbGVjdGlvbi5lcShwcmV2LnNlbGVjdGlvbikpXG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICBsZXQgb2xkU2Nyb2xsUG9zID0gc2Nyb2xsID09IFwicHJlc2VydmVcIiAmJiB1cGRhdGVTZWwgJiYgdGhpcy5kb20uc3R5bGUub3ZlcmZsb3dBbmNob3IgPT0gbnVsbCAmJiBzdG9yZVNjcm9sbFBvcyh0aGlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNlbCkge1xuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBhbiBpc3N1ZSBpbiBDaHJvbWUsIElFLCBhbmQgRWRnZSB3aGVyZSBjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIERPTSBhcm91bmQgYW4gYWN0aXZlIHNlbGVjdGlvbiBwdXRzIGl0IGludG8gYSBicm9rZW5cbiAgICAgICAgICAgIC8vIHN0YXRlIHdoZXJlIHRoZSB0aGluZyB0aGUgdXNlciBzZWVzIGRpZmZlcnMgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiByZXBvcnRlZCBieSB0aGUgU2VsZWN0aW9uIG9iamVjdCAoIzcxMCwgIzk3MyxcbiAgICAgICAgICAgIC8vICMxMDExLCAjMTAxMywgIzEwMzUpLlxuICAgICAgICAgICAgbGV0IGZvcmNlU2VsVXBkYXRlID0gdXBkYXRlRG9jICYmIChpZSB8fCBjaHJvbWUpICYmICF0aGlzLmNvbXBvc2luZyAmJlxuICAgICAgICAgICAgICAgICFwcmV2LnNlbGVjdGlvbi5lbXB0eSAmJiAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHByZXYuc2VsZWN0aW9uLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZURvYykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIHRoYXQgdGhlIHNlbGVjdGlvbiBwb2ludHMgaW50byBpcyB3cml0dGVuIHRvLFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSBzb21ldGltZXMgc3RhcnRzIG1pc3JlcG9ydGluZyB0aGUgc2VsZWN0aW9uLCBzbyB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdHJhY2tzIHRoYXQgYW5kIGZvcmNlcyBhIHNlbGVjdGlvbiByZXNldCB3aGVuIG91ciB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBkaWQgd3JpdGUgdG8gdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGNocm9tZUtsdWRnZSA9IGNocm9tZSA/ICh0aGlzLnRyYWNrV3JpdGVzID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPSBmaW5kQ29tcG9zaXRpb25Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgfHwgIXRoaXMuZG9jVmlldy51cGRhdGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyhzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaHJvbWVLbHVkZ2UgJiYgIXRoaXMudHJhY2tXcml0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlU2VsVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGZvciBhbiBpc3N1ZSB3aGVyZSBhbiB1cGRhdGUgYXJyaXZpbmcgcmlnaHQgYmV0d2VlblxuICAgICAgICAgICAgLy8gYSBET00gc2VsZWN0aW9uIGNoYW5nZSBhbmQgdGhlIFwic2VsZWN0aW9uY2hhbmdlXCIgZXZlbnQgZm9yIGl0XG4gICAgICAgICAgICAvLyBjYW4gY2F1c2UgYSBzcHVyaW91cyBET00gc2VsZWN0aW9uIHVwZGF0ZSwgZGlzcnVwdGluZyBtb3VzZVxuICAgICAgICAgICAgLy8gZHJhZyBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZm9yY2VTZWxVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAhKHRoaXMuaW5wdXQubW91c2VEb3duICYmIHRoaXMuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckluUmlnaHRQbGFjZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzLCBmb3JjZVNlbFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW5jTm9kZVNlbGVjdGlvbih0aGlzLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cyhwcmV2KTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmRyYWdnaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSkgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdnZWROb2RlKHRoaXMuZHJhZ2dpbmcsIHByZXYpO1xuICAgICAgICBpZiAoc2Nyb2xsID09IFwicmVzZXRcIikge1xuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JvbGwgPT0gXCJ0byBzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFNjcm9sbFBvcykge1xuICAgICAgICAgICAgcmVzZXRTY3JvbGxQb3Mob2xkU2Nyb2xsUG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjcm9sbFRvU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgc3RhcnRET00gPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlO1xuICAgICAgICBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGYgPT4gZih0aGlzKSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5kb2NWaWV3LmRvbUFmdGVyUG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKVxuICAgICAgICAgICAgaWYgKHZpZXcuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpblZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5WaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEcmFnZ2VkTm9kZShkcmFnZ2luZywgcHJldikge1xuICAgICAgICBsZXQgc2VsID0gZHJhZ2dpbmcubm9kZSwgZm91bmQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZG9jLm5vZGVBdChzZWwuZnJvbSkgPT0gc2VsLm5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gc2VsLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbW92ZWRQb3MgPSBzZWwuZnJvbSArICh0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSBwcmV2LmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gbW92ZWRQb3MgPiAwICYmIHRoaXMuc3RhdGUuZG9jLm5vZGVBdChtb3ZlZFBvcyk7XG4gICAgICAgICAgICBpZiAobW92ZWQgPT0gc2VsLm5vZGUpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBtb3ZlZFBvcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKGRyYWdnaW5nLnNsaWNlLCBkcmFnZ2luZy5tb3ZlLCBmb3VuZCA8IDAgPyB1bmRlZmluZWQgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnN0YXRlLmRvYywgZm91bmQpKTtcbiAgICB9XG4gICAgc29tZVByb3AocHJvcE5hbWUsIGYpIHtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wcyAmJiB0aGlzLl9wcm9wc1twcm9wTmFtZV0sIHZhbHVlO1xuICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIHZpZXcgaGFzIGZvY3VzLlxuICAgICovXG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIElFIG5vdCBoYW5kbGluZyBmb2N1cyBjb3JyZWN0bHkgaWYgcmVzaXplIGhhbmRsZXMgYXJlIHNob3duLlxuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggcmVzaXplIGhhbmRsZXMsIGFjdGl2ZUVsZW1lbnRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGF0IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGlzLmRvbS5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICAvLyBJZiBhY3RpdmVFbGVtZW50IGlzIHdpdGhpbiB0aGlzLmRvbSwgYW5kIHRoZXJlIGFyZSBubyBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgLy8gc2V0dGluZyBgY29udGVudGVkaXRhYmxlYCB0byBmYWxzZSBpbiBiZXR3ZWVuLCB0cmVhdCBpdCBhcyBmb2N1c2VkLlxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyhub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiB0aGlzLmRvbSAhPSBub2RlICYmIHRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBGb2N1cyB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSlcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmRvbSk7XG4gICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZG9jdW1lbnQgcm9vdCBpbiB3aGljaCB0aGUgZWRpdG9yIGV4aXN0cy4gVGhpcyB3aWxsXG4gICAgdXN1YWxseSBiZSB0aGUgdG9wLWxldmVsIGBkb2N1bWVudGAsIGJ1dCBtaWdodCBiZSBhIFtzaGFkb3dcbiAgICBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4gICAgcm9vdCBpZiB0aGUgZWRpdG9yIGlzIGluc2lkZSBvbmUuXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGlmIChjYWNoZWQgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2guZ2V0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlYXJjaCkuZ2V0U2VsZWN0aW9uID0gKCkgPT4gc2VhcmNoLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZCB8fCBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiBhbiBleGlzdGluZyBlZGl0b3IgdmlldyBpcyBtb3ZlZCB0byBhIG5ldyBkb2N1bWVudCBvclxuICAgIHNoYWRvdyB0cmVlLCBjYWxsIHRoaXMgdG8gbWFrZSBpdCByZWNvbXB1dGUgaXRzIHJvb3QuXG4gICAgKi9cbiAgICB1cGRhdGVSb290KCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBwYWlyIG9mIHZpZXdwb3J0IGNvb3JkaW5hdGVzLCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGVtLiBNYXkgcmV0dXJuIG51bGwgaWYgdGhlIGdpdmVuXG4gICAgY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuICAgIHJldHVybmVkLCBpdHMgYHBvc2AgcHJvcGVydHkgaXMgdGhlIHBvc2l0aW9uIG5lYXJlc3QgdG8gdGhlXG4gICAgY29vcmRpbmF0ZXMsIGFuZCBpdHMgYGluc2lkZWAgcHJvcGVydHkgaG9sZHMgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuICAgIHRoZSB0b3AgbGV2ZWwsIG5vdCBpbiBhbnkgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0Q29vcmRzKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuICAgIGZsYXQgY3Vyc29yLWlzaCByZWN0YW5nbGUuIElmIHRoZSBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byB0aGluZ3NcbiAgICB0aGF0IGFyZW4ndCBkaXJlY3RseSBhZGphY2VudCwgYHNpZGVgIGRldGVybWluZXMgd2hpY2ggZWxlbWVudFxuICAgIGlzIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4gICAgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGFmdGVyLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICByZXR1cm4gY29vcmRzQXRQb3ModGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgcG9zaXRpb24uIFdoZW4gYHNpZGVgIGlzIG5lZ2F0aXZlLCBmaW5kIHRoZSBwb3NpdGlvbiBhcyBjbG9zZSBhc1xuICAgIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4gICAgcHJlZmVyIHBvc2l0aW9ucyBjbG9zZSB0byB0aGUgY29udGVudCBhZnRlciB0aGUgcG9zaXRpb24uIFdoZW5cbiAgICB6ZXJvLCBwcmVmZXIgYXMgc2hhbGxvdyBhIHBvc2l0aW9uIGFzIHBvc3NpYmxlLlxuICAgIFxuICAgIE5vdGUgdGhhdCB5b3Ugc2hvdWxkICoqbm90KiogbXV0YXRlIHRoZSBlZGl0b3IncyBpbnRlcm5hbCBET00sXG4gICAgb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uIE1heSByZXR1cm4gYG51bGxgIHdoZW4gdGhlIHBvc2l0aW9uIGRvZXNuJ3QgcG9pbnRcbiAgICBpbiBmcm9udCBvZiBhIG5vZGUgb3IgaWYgdGhlIG5vZGUgaXMgaW5zaWRlIGFuIG9wYXF1ZSBub2RlIHZpZXcuXG4gICAgXG4gICAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhYmxlIHRvIGNhbGwgdGhpbmdzIGxpa2VcbiAgICBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbiAgICBlZGl0b3IgRE9NIGRpcmVjdGx5LCBvciBhZGQgc3R5bGluZyB0aGlzIHdheSwgc2luY2UgdGhhdCB3aWxsIGJlXG4gICAgaW1tZWRpYXRlbHkgb3ZlcnJpZGVuIGJ5IHRoZSBlZGl0b3IgYXMgaXQgcmVkcmF3cyB0aGUgbm9kZS5cbiAgICAqL1xuICAgIG5vZGVET00ocG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICAgICAgICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBET01cbiAgICBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4gICAgZG9jdW1lbnQgc3RydWN0dXJlIGRpcmVjdGx5LCByYXRoZXIgdGhhbiBwb2tpbmcgYXJvdW5kIGluIHRoZVxuICAgIERPTSwgYnV0IHNvbWV0aW1lc+KAlGZvciBleGFtcGxlIHdoZW4gaW50ZXJwcmV0aW5nIGFuIGV2ZW50XG4gICAgdGFyZ2V04oCUeW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuICAgIFxuICAgIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4gICAgbm9kZSB0byB1c2Ugd2hlbiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0LCBiaWFzID0gLTEpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuICAgIG1vdmluZyBpbiBhIGdpdmVuIGRpcmVjdGlvbi4gV2hlbiwgZm9yIGV4YW1wbGUsIGdpdmVuIGBcImxlZnRcImAsXG4gICAgaXQgd2lsbCByZXR1cm4gdHJ1ZSBpZiBtb3ZpbmcgbGVmdCBmcm9tIHRoZSBjdXJyZW50IGN1cnNvclxuICAgIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4gICAgdG8gdGhlIHZpZXcncyBjdXJyZW50IHN0YXRlIGJ5IGRlZmF1bHQsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgIHBhc3MgYSBkaWZmZXJlbnQgc3RhdGUuXG4gICAgKi9cbiAgICBlbmRPZlRleHRibG9jayhkaXIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIEhUTUwgc3RyaW5nLiBUaGVcbiAgICBgZXZlbnRgLCBpZiBnaXZlbiwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgW2BoYW5kbGVQYXN0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZVBhc3RlKSBob29rLlxuICAgICovXG4gICAgcGFzdGVIVE1MKGh0bWwsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIFwiXCIsIGh0bWwsIGZhbHNlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gcGxhaW4tdGV4dCBpbnB1dC5cbiAgICAqL1xuICAgIHBhc3RlVGV4dCh0ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCB0ZXh0LCBudWxsLCB0cnVlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIGVkaXRvciBmcm9tIHRoZSBET00gYW5kIGRlc3Ryb3lzIGFsbCBbbm9kZVxuICAgIHZpZXdzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9jVmlldylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVzdHJveUlucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlKHRoaXMuc3RhdGUuZG9jLCBbXSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBudWxsO1xuICAgICAgICBjbGVhclJldXNlZFJhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgdHJ1ZSB3aGVuIHRoZSB2aWV3IGhhcyBiZWVuXG4gICAgW2Rlc3Ryb3llZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kZXN0cm95KSAoYW5kIHRodXMgc2hvdWxkIG5vdCBiZVxuICAgIHVzZWQgYW55bW9yZSkuXG4gICAgKi9cbiAgICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcgPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBmb3IgdGVzdGluZy5cbiAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBEaXNwYXRjaCBhIHRyYW5zYWN0aW9uLiBXaWxsIGNhbGxcbiAgICBbYGRpc3BhdGNoVHJhbnNhY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgIHdoZW4gZ2l2ZW4sIGFuZCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gYXBwbHlpbmcgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNhbGxpbmdcbiAgICBbYHVwZGF0ZVN0YXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy51cGRhdGVTdGF0ZSkgd2l0aCB0aGUgcmVzdWx0LlxuICAgIFRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIHRoZSB2aWV3IGluc3RhbmNlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuICAgICovXG4gICAgZGlzcGF0Y2godHIpIHtcbiAgICAgICAgbGV0IGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb21TZWxlY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHNhZmFyaSAmJiB0aGlzLnJvb3Qubm9kZVR5cGUgPT09IDExICYmXG4gICAgICAgICAgICBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbSAmJiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzLCBzZWwpIHx8IHNlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21TZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZURvY0RlY28odmlldykge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgYXR0cnMuY2xhc3MgPSBcIlByb3NlTWlycm9yXCI7XG4gICAgYXR0cnMuY29udGVudGVkaXRhYmxlID0gU3RyaW5nKHZpZXcuZWRpdGFibGUpO1xuICAgIHZpZXcuc29tZVByb3AoXCJhdHRyaWJ1dGVzXCIsIHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHIgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5zdHlsZSA9IChhdHRycy5zdHlsZSA/IGF0dHJzLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdHRyc1thdHRyXSAmJiBhdHRyICE9IFwiY29udGVudGVkaXRhYmxlXCIgJiYgYXR0ciAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJdID0gU3RyaW5nKHZhbHVlW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWF0dHJzLnRyYW5zbGF0ZSlcbiAgICAgICAgYXR0cnMudHJhbnNsYXRlID0gXCJub1wiO1xuICAgIHJldHVybiBbRGVjb3JhdGlvbi5ub2RlKDAsIHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgYXR0cnMpXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGlmICh2aWV3Lm1hcmtDdXJzb3IpIHtcbiAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiLCBcInRydWVcIik7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJcIik7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IHsgZG9tLCBkZWNvOiBEZWNvcmF0aW9uLndpZGdldCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkLCBkb20sIHsgcmF3OiB0cnVlLCBtYXJrczogdmlldy5tYXJrQ3Vyc29yIH0pIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVkaXRhYmxlKHZpZXcpIHtcbiAgICByZXR1cm4gIXZpZXcuc29tZVByb3AoXCJlZGl0YWJsZVwiLCB2YWx1ZSA9PiB2YWx1ZSh2aWV3LnN0YXRlKSA9PT0gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uQ29udGV4dENoYW5nZWQoc2VsMSwgc2VsMikge1xuICAgIGxldCBkZXB0aCA9IE1hdGgubWluKHNlbDEuJGFuY2hvci5zaGFyZWREZXB0aChzZWwxLmhlYWQpLCBzZWwyLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMi5oZWFkKSk7XG4gICAgcmV0dXJuIHNlbDEuJGFuY2hvci5zdGFydChkZXB0aCkgIT0gc2VsMi4kYW5jaG9yLnN0YXJ0KGRlcHRoKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9kZVZpZXdzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBhZGQob2JqKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJub2RlVmlld3NcIiwgYWRkKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwibWFya1ZpZXdzXCIsIGFkZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoYW5nZWROb2RlVmlld3MoYSwgYikge1xuICAgIGxldCBuQSA9IDAsIG5CID0gMDtcbiAgICBmb3IgKGxldCBwcm9wIGluIGEpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gIT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBuQSsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBfIGluIGIpXG4gICAgICAgIG5CKys7XG4gICAgcmV0dXJuIG5BICE9IG5CO1xufVxuZnVuY3Rpb24gY2hlY2tTdGF0ZUNvbXBvbmVudChwbHVnaW4pIHtcbiAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUgfHwgcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gfHwgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUGx1Z2lucyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXcgbXVzdCBub3QgaGF2ZSBhIHN0YXRlIGNvbXBvbmVudFwiKTtcbn1cblxuZXhwb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldywgX19lbmRDb21wb3NpdGlvbiwgX19wYXJzZUZyb21DbGlwYm9hcmQsIF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkIH07XG4iXSwibmFtZXMiOlsiVGV4dFNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJBbGxTZWxlY3Rpb24iLCJTZWxlY3Rpb24iLCJET01TZXJpYWxpemVyIiwiRnJhZ21lbnQiLCJNYXJrIiwiU2xpY2UiLCJET01QYXJzZXIiLCJkcm9wUG9pbnQiLCJkb21JbmRleCIsIm5vZGUiLCJpbmRleCIsInByZXZpb3VzU2libGluZyIsInBhcmVudE5vZGUiLCJwYXJlbnQiLCJhc3NpZ25lZFNsb3QiLCJub2RlVHlwZSIsImhvc3QiLCJyZXVzZWRSYW5nZSIsInRleHRSYW5nZSIsImZyb20iLCJ0byIsInJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsInNldEVuZCIsIm5vZGVWYWx1ZSIsImxlbmd0aCIsInNldFN0YXJ0IiwiY2xlYXJSZXVzZWRSYW5nZSIsImlzRXF1aXZhbGVudFBvc2l0aW9uIiwib2ZmIiwidGFyZ2V0Tm9kZSIsInRhcmdldE9mZiIsInNjYW5Gb3IiLCJhdG9tRWxlbWVudHMiLCJkaXIiLCJub2RlU2l6ZSIsImhhc0Jsb2NrRGVzYyIsInRlc3QiLCJub2RlTmFtZSIsImNvbnRlbnRFZGl0YWJsZSIsImNoaWxkTm9kZXMiLCJ0ZXh0Tm9kZUJlZm9yZSQxIiwib2Zmc2V0IiwidGV4dE5vZGVBZnRlciQxIiwiaXNPbkVkZ2UiLCJhdFN0YXJ0IiwiYXRFbmQiLCJkb20iLCJkZXNjIiwiY3VyIiwicG1WaWV3RGVzYyIsImlzQmxvY2siLCJjb250ZW50RE9NIiwic2VsZWN0aW9uQ29sbGFwc2VkIiwiZG9tU2VsIiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0Iiwia2V5RXZlbnQiLCJrZXlDb2RlIiwia2V5IiwiZXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImNvZGUiLCJkZWVwQWN0aXZlRWxlbWVudCIsImRvYyIsImVsdCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiY2FyZXRGcm9tUG9pbnQiLCJ4IiwieSIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJwb3MiLCJvZmZzZXROb2RlIiwiXyIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwibmF2IiwibmF2aWdhdG9yIiwiYWdlbnQiLCJ1c2VyQWdlbnQiLCJpZV9lZGdlIiwiZXhlYyIsImllX3VwdG8xMCIsImllXzExdXAiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJnZWNrbyIsIl9jaHJvbWUiLCJjaHJvbWUiLCJjaHJvbWVfdmVyc2lvbiIsInNhZmFyaSIsInZlbmRvciIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwibWFjIiwicGxhdGZvcm0iLCJ3aW5kb3dzIiwiYW5kcm9pZCIsIndlYmtpdCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwid2Via2l0X3ZlcnNpb24iLCJ3aW5kb3dSZWN0IiwidnAiLCJkZWZhdWx0VmlldyIsInZpc3VhbFZpZXdwb3J0IiwibGVmdCIsInJpZ2h0Iiwid2lkdGgiLCJ0b3AiLCJib3R0b20iLCJoZWlnaHQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldFNpZGUiLCJ2YWx1ZSIsInNpZGUiLCJjbGllbnRSZWN0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsUmVjdEludG9WaWV3IiwidmlldyIsInN0YXJ0RE9NIiwic2Nyb2xsVGhyZXNob2xkIiwic29tZVByb3AiLCJzY3JvbGxNYXJnaW4iLCJvd25lckRvY3VtZW50IiwiYXRUb3AiLCJib2R5IiwiYm91bmRpbmciLCJtb3ZlWCIsIm1vdmVZIiwic2Nyb2xsQnkiLCJzdGFydFgiLCJzY3JvbGxMZWZ0Iiwic3RhcnRZIiwic2Nyb2xsVG9wIiwiZFgiLCJkWSIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsInN0b3JlU2Nyb2xsUG9zIiwiTWF0aCIsIm1heCIsInJlZkRPTSIsInJlZlRvcCIsIm1pbiIsImlubmVySGVpZ2h0Iiwicm9vdCIsImVsZW1lbnRGcm9tUG9pbnQiLCJjb250YWlucyIsImxvY2FsUmVjdCIsInN0YWNrIiwic2Nyb2xsU3RhY2siLCJwdXNoIiwicmVzZXRTY3JvbGxQb3MiLCJuZXdSZWZUb3AiLCJyZXN0b3JlU2Nyb2xsU3RhY2siLCJkVG9wIiwiaSIsInByZXZlbnRTY3JvbGxTdXBwb3J0ZWQiLCJmb2N1c1ByZXZlbnRTY3JvbGwiLCJzZXRBY3RpdmUiLCJmb2N1cyIsInN0b3JlZCIsInByZXZlbnRTY3JvbGwiLCJ1bmRlZmluZWQiLCJmaW5kT2Zmc2V0SW5Ob2RlIiwiY29vcmRzIiwiY2xvc2VzdCIsImR4Q2xvc2VzdCIsImNvb3Jkc0Nsb3Nlc3QiLCJyb3dCb3QiLCJyb3dUb3AiLCJmaXJzdEJlbG93IiwiY29vcmRzQmVsb3ciLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJjaGlsZEluZGV4IiwibmV4dFNpYmxpbmciLCJyZWN0cyIsImdldENsaWVudFJlY3RzIiwiZHgiLCJmaW5kT2Zmc2V0SW5UZXh0IiwibGVuIiwic2luZ2xlUmVjdCIsImluUmVjdCIsInRhcmdldEtsdWRnZSIsInBvc0Zyb21FbGVtZW50IiwiYmlhcyIsImRvY1ZpZXciLCJwb3NGcm9tRE9NIiwicG9zRnJvbUNhcmV0Iiwib3V0c2lkZUJsb2NrIiwic2F3QmxvY2siLCJuZWFyZXN0RGVzYyIsInBvc0JlZm9yZSIsInBvc0FmdGVyIiwiaXNUZXh0IiwiYmVmb3JlIiwiZWxlbWVudCIsImJveCIsInN0YXJ0SSIsImZsb29yIiwiaiIsInBvc0F0Q29vcmRzIiwiY2FyZXQiLCJwIiwiZHJhZ2dhYmxlIiwibmV4dCIsInByZXYiLCJsYXN0Q2hpbGQiLCJzdGF0ZSIsImNvbnRlbnQiLCJzaXplIiwiaW5zaWRlIiwicG9zQXRTdGFydCIsImJvcmRlciIsIm5vblplcm8iLCJ0YXJnZXQiLCJmaXJzdCIsIkFycmF5IiwicHJvdG90eXBlIiwiZmluZCIsImNhbGwiLCJCSURJIiwiY29vcmRzQXRQb3MiLCJhdG9tIiwiZG9tRnJvbVBvcyIsInN1cHBvcnRFbXB0eVJhbmdlIiwicmVjdEJlZm9yZSIsInJlY3RBZnRlciIsImZsYXR0ZW5WIiwidGFrZVNpZGUiLCIkZG9tIiwicmVzb2x2ZSIsImlubGluZUNvbnRlbnQiLCJmbGF0dGVuSCIsImFmdGVyIiwiaWdub3JlRm9yQ29vcmRzIiwid2l0aEZsdXNoZWRTdGF0ZSIsImYiLCJ2aWV3U3RhdGUiLCJhY3RpdmUiLCJ1cGRhdGVTdGF0ZSIsImVuZE9mVGV4dGJsb2NrVmVydGljYWwiLCJzZWwiLCJzZWxlY3Rpb24iLCIkcG9zIiwiJGZyb20iLCIkdG8iLCJuZWFyZXN0IiwiYm94ZXMiLCJtYXliZVJUTCIsImVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCIsIiRoZWFkIiwiaXNUZXh0YmxvY2siLCJwYXJlbnRPZmZzZXQiLCJkb21TZWxlY3Rpb24iLCJ0ZXh0Q29udGVudCIsIm1vZGlmeSIsIm9sZE5vZGUiLCJvbGRPZmYiLCJkb21TZWxlY3Rpb25SYW5nZSIsIm9sZEJpZGlMZXZlbCIsImNhcmV0QmlkaUxldmVsIiwicGFyZW50RE9NIiwiZGVwdGgiLCJkb21BZnRlclBvcyIsIm5ld05vZGUiLCJuZXdPZmYiLCJyZXN1bHQiLCJjb2xsYXBzZSIsImV4dGVuZCIsImNhY2hlZFN0YXRlIiwiY2FjaGVkRGlyIiwiY2FjaGVkUmVzdWx0IiwiZW5kT2ZUZXh0YmxvY2siLCJOT1RfRElSVFkiLCJDSElMRF9ESVJUWSIsIkNPTlRFTlRfRElSVFkiLCJOT0RFX0RJUlRZIiwiVmlld0Rlc2MiLCJjb25zdHJ1Y3RvciIsImNoaWxkcmVuIiwiZGlydHkiLCJtYXRjaGVzV2lkZ2V0Iiwid2lkZ2V0IiwibWF0Y2hlc01hcmsiLCJtYXJrIiwibWF0Y2hlc05vZGUiLCJvdXRlckRlY28iLCJpbm5lckRlY28iLCJtYXRjaGVzSGFjayIsInBhcnNlUnVsZSIsInN0b3BFdmVudCIsImRlc3Ryb3kiLCJwb3NCZWZvcmVDaGlsZCIsInBvc0F0RW5kIiwibG9jYWxQb3NGcm9tRE9NIiwiZG9tQmVmb3JlIiwiZG9tQWZ0ZXIiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInNlYXJjaCIsIm9ubHlOb2RlcyIsImdldERlc2MiLCJub2RlRE9NIiwic2NhbiIsImRlc2NBdCIsImVuZCIsImN1clBvcyIsIlRyYWlsaW5nSGFja1ZpZXdEZXNjIiwiV2lkZ2V0Vmlld0Rlc2MiLCJlbnRlciIsImRvbUF0b20iLCJwYXJzZVJhbmdlIiwiYmFzZSIsImZyb21PZmZzZXQiLCJ0b09mZnNldCIsImNoaWxkQmFzZSIsImVtcHR5Q2hpbGRBdCIsIlJhbmdlRXJyb3IiLCJzZXRTZWxlY3Rpb24iLCJhbmNob3IiLCJoZWFkIiwiZm9yY2UiLCJhbmNob3JET00iLCJoZWFkRE9NIiwiZ2V0U2VsZWN0aW9uIiwiYnJLbHVkZ2UiLCJkb21TZWxFeHRlbmRlZCIsInRtcCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwiaWdub3JlTXV0YXRpb24iLCJtdXRhdGlvbiIsInR5cGUiLCJjb250ZW50TG9zdCIsIm1hcmtEaXJ0eSIsInN0YXJ0SW5zaWRlIiwiZW5kSW5zaWRlIiwibWFya1BhcmVudHNEaXJ0eSIsImxldmVsIiwidGV4dCIsInNlbGYiLCJ0b0RPTSIsInNwZWMiLCJyYXciLCJ3cmFwIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwiY2xhc3NMaXN0IiwiYWRkIiwiZXEiLCJpZ25vcmUiLCJzdG9wIiwiaWdub3JlU2VsZWN0aW9uIiwiQ29tcG9zaXRpb25WaWV3RGVzYyIsInRleHRET00iLCJtdXQiLCJvbGRWYWx1ZSIsIk1hcmtWaWV3RGVzYyIsImNyZWF0ZSIsImlubGluZSIsImN1c3RvbSIsIm5vZGVWaWV3cyIsIm5hbWUiLCJyZW5kZXJTcGVjIiwicmVwYXJzZUluVmlldyIsImF0dHJzIiwiY29udGVudEVsZW1lbnQiLCJzbGljZSIsImNvcHkiLCJub2RlcyIsInJlcGxhY2VOb2RlcyIsIk5vZGVWaWV3RGVzYyIsImRlc2NPYmoiLCJjcmVhdGVUZXh0Tm9kZSIsImhhc0F0dHJpYnV0ZSIsImFwcGx5T3V0ZXJEZWNvIiwiQ3VzdG9tTm9kZVZpZXdEZXNjIiwiVGV4dFZpZXdEZXNjIiwicnVsZSIsIndoaXRlc3BhY2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJnZXRDb250ZW50IiwiZW1wdHkiLCJzYW1lT3V0ZXJEZWNvIiwiaXNMZWFmIiwidXBkYXRlQ2hpbGRyZW4iLCJjb21wb3NpdGlvbiIsImNvbXBvc2luZyIsImxvY2FsQ29tcG9zaXRpb25JbmZvIiwibG9jYWxDb21wb3NpdGlvbiIsImNvbXBvc2l0aW9uSW5DaGlsZCIsInVwZGF0ZXIiLCJWaWV3VHJlZVVwZGF0ZXIiLCJpdGVyRGVjbyIsImluc2lkZU5vZGUiLCJtYXJrcyIsInN5bmNUb01hcmtzIiwiY2hpbGRDb3VudCIsIm5vbmUiLCJwbGFjZVdpZGdldCIsImNvbXBJbmRleCIsImZpbmROb2RlTWF0Y2giLCJmaW5kSW5kZXhXaXRoQ2hpbGQiLCJ1cGRhdGVOb2RlQXQiLCJ1cGRhdGVOZXh0Tm9kZSIsImFkZE5vZGUiLCJhZGRUZXh0YmxvY2tIYWNrcyIsImRlc3Ryb3lSZXN0IiwiY2hhbmdlZCIsInByb3RlY3RMb2NhbENvbXBvc2l0aW9uIiwicmVuZGVyRGVzY3MiLCJpb3NIYWNrcyIsInRleHROb2RlIiwiaW5wdXQiLCJjb21wb3NpdGlvbk5vZGUiLCJ0ZXh0UG9zIiwiZmluZFRleHRJbkZyYWdtZW50IiwidG9wTm9kZSIsInJlbW92ZUNoaWxkIiwiY29tcG9zaXRpb25Ob2RlcyIsInVwZGF0ZSIsInNhbWVNYXJrdXAiLCJ1cGRhdGVJbm5lciIsInVwZGF0ZU91dGVyRGVjbyIsIm5lZWRzV3JhcCIsIm9sZERPTSIsInBhdGNoT3V0ZXJEZWNvIiwiY29tcHV0ZU91dGVyRGVjbyIsInNlbGVjdE5vZGUiLCJkZXNlbGVjdE5vZGUiLCJyZW1vdmUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpc0F0b20iLCJkb2NWaWV3RGVzYyIsInNraXAiLCJwbUlzRGVjbyIsImluUGFyZW50IiwidHJhY2tXcml0ZXMiLCJuIiwiY3V0IiwiZGVzY3MiLCJ3cml0dGVuIiwiY2hpbGRET00iLCJybSIsImluc2VydEJlZm9yZSIsIk91dGVyRGVjb0xldmVsIiwiT2JqZWN0Iiwibm9EZWNvIiwidmFsIiwiaXNJbmxpbmUiLCJjbGFzcyIsIm91dGVyRE9NIiwicHJldkNvbXB1dGVkIiwiY3VyQ29tcHV0ZWQiLCJjdXJET00iLCJkZWNvIiwidG9Mb3dlckNhc2UiLCJwYXRjaEF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJwcmV2TGlzdCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImN1ckxpc3QiLCJpbmRleE9mIiwicHJvcCIsIm0iLCJyZW1vdmVQcm9wZXJ0eSIsImNzc1RleHQiLCJhIiwiYiIsImxvY2siLCJwcmVNYXRjaCIsImRlc3Ryb3lCZXR3ZWVuIiwic3RhcnQiLCJzcGxpY2UiLCJrZWVwIiwibWF4S2VlcCIsInNwYW5uaW5nIiwicG9wIiwiZm91bmQiLCJpc0xvY2tlZCIsIm1hcmtEZXNjIiwidGFyZ2V0RGVzYyIsIm1hdGNoZXMiLCJlIiwibWF0Y2hlZCIsImhhcyIsImRvbU5vZGUiLCJnZXQiLCJuZXh0RE9NIiwidXBkYXRlZCIsImxvY2tlZCIsInJlY3JlYXRlV3JhcHBlciIsIndyYXBwZXIiLCJjaCIsInJlcXVpcmVzR2Vja29IYWNrTm9kZSIsImFkZEhhY2tOb2RlIiwiY2xhc3NOYW1lIiwiYWx0IiwiaGFjayIsImZyYWciLCJwYXJlbnREZXNjIiwiY3VyRGVzYyIsImRlc2NJIiwiZkkiLCJNYXAiLCJvdXRlciIsInNldCIsInJldmVyc2UiLCJjb21wYXJlU2lkZSIsIm9uV2lkZ2V0Iiwib25Ob2RlIiwibG9jYWxzIiwiZm9yQ2hpbGQiLCJkZWNvSW5kZXgiLCJyZXN0Tm9kZSIsInBhcmVudEluZGV4Iiwid2lkZ2V0cyIsInNvcnQiLCJjdXRBdCIsImQiLCJvbGRDU1MiLCJ3aW5kb3ciLCJsaXN0U3R5bGUiLCJjaGlsZFN0YXJ0Iiwic3RyIiwibGFzdEluZGV4T2YiLCJyZXBsYWNlbWVudCIsInNlbGVjdGlvbkZyb21ET00iLCJvcmlnaW4iLCJpbldpZGdldCIsIiRhbmNob3IiLCJuZWFyZXN0RGVzY05vZGUiLCJpc1NlbGVjdGFibGUiLCJzZWxlY3Rpb25CZXR3ZWVuIiwiZWRpdG9yT3duc1NlbGVjdGlvbiIsImVkaXRhYmxlIiwiaGFzRm9jdXMiLCJoYXNTZWxlY3Rpb24iLCJzZWxlY3Rpb25Ub0RPTSIsInN5bmNOb2RlU2VsZWN0aW9uIiwibW91c2VEb3duIiwiYWxsb3dEZWZhdWx0IiwiY3VyU2VsIiwiZG9tT2JzZXJ2ZXIiLCJjdXJyZW50U2VsZWN0aW9uIiwiZGVsYXllZFNlbGVjdGlvblN5bmMiLCJzZXRDdXJTZWxlY3Rpb24iLCJkaXNjb25uZWN0U2VsZWN0aW9uIiwiY3Vyc29yV3JhcHBlciIsInNlbGVjdEN1cnNvcldyYXBwZXIiLCJyZXNldEVkaXRhYmxlRnJvbSIsInJlc2V0RWRpdGFibGVUbyIsImJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlIiwidGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIiLCJyZXNldEVkaXRhYmxlIiwidmlzaWJsZSIsInJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2UiLCJjb25uZWN0U2VsZWN0aW9uIiwic2V0RWRpdGFibGUiLCJ3YXNEcmFnZ2FibGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGlkZVNlbGVjdGlvbkd1YXJkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJpbWciLCJkaXNhYmxlZCIsImxhc3RTZWxlY3RlZFZpZXdEZXNjIiwiY2xlYXJOb2RlU2VsZWN0aW9uIiwiYmV0d2VlbiIsImhhc0ZvY3VzQW5kU2VsZWN0aW9uIiwiYW5jaG9ySW5SaWdodFBsYWNlIiwibW92ZVNlbGVjdGlvbkJsb2NrIiwiJHNpZGUiLCIkc3RhcnQiLCJmaW5kRnJvbSIsImFwcGx5IiwiZGlzcGF0Y2giLCJ0ciIsInNjcm9sbEludG9WaWV3Iiwic2VsZWN0SG9yaXpvbnRhbGx5IiwibW9kcyIsInRleHRPZmZzZXQiLCJub2RlQmVmb3JlIiwibm9kZUFmdGVyIiwiJG5ld0hlYWQiLCJub2RlUG9zIiwibm9kZUxlbiIsImlzSWdub3JhYmxlIiwic2tpcElnbm9yZWROb2RlcyIsInNraXBJZ25vcmVkTm9kZXNCZWZvcmUiLCJza2lwSWdub3JlZE5vZGVzQWZ0ZXIiLCJtb3ZlTm9kZSIsIm1vdmVPZmZzZXQiLCJpc0Jsb2NrTm9kZSIsInNldFNlbEZvY3VzIiwidGV4dE5vZGVBZnRlciIsInRleHROb2RlQmVmb3JlIiwiZmluZERpcmVjdGlvbiIsIm1pZCIsImFicyIsImNvbXB1dGVkIiwiZGlyZWN0aW9uIiwic2VsZWN0VmVydGljYWxseSIsImJleW9uZCIsIm5lYXIiLCJzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSIsInNhbWVQYXJlbnQiLCJuZXh0Tm9kZSIsImRlbGV0ZSIsInN3aXRjaEVkaXRhYmxlIiwic2FmYXJpRG93bkFycm93QnVnIiwiZ2V0TW9kcyIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5Iiwic2hpZnRLZXkiLCJjYXB0dXJlS2V5RG93biIsInNlcmlhbGl6ZUZvckNsaXBib2FyZCIsImNvbnRleHQiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwiZGVmYXVsdEF0dHJzIiwic2VyaWFsaXplciIsImZyb21TY2hlbWEiLCJzY2hlbWEiLCJkZXRhY2hlZERvYyIsInNlcmlhbGl6ZUZyYWdtZW50Iiwid3JhcHBlcnMiLCJ3cmFwTWFwIiwiSlNPTiIsInN0cmluZ2lmeSIsInRleHRCZXR3ZWVuIiwicGFyc2VGcm9tQ2xpcGJvYXJkIiwiaHRtbCIsInBsYWluVGV4dCIsIiRjb250ZXh0IiwiaW5Db2RlIiwiYXNUZXh0IiwicmVwbGFjZSIsInBhcnNlZCIsImZvckVhY2giLCJibG9jayIsInNlcmlhbGl6ZU5vZGUiLCJyZWFkSFRNTCIsInJlc3RvcmVSZXBsYWNlZFNwYWNlcyIsImNvbnRleHROb2RlIiwicXVlcnlTZWxlY3RvciIsInNsaWNlRGF0YSIsImdldEF0dHJpYnV0ZSIsInBhcnNlciIsInBhcnNlU2xpY2UiLCJydWxlRnJvbU5vZGUiLCJpbmxpbmVQYXJlbnRzIiwiYWRkQ29udGV4dCIsImNsb3NlU2xpY2UiLCJtYXhPcGVuIiwibm9ybWFsaXplU2libGluZ3MiLCJpc29sYXRpbmciLCJmcmFnbWVudCIsIm1hdGNoIiwiY29udGVudE1hdGNoQXQiLCJsYXN0V3JhcCIsImZpbmRXcmFwcGluZyIsImluTGFzdCIsImFkZFRvU2libGluZyIsImNsb3NlUmlnaHQiLCJ3cmFwcGVkIiwid2l0aFdyYXBwZXJzIiwibWF0Y2hUeXBlIiwic2libGluZyIsImlubmVyIiwicmVwbGFjZUNoaWxkIiwiYXBwZW5kIiwiZmlsbCIsImZpbGxCZWZvcmUiLCJjbG9zZVJhbmdlIiwidGhlYWQiLCJ0Ym9keSIsInRmb290IiwiY2FwdGlvbiIsImNvbGdyb3VwIiwiY29sIiwidGQiLCJ0aCIsIl9kZXRhY2hlZERvYyIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwibWV0YXMiLCJmaXJzdFRhZyIsIm1hcCIsImpvaW4iLCJpbm5lckhUTUwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYXJyYXkiLCJwYXJzZSIsImhhc1JlcXVpcmVkQXR0cnMiLCJoYW5kbGVycyIsImVkaXRIYW5kbGVycyIsInBhc3NpdmVIYW5kbGVycyIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJJbnB1dFN0YXRlIiwibGFzdEtleUNvZGUiLCJsYXN0S2V5Q29kZVRpbWUiLCJsYXN0Q2xpY2siLCJ0aW1lIiwibGFzdFNlbGVjdGlvbk9yaWdpbiIsImxhc3RTZWxlY3Rpb25UaW1lIiwibGFzdElPU0VudGVyIiwibGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0IiwibGFzdEZvY3VzIiwibGFzdFRvdWNoIiwibGFzdEFuZHJvaWREZWxldGUiLCJjb21wb3NpbmdUaW1lb3V0IiwiY29tcG9zaXRpb25FbmRlZEF0IiwiY29tcG9zaXRpb25JRCIsImNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMiLCJkb21DaGFuZ2VDb3VudCIsImV2ZW50SGFuZGxlcnMiLCJpbml0SW5wdXQiLCJoYW5kbGVyIiwiZXZlbnRCZWxvbmdzVG9WaWV3IiwicnVuQ3VzdG9tSGFuZGxlciIsInBhc3NpdmUiLCJlbnN1cmVMaXN0ZW5lcnMiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJEYXRlIiwibm93IiwiZGVzdHJveUlucHV0IiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudEhhbmRsZXJzIiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1YmJsZXMiLCJkaXNwYXRjaEV2ZW50Iiwia2V5ZG93biIsIl9ldmVudCIsImluT3JOZWFyQ29tcG9zaXRpb24iLCJmb3JjZUZsdXNoIiwicHJldmVudERlZmF1bHQiLCJrZXl1cCIsImtleXByZXNzIiwiY2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpbnNlcnRUZXh0IiwiZXZlbnRDb29yZHMiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzTmVhciIsImNsaWNrIiwiZHkiLCJydW5IYW5kbGVyT25Db250ZXh0IiwicHJvcE5hbWUiLCJ1cGRhdGVTZWxlY3Rpb24iLCJmb2N1c2VkIiwic2V0TWV0YSIsInNlbGVjdENsaWNrZWRMZWFmIiwic2VsZWN0Q2xpY2tlZE5vZGUiLCJzZWxlY3RlZE5vZGUiLCJzZWxlY3RBdCIsImhhbmRsZVNpbmdsZUNsaWNrIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJoYW5kbGVUcmlwbGVDbGljayIsImRlZmF1bHRUcmlwbGVDbGljayIsImJ1dHRvbiIsImZvcmNlRE9NRmx1c2giLCJlbmRDb21wb3NpdGlvbiIsInNlbGVjdE5vZGVNb2RpZmllciIsIm1vdXNlZG93biIsImZsdXNoZWQiLCJkb25lIiwiTW91c2VEb3duIiwibWlnaHREcmFnIiwic3RhcnREb2MiLCJ0YXJnZXRQb3MiLCJub2RlQXQiLCJzZWxlY3RhYmxlIiwiYWRkQXR0ciIsInNldFVuZWRpdGFibGUiLCJ1cCIsImJpbmQiLCJtb3ZlIiwidXBkYXRlQWxsb3dEZWZhdWx0IiwiYnV0dG9ucyIsImNvbnRleHRtZW51IiwidGltZVN0YW1wIiwidGltZW91dENvbXBvc2l0aW9uIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9udXBkYXRlIiwiZmx1c2giLCJzdG9yZWRNYXJrcyIsInNvbWUiLCJpbmNsdXNpdmUiLCJtYXJrQ3Vyc29yIiwic2NoZWR1bGVDb21wb3NlRW5kIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsIlByb21pc2UiLCJ0aGVuIiwiZGVsYXkiLCJjbGVhckNvbXBvc2l0aW9uIiwidGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50IiwiZmluZENvbXBvc2l0aW9uTm9kZSIsInRleHRCZWZvcmUiLCJ0ZXh0QWZ0ZXIiLCJkZXNjQWZ0ZXIiLCJsYXN0Q2hhbmdlZCIsImxhc3RDaGFuZ2VkVGV4dE5vZGUiLCJkZXNjQmVmb3JlIiwiZm9yY2VVcGRhdGUiLCJmbHVzaGluZ1Nvb24iLCJjYXB0dXJlQ29weSIsInNlbGVjdE5vZGVDb250ZW50cyIsImJsdXIiLCJicm9rZW5DbGlwYm9hcmRBUEkiLCJkYXRhIiwiY2xpcGJvYXJkRGF0YSIsImNsZWFyRGF0YSIsInNldERhdGEiLCJkZWxldGVTZWxlY3Rpb24iLCJzbGljZVNpbmdsZU5vZGUiLCJjYXB0dXJlUGFzdGUiLCJwbGFpbiIsImRvUGFzdGUiLCJwcmVmZXJQbGFpbiIsInNpbmdsZU5vZGUiLCJyZXBsYWNlU2VsZWN0aW9uV2l0aCIsInJlcGxhY2VTZWxlY3Rpb24iLCJnZXRUZXh0IiwiZ2V0RGF0YSIsInVyaXMiLCJwYXN0ZSIsIkRyYWdnaW5nIiwiZHJhZ0NvcHlNb2RpZmllciIsImRyYWdzdGFydCIsImRhdGFUcmFuc2ZlciIsImRyYWdnZWRTbGljZSIsImVmZmVjdEFsbG93ZWQiLCJkcmFnZ2luZyIsImRyYWdlbmQiLCJkcmFnb3ZlciIsImRyYWdlbnRlciIsImRyb3AiLCJldmVudFBvcyIsIiRtb3VzZSIsImluc2VydFBvcyIsIm1hcHBpbmciLCJpc05vZGUiLCJiZWZvcmVJbnNlcnQiLCJyZXBsYWNlUmFuZ2VXaXRoIiwicmVwbGFjZVJhbmdlIiwibWFwcyIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsInJlbGF0ZWRUYXJnZXQiLCJjbGVhciIsImJlZm9yZWlucHV0IiwiaW5wdXRUeXBlIiwiZmx1c2hTb29uIiwiJGN1cnNvciIsImNvbXBhcmVPYmpzIiwiV2lkZ2V0VHlwZSIsIm5vU3BlYyIsInNwYW4iLCJvbGRPZmZzZXQiLCJkZWxldGVkIiwibWFwUmVzdWx0IiwiRGVjb3JhdGlvbiIsInZhbGlkIiwib3RoZXIiLCJJbmxpbmVUeXBlIiwiaW5jbHVzaXZlU3RhcnQiLCJpbmNsdXNpdmVFbmQiLCJpcyIsIk5vZGVUeXBlIiwiZmluZEluZGV4IiwiRGVjb3JhdGlvblNldCIsImxvY2FsIiwiZGVjb3JhdGlvbnMiLCJidWlsZFRyZWUiLCJwcmVkaWNhdGUiLCJmaW5kSW5uZXIiLCJjaGlsZE9mZiIsIm9wdGlvbnMiLCJtYXBJbm5lciIsIm5ld0xvY2FsIiwibWFwcGVkIiwib25SZW1vdmUiLCJtYXBDaGlsZHJlbiIsImJ5UG9zIiwiYWRkSW5uZXIiLCJjaGlsZE5vZGUiLCJjaGlsZE9mZnNldCIsImJhc2VPZmZzZXQiLCJ0YWtlU3BhbnNGb3JOb2RlIiwibW92ZVNwYW5zIiwid2l0aG91dE51bGxzIiwiY29uY2F0IiwicmVtb3ZlSW5uZXIiLCJyZW1vdmVkIiwiZGVjIiwibG9jYWxTZXQiLCJEZWNvcmF0aW9uR3JvdXAiLCJyZW1vdmVPdmVybGFwIiwibG9jYWxzSW5uZXIiLCJtZW1iZXJzIiwibWFwcGVkRGVjb3MiLCJtZW1iZXIiLCJzb3J0ZWQiLCJldmVyeSIsInJlZHVjZSIsInIiLCJvbGRDaGlsZHJlbiIsIm1vdmVkIiwib2xkU3RhcnQiLCJvbGRFbmQiLCJuZXdTdGFydCIsIm5ld0VuZCIsImRTaXplIiwibXVzdFJlYnVpbGQiLCJmcm9tTG9jYWwiLCJ0b0xvY2FsIiwibWF5YmVDaGlsZCIsIm1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zIiwiYnVpbHQiLCJzcGFucyIsImdhdGhlciIsImhhc051bGxzIiwibG9jYWxTdGFydCIsInN1YnRyZWUiLCJ3b3JraW5nIiwiaW5zZXJ0QWhlYWQiLCJ2aWV3RGVjb3JhdGlvbnMiLCJvYnNlcnZlT3B0aW9ucyIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlT2xkVmFsdWUiLCJ1c2VDaGFyRGF0YSIsIlNlbGVjdGlvblN0YXRlIiwiRE9NT2JzZXJ2ZXIiLCJoYW5kbGVET01DaGFuZ2UiLCJxdWV1ZSIsIm9ic2VydmVyIiwib25DaGFyRGF0YSIsInN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJyZW1vdmVkTm9kZXMiLCJwcmV2VmFsdWUiLCJvblNlbGVjdGlvbkNoYW5nZSIsInRha2VSZWNvcmRzIiwib2JzZXJ2ZSIsInRha2UiLCJkaXNjb25uZWN0Iiwic3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzIiwiaWdub3JlU2VsZWN0aW9uQ2hhbmdlIiwiYW5jZXN0b3JzIiwiU2V0IiwiY29udGFpbmVyIiwibmV3U2VsIiwidHlwZU92ZXIiLCJhZGRlZCIsInJlZ2lzdGVyTXV0YXRpb24iLCJicnMiLCJiciIsImJsb2NrUGFyZW50IiwicmVhZFNlbCIsInNjcm9sbFRvU2VsZWN0aW9uIiwiY2hlY2tDU1MiLCJhdHRyaWJ1dGVOYW1lIiwiYWRkZWROb2RlcyIsImNzc0NoZWNrZWQiLCJXZWFrTWFwIiwiY3NzQ2hlY2tXYXJuZWQiLCJ3aGl0ZVNwYWNlIiwiY29uc29sZSIsInJhbmdlVG9TZWxlY3Rpb25SYW5nZSIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsImN1cnJlbnRBbmNob3IiLCJkb21BdFBvcyIsInNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlIiwiZ2V0Q29tcG9zZWRSYW5nZXMiLCJyZWFkIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiZ2V0VGFyZ2V0UmFuZ2VzIiwiZXhlY0NvbW1hbmQiLCJwYXJzZUJldHdlZW4iLCJmcm9tXyIsInRvXyIsInRvcE1hdGNoIiwidG9wT3BlbiIsImZpbmRQb3NpdGlvbnMiLCJyZWFkRE9NQ2hhbmdlIiwiJGJlZm9yZSIsInNoYXJlZCIsInNoYXJlZERlcHRoIiwiY29tcGFyZSIsInByZWZlcnJlZFBvcyIsInByZWZlcnJlZFNpZGUiLCJjaGFuZ2UiLCJmaW5kRGlmZiIsImVuZEEiLCJlbmRCIiwicmVzb2x2ZVNlbGVjdGlvbiIsInJlc29sdmVOb0NhY2hlIiwiJGZyb21BIiwiaW5saW5lQ2hhbmdlIiwibmV4dFNlbCIsImxvb2tzTGlrZUJhY2tzcGFjZSIsImNoRnJvbSIsImNoVG8iLCJtYXJrQ2hhbmdlIiwibWFya3NBY3Jvc3MiLCJpc01hcmtDaGFuZ2UiLCJhZGRNYXJrIiwicmVtb3ZlTWFyayIsImVuc3VyZU1hcmtzIiwicGFyc2VkU2VsIiwiY3VyTWFya3MiLCJwcmV2TWFya3MiLCJyZW1vdmVGcm9tU2V0IiwiYWRkVG9TZXQiLCJvbGQiLCIkbmV3U3RhcnQiLCIkbmV3RW5kIiwic2tpcENsb3NpbmdBbmRPcGVuaW5nIiwiJG5leHQiLCJmcm9tRW5kIiwibWF5T3BlbiIsImluZGV4QWZ0ZXIiLCJmaW5kRGlmZlN0YXJ0IiwiZmluZERpZmZFbmQiLCJhZGp1c3QiLCJpc1N1cnJvZ2F0ZVBhaXIiLCJjaGFyQ29kZUF0IiwiX19zZXJpYWxpemVGb3JDbGlwYm9hcmQiLCJfX3BhcnNlRnJvbUNsaXBib2FyZCIsIl9fZW5kQ29tcG9zaXRpb24iLCJFZGl0b3JWaWV3IiwicGxhY2UiLCJwcm9wcyIsIl9yb290IiwibW91bnRlZCIsInByZXZEaXJlY3RQbHVnaW5zIiwicGx1Z2luVmlld3MiLCJfcHJvcHMiLCJkaXJlY3RQbHVnaW5zIiwicGx1Z2lucyIsImNoZWNrU3RhdGVDb21wb25lbnQiLCJtb3VudCIsImdldEVkaXRhYmxlIiwidXBkYXRlQ3Vyc29yV3JhcHBlciIsImJ1aWxkTm9kZVZpZXdzIiwiY29tcHV0ZURvY0RlY28iLCJ1cGRhdGVQbHVnaW5WaWV3cyIsImhhbmRsZURPTUV2ZW50cyIsInByZXZQcm9wcyIsInVwZGF0ZVN0YXRlSW5uZXIiLCJzZXRQcm9wcyIsIl9hIiwicmVkcmF3IiwidXBkYXRlU2VsIiwicGx1Z2luc0NoYW5nZWQiLCJjaGFuZ2VkTm9kZVZpZXdzIiwic2Nyb2xsIiwidXBkYXRlRG9jIiwib2xkU2Nyb2xsUG9zIiwib3ZlcmZsb3dBbmNob3IiLCJmb3JjZVNlbFVwZGF0ZSIsInNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkIiwiY2hyb21lS2x1ZGdlIiwidXBkYXRlRHJhZ2dlZE5vZGUiLCJkZXN0cm95UGx1Z2luVmlld3MiLCJwcmV2U3RhdGUiLCJwbHVnaW4iLCJwbHVnaW5WaWV3IiwibW92ZWRQb3MiLCJwYXJlbnRFbGVtZW50IiwiY2FjaGVkIiwiZ2V0UHJvdG90eXBlT2YiLCJ1cGRhdGVSb290IiwicG9zQXRET00iLCJwYXN0ZUhUTUwiLCJDbGlwYm9hcmRFdmVudCIsInBhc3RlVGV4dCIsImlzRGVzdHJveWVkIiwiZGlzcGF0Y2hUcmFuc2FjdGlvbiIsImNvbnRlbnRlZGl0YWJsZSIsImF0dHIiLCJ0cmFuc2xhdGUiLCJzZWwxIiwic2VsMiIsIm9iaiIsImhhc093blByb3BlcnR5IiwibkEiLCJuQiIsImZpbHRlclRyYW5zYWN0aW9uIiwiYXBwZW5kVHJhbnNhY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-view/dist/index.js\n");

/***/ })

};
;