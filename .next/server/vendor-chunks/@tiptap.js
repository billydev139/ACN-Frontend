"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ index),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js\");\n\n\n\n\n\n\n\n/**\r\n * Takes a Transaction & Editor State and turns it into a chainable state object\r\n * @param config The transaction and state to create the chainable state from\r\n * @returns A chainable Editor state object\r\n */ function createChainableState(config) {\n    const { state, transaction } = config;\n    let { selection } = transaction;\n    let { doc } = transaction;\n    let { storedMarks } = transaction;\n    return {\n        ...state,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        plugins: state.plugins,\n        schema: state.schema,\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n        get storedMarks () {\n            return storedMarks;\n        },\n        get selection () {\n            return selection;\n        },\n        get doc () {\n            return doc;\n        },\n        get tr () {\n            selection = transaction.selection;\n            doc = transaction.doc;\n            storedMarks = transaction.storedMarks;\n            return transaction;\n        }\n    };\n}\nclass CommandManager {\n    constructor(props){\n        this.editor = props.editor;\n        this.rawCommands = this.editor.extensionManager.commands;\n        this.customState = props.state;\n    }\n    get hasCustomState() {\n        return !!this.customState;\n    }\n    get state() {\n        return this.customState || this.editor.state;\n    }\n    get commands() {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const { tr } = state;\n        const props = this.buildProps(tr);\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n            const method = (...args)=>{\n                const callback = command(...args)(props);\n                if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                    view.dispatch(tr);\n                }\n                return callback;\n            };\n            return [\n                name,\n                method\n            ];\n        }));\n    }\n    get chain() {\n        return ()=>this.createChain();\n    }\n    get can() {\n        return ()=>this.createCan();\n    }\n    createChain(startTr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const callbacks = [];\n        const hasStartTransaction = !!startTr;\n        const tr = startTr || state.tr;\n        const run = ()=>{\n            if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                view.dispatch(tr);\n            }\n            return callbacks.every((callback)=>callback === true);\n        };\n        const chain = {\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n                const chainedCommand = (...args)=>{\n                    const props = this.buildProps(tr, shouldDispatch);\n                    const callback = command(...args)(props);\n                    callbacks.push(callback);\n                    return chain;\n                };\n                return [\n                    name,\n                    chainedCommand\n                ];\n            })),\n            run\n        };\n        return chain;\n    }\n    createCan(startTr) {\n        const { rawCommands, state } = this;\n        const dispatch = false;\n        const tr = startTr || state.tr;\n        const props = this.buildProps(tr, dispatch);\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n            return [\n                name,\n                (...args)=>command(...args)({\n                        ...props,\n                        dispatch: undefined\n                    })\n            ];\n        }));\n        return {\n            ...formattedCommands,\n            chain: ()=>this.createChain(tr, dispatch)\n        };\n    }\n    buildProps(tr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const props = {\n            tr,\n            editor,\n            view,\n            state: createChainableState({\n                state,\n                transaction: tr\n            }),\n            dispatch: shouldDispatch ? ()=>undefined : undefined,\n            chain: ()=>this.createChain(tr, shouldDispatch),\n            can: ()=>this.createCan(tr),\n            get commands () {\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n                    return [\n                        name,\n                        (...args)=>command(...args)(props)\n                    ];\n                }));\n            }\n        };\n        return props;\n    }\n}\nclass EventEmitter {\n    constructor(){\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback)=>callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter((callback)=>callback !== fn);\n            } else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n/**\r\n * Returns a field from an extension\r\n * @param extension The Tiptap extension\r\n * @param field The field, for example `renderHTML` or `priority`\r\n * @param context The context object that should be passed as `this` into the function\r\n * @returns The field value\r\n */ function getExtensionField(extension, field, context) {\n    if (extension.config[field] === undefined && extension.parent) {\n        return getExtensionField(extension.parent, field, context);\n    }\n    if (typeof extension.config[field] === \"function\") {\n        const value = extension.config[field].bind({\n            ...context,\n            parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n        });\n        return value;\n    }\n    return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n    const baseExtensions = extensions.filter((extension)=>extension.type === \"extension\");\n    const nodeExtensions = extensions.filter((extension)=>extension.type === \"node\");\n    const markExtensions = extensions.filter((extension)=>extension.type === \"mark\");\n    return {\n        baseExtensions,\n        nodeExtensions,\n        markExtensions\n    };\n}\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */ function getAttributesFromExtensions(extensions) {\n    const extensionAttributes = [];\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const nodeAndMarkExtensions = [\n        ...nodeExtensions,\n        ...markExtensions\n    ];\n    const defaultAttribute = {\n        default: null,\n        rendered: true,\n        renderHTML: null,\n        parseHTML: null,\n        keepOnSplit: true,\n        isRequired: false\n    };\n    extensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        const addGlobalAttributes = getExtensionField(extension, \"addGlobalAttributes\", context);\n        if (!addGlobalAttributes) {\n            return;\n        }\n        // TODO: remove `as GlobalAttributes`\n        const globalAttributes = addGlobalAttributes();\n        globalAttributes.forEach((globalAttribute)=>{\n            globalAttribute.types.forEach((type)=>{\n                Object.entries(globalAttribute.attributes).forEach(([name, attribute])=>{\n                    extensionAttributes.push({\n                        type,\n                        name,\n                        attribute: {\n                            ...defaultAttribute,\n                            ...attribute\n                        }\n                    });\n                });\n            });\n        });\n    });\n    nodeAndMarkExtensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        const addAttributes = getExtensionField(extension, \"addAttributes\", context);\n        if (!addAttributes) {\n            return;\n        }\n        // TODO: remove `as Attributes`\n        const attributes = addAttributes();\n        Object.entries(attributes).forEach(([name, attribute])=>{\n            const mergedAttr = {\n                ...defaultAttribute,\n                ...attribute\n            };\n            if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === \"function\") {\n                mergedAttr.default = mergedAttr.default();\n            }\n            if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n                delete mergedAttr.default;\n            }\n            extensionAttributes.push({\n                type: extension.name,\n                name,\n                attribute: mergedAttr\n            });\n        });\n    });\n    return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.nodes[nameOrType]) {\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.nodes[nameOrType];\n    }\n    return nameOrType;\n}\nfunction mergeAttributes(...objects) {\n    return objects.filter((item)=>!!item).reduce((items, item)=>{\n        const mergedAttributes = {\n            ...items\n        };\n        Object.entries(item).forEach(([key, value])=>{\n            const exists = mergedAttributes[key];\n            if (!exists) {\n                mergedAttributes[key] = value;\n                return;\n            }\n            if (key === \"class\") {\n                const valueClasses = value ? value.split(\" \") : [];\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n                const insertClasses = valueClasses.filter((valueClass)=>!existingClasses.includes(valueClass));\n                mergedAttributes[key] = [\n                    ...existingClasses,\n                    ...insertClasses\n                ].join(\" \");\n            } else if (key === \"style\") {\n                mergedAttributes[key] = [\n                    mergedAttributes[key],\n                    value\n                ].join(\"; \");\n            } else {\n                mergedAttributes[key] = value;\n            }\n        });\n        return mergedAttributes;\n    }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n    return extensionAttributes.filter((item)=>item.attribute.rendered).map((item)=>{\n        if (!item.attribute.renderHTML) {\n            return {\n                [item.name]: nodeOrMark.attrs[item.name]\n            };\n        }\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n    }).reduce((attributes, attribute)=>mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */ function callOrReturn(value, context = undefined, ...props) {\n    if (isFunction(value)) {\n        if (context) {\n            return value.bind(context)(...props);\n        }\n        return value(...props);\n    }\n    return value;\n}\nfunction isEmptyObject(value = {}) {\n    return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n        return Number(value);\n    }\n    if (value === \"true\") {\n        return true;\n    }\n    if (value === \"false\") {\n        return false;\n    }\n    return value;\n}\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */ function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n    if (parseRule.style) {\n        return parseRule;\n    }\n    return {\n        ...parseRule,\n        getAttrs: (node)=>{\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n            if (oldAttributes === false) {\n                return false;\n            }\n            const newAttributes = extensionAttributes.reduce((items, item)=>{\n                const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n                if (value === null || value === undefined) {\n                    return items;\n                }\n                return {\n                    ...items,\n                    [item.name]: value\n                };\n            }, {});\n            return {\n                ...oldAttributes,\n                ...newAttributes\n            };\n        }\n    };\n}\nfunction cleanUpSchemaItem(data) {\n    return Object.fromEntries(// @ts-ignore\n    Object.entries(data).filter(([key, value])=>{\n        if (key === \"attrs\" && isEmptyObject(value)) {\n            return false;\n        }\n        return value !== null && value !== undefined;\n    }));\n}\n/**\r\n * Creates a new Prosemirror schema based on the given extensions.\r\n * @param extensions An array of Tiptap extensions\r\n * @param editor The editor instance\r\n * @returns A Prosemirror schema\r\n */ function getSchemaByResolvedExtensions(extensions, editor) {\n    var _a;\n    const allAttributes = getAttributesFromExtensions(extensions);\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const topNode = (_a = nodeExtensions.find((extension)=>getExtensionField(extension, \"topNode\"))) === null || _a === void 0 ? void 0 : _a.name;\n    const nodes = Object.fromEntries(nodeExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraNodeFields = extensions.reduce((fields, e)=>{\n            const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n            return {\n                ...fields,\n                ...extendNodeSchema ? extendNodeSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraNodeFields,\n            content: callOrReturn(getExtensionField(extension, \"content\", context)),\n            marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n            atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n            selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n            draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n            isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute)=>{\n                var _a;\n                return [\n                    extensionAttribute.name,\n                    {\n                        default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n                    }\n                ];\n            }))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (node)=>renderHTML({\n                    node,\n                    HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n                });\n        }\n        const renderText = getExtensionField(extension, \"renderText\", context);\n        if (renderText) {\n            schema.toText = renderText;\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    const marks = Object.fromEntries(markExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraMarkFields = extensions.reduce((fields, e)=>{\n            const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n            return {\n                ...fields,\n                ...extendMarkSchema ? extendMarkSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraMarkFields,\n            inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n            excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute)=>{\n                var _a;\n                return [\n                    extensionAttribute.name,\n                    {\n                        default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n                    }\n                ];\n            }))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (mark)=>renderHTML({\n                    mark,\n                    HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n                });\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode,\n        nodes,\n        marks\n    });\n}\n/**\r\n * Tries to get a node or mark type by its name.\r\n * @param name The name of the node or mark type\r\n * @param schema The Prosemiror schema to search in\r\n * @returns The node or mark type, or null if it doesn't exist\r\n */ function getSchemaTypeByName(name, schema) {\n    return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n    if (Array.isArray(enabled)) {\n        return enabled.some((enabledExtension)=>{\n            const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n            return name === extension.name;\n        });\n    }\n    return enabled;\n}\n/**\r\n * Returns the text content of a resolved prosemirror position\r\n * @param $from The resolved position to get the text content from\r\n * @param maxMatch The maximum number of characters to match\r\n * @returns The text content\r\n */ const getTextContentFromNodes = ($from, maxMatch = 500)=>{\n    let textBefore = \"\";\n    const sliceEndPos = $from.parentOffset;\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index)=>{\n        var _a, _b;\n        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            node,\n            pos,\n            parent,\n            index\n        })) || node.textContent || \"%leaf%\";\n        textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n    });\n    return textBefore;\n};\nfunction isRegExp(value) {\n    return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\nclass InputRule {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst inputRuleMatcherHandler = (text, find)=>{\n    if (isRegExp(find)) {\n        return find.exec(text);\n    }\n    const inputRuleMatch = find(text);\n    if (!inputRuleMatch) {\n        return null;\n    }\n    const result = [\n        inputRuleMatch.text\n    ];\n    result.index = inputRuleMatch.index;\n    result.input = text;\n    result.data = inputRuleMatch.data;\n    if (inputRuleMatch.replaceWith) {\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n        }\n        result.push(inputRuleMatch.replaceWith);\n    }\n    return result;\n};\nfunction run$1(config) {\n    var _a;\n    const { editor, from, to, text, rules, plugin } = config;\n    const { view } = editor;\n    if (view.composing) {\n        return false;\n    }\n    const $from = view.state.doc.resolve(from);\n    if (// check for code node\n    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark)=>mark.type.spec.code))) {\n        return false;\n    }\n    let matched = false;\n    const textBefore = getTextContentFromNodes($from) + text;\n    rules.forEach((rule)=>{\n        if (matched) {\n            return;\n        }\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\n        if (!match) {\n            return;\n        }\n        const tr = view.state.tr;\n        const state = createChainableState({\n            state: view.state,\n            transaction: tr\n        });\n        const range = {\n            from: from - (match[0].length - text.length),\n            to\n        };\n        const { commands, chain, can } = new CommandManager({\n            editor,\n            state\n        });\n        const handler = rule.handler({\n            state,\n            range,\n            match,\n            commands,\n            chain,\n            can\n        });\n        // stop if there are no changes\n        if (handler === null || !tr.steps.length) {\n            return;\n        }\n        // store transform as meta data\n        // so we can undo input rules within the `undoInputRules` command\n        tr.setMeta(plugin, {\n            transform: tr,\n            from,\n            to,\n            text\n        });\n        view.dispatch(tr);\n        matched = true;\n    });\n    return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */ function inputRulesPlugin(props) {\n    const { editor, rules } = props;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init () {\n                return null;\n            },\n            apply (tr, prev) {\n                const stored = tr.getMeta(plugin);\n                if (stored) {\n                    return stored;\n                }\n                // if InputRule is triggered by insertContent()\n                const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n                const isSimulatedInput = !!simulatedInputMeta;\n                if (isSimulatedInput) {\n                    setTimeout(()=>{\n                        const { from, text } = simulatedInputMeta;\n                        const to = from + text.length;\n                        run$1({\n                            editor,\n                            from,\n                            to,\n                            text,\n                            rules,\n                            plugin\n                        });\n                    });\n                }\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput (view, from, to, text) {\n                return run$1({\n                    editor,\n                    from,\n                    to,\n                    text,\n                    rules,\n                    plugin\n                });\n            },\n            handleDOMEvents: {\n                compositionend: (view)=>{\n                    setTimeout(()=>{\n                        const { $cursor } = view.state.selection;\n                        if ($cursor) {\n                            run$1({\n                                editor,\n                                from: $cursor.pos,\n                                to: $cursor.pos,\n                                text: \"\",\n                                rules,\n                                plugin\n                            });\n                        }\n                    });\n                    return false;\n                }\n            },\n            // add support for input rules to trigger on enter\n            // this is useful for example for code blocks\n            handleKeyDown (view, event) {\n                if (event.key !== \"Enter\") {\n                    return false;\n                }\n                const { $cursor } = view.state.selection;\n                if ($cursor) {\n                    return run$1({\n                        editor,\n                        from: $cursor.pos,\n                        to: $cursor.pos,\n                        text: \"\\n\",\n                        rules,\n                        plugin\n                    });\n                }\n                return false;\n            }\n        },\n        // @ts-ignore\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\r\n * Paste rules are used to react to pasted content.\r\n * @see https://tiptap.dev/guide/custom-extensions/#paste-rules\r\n */ class PasteRule {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst pasteRuleMatcherHandler = (text, find, event)=>{\n    if (isRegExp(find)) {\n        return [\n            ...text.matchAll(find)\n        ];\n    }\n    const matches = find(text, event);\n    if (!matches) {\n        return [];\n    }\n    return matches.map((pasteRuleMatch)=>{\n        const result = [\n            pasteRuleMatch.text\n        ];\n        result.index = pasteRuleMatch.index;\n        result.input = text;\n        result.data = pasteRuleMatch.data;\n        if (pasteRuleMatch.replaceWith) {\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n            }\n            result.push(pasteRuleMatch.replaceWith);\n        }\n        return result;\n    });\n};\nfunction run(config) {\n    const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n    const { commands, chain, can } = new CommandManager({\n        editor,\n        state\n    });\n    const handlers = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (!node.isTextblock || node.type.spec.code) {\n            return;\n        }\n        const resolvedFrom = Math.max(from, pos);\n        const resolvedTo = Math.min(to, pos + node.content.size);\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, \"￼\");\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n        matches.forEach((match)=>{\n            if (match.index === undefined) {\n                return;\n            }\n            const start = resolvedFrom + match.index + 1;\n            const end = start + match[0].length;\n            const range = {\n                from: state.tr.mapping.map(start),\n                to: state.tr.mapping.map(end)\n            };\n            const handler = rule.handler({\n                state,\n                range,\n                match,\n                commands,\n                chain,\n                can,\n                pasteEvent,\n                dropEvent\n            });\n            handlers.push(handler);\n        });\n    });\n    const success = handlers.every((handler)=>handler !== null);\n    return success;\n}\nconst createClipboardPasteEvent = (text)=>{\n    var _a;\n    const event = new ClipboardEvent(\"paste\", {\n        clipboardData: new DataTransfer()\n    });\n    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData(\"text/html\", text);\n    return event;\n};\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */ function pasteRulesPlugin(props) {\n    const { editor, rules } = props;\n    let dragSourceElement = null;\n    let isPastedFromProseMirror = false;\n    let isDroppedFromProseMirror = false;\n    let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    let dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    const processEvent = ({ state, from, to, rule, pasteEvt })=>{\n        const tr = state.tr;\n        const chainableState = createChainableState({\n            state,\n            transaction: tr\n        });\n        const handler = run({\n            editor,\n            state: chainableState,\n            from: Math.max(from - 1, 0),\n            to: to.b - 1,\n            rule,\n            pasteEvent: pasteEvt,\n            dropEvent\n        });\n        if (!handler || !tr.steps.length) {\n            return;\n        }\n        dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n        pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n        return tr;\n    };\n    const plugins = rules.map((rule)=>{\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n            // we register a global drag handler to track the current drag source element\n            view (view) {\n                const handleDragstart = (event)=>{\n                    var _a;\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n                };\n                window.addEventListener(\"dragstart\", handleDragstart);\n                return {\n                    destroy () {\n                        window.removeEventListener(\"dragstart\", handleDragstart);\n                    }\n                };\n            },\n            props: {\n                handleDOMEvents: {\n                    drop: (view, event)=>{\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n                        dropEvent = event;\n                        return false;\n                    },\n                    paste: (_view, event)=>{\n                        var _a;\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData(\"text/html\");\n                        pasteEvent = event;\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes(\"data-pm-slice\"));\n                        return false;\n                    }\n                }\n            },\n            appendTransaction: (transactions, oldState, state)=>{\n                const transaction = transactions[0];\n                const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n                const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n                // if PasteRule is triggered by insertContent()\n                const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n                const isSimulatedPaste = !!simulatedPasteMeta;\n                if (!isPaste && !isDrop && !isSimulatedPaste) {\n                    return;\n                }\n                // Handle simulated paste\n                if (isSimulatedPaste) {\n                    const { from, text } = simulatedPasteMeta;\n                    const to = from + text.length;\n                    const pasteEvt = createClipboardPasteEvent(text);\n                    return processEvent({\n                        rule,\n                        state,\n                        from,\n                        to: {\n                            b: to\n                        },\n                        pasteEvt\n                    });\n                }\n                // handle actual paste/drop\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\n                // stop if there is no changed range\n                if (!isNumber(from) || !to || from === to.b) {\n                    return;\n                }\n                return processEvent({\n                    rule,\n                    state,\n                    from,\n                    to,\n                    pasteEvt: pasteEvent\n                });\n            }\n        });\n    });\n    return plugins;\n}\nfunction findDuplicates(items) {\n    const filtered = items.filter((el, index)=>items.indexOf(el) !== index);\n    return [\n        ...new Set(filtered)\n    ];\n}\nclass ExtensionManager {\n    constructor(extensions, editor){\n        this.splittableMarks = [];\n        this.editor = editor;\n        this.extensions = ExtensionManager.resolve(extensions);\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n        this.setupExtensions();\n    }\n    /**\r\n     * Returns a flattened and sorted extension list while\r\n     * also checking for duplicated extensions and warns the user.\r\n     * @param extensions An array of Tiptap extensions\r\n     * @returns An flattened and sorted array of Tiptap extensions\r\n     */ static resolve(extensions) {\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n        const duplicatedNames = findDuplicates(resolvedExtensions.map((extension)=>extension.name));\n        if (duplicatedNames.length) {\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item)=>`'${item}'`).join(\", \")}]. This can lead to issues.`);\n        }\n        return resolvedExtensions;\n    }\n    /**\r\n     * Create a flattened array of extensions by traversing the `addExtensions` field.\r\n     * @param extensions An array of Tiptap extensions\r\n     * @returns A flattened array of Tiptap extensions\r\n     */ static flatten(extensions) {\n        return extensions.map((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage\n            };\n            const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n            if (addExtensions) {\n                return [\n                    extension,\n                    ...this.flatten(addExtensions())\n                ];\n            }\n            return extension;\n        })// `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10);\n    }\n    /**\r\n     * Sort extensions by priority.\r\n     * @param extensions An array of Tiptap extensions\r\n     * @returns A sorted array of Tiptap extensions by priority\r\n     */ static sort(extensions) {\n        const defaultPriority = 100;\n        return extensions.sort((a, b)=>{\n            const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n            const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n            if (priorityA > priorityB) {\n                return -1;\n            }\n            if (priorityA < priorityB) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    /**\r\n     * Get all commands from the extensions.\r\n     * @returns An object with all commands where the key is the command name and the value is the command function\r\n     */ get commands() {\n        return this.extensions.reduce((commands, extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const addCommands = getExtensionField(extension, \"addCommands\", context);\n            if (!addCommands) {\n                return commands;\n            }\n            return {\n                ...commands,\n                ...addCommands()\n            };\n        }, {});\n    }\n    /**\r\n     * Get all registered Prosemirror plugins from the extensions.\r\n     * @returns An array of Prosemirror plugins\r\n     */ get plugins() {\n        const { editor } = this;\n        // With ProseMirror, first plugins within an array are executed first.\n        // In Tiptap, we provide the ability to override plugins,\n        // so it feels more natural to run plugins at the end of an array first.\n        // That’s why we have to reverse the `extensions` array and sort again\n        // based on the `priority` option.\n        const extensions = ExtensionManager.sort([\n            ...this.extensions\n        ].reverse());\n        const inputRules = [];\n        const pasteRules = [];\n        const allPlugins = extensions.map((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const plugins = [];\n            const addKeyboardShortcuts = getExtensionField(extension, \"addKeyboardShortcuts\", context);\n            let defaultBindings = {};\n            // bind exit handling\n            if (extension.type === \"mark\" && extension.config.exitable) {\n                defaultBindings.ArrowRight = ()=>Mark.handleExit({\n                        editor,\n                        mark: extension\n                    });\n            }\n            if (addKeyboardShortcuts) {\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method])=>{\n                    return [\n                        shortcut,\n                        ()=>method({\n                                editor\n                            })\n                    ];\n                }));\n                defaultBindings = {\n                    ...defaultBindings,\n                    ...bindings\n                };\n            }\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n            plugins.push(keyMapPlugin);\n            const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n                inputRules.push(...addInputRules());\n            }\n            const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n                pasteRules.push(...addPasteRules());\n            }\n            const addProseMirrorPlugins = getExtensionField(extension, \"addProseMirrorPlugins\", context);\n            if (addProseMirrorPlugins) {\n                const proseMirrorPlugins = addProseMirrorPlugins();\n                plugins.push(...proseMirrorPlugins);\n            }\n            return plugins;\n        }).flat();\n        return [\n            inputRulesPlugin({\n                editor,\n                rules: inputRules\n            }),\n            ...pasteRulesPlugin({\n                editor,\n                rules: pasteRules\n            }),\n            ...allPlugins\n        ];\n    }\n    /**\r\n     * Get all attributes from the extensions.\r\n     * @returns An array of attributes\r\n     */ get attributes() {\n        return getAttributesFromExtensions(this.extensions);\n    }\n    /**\r\n     * Get all node views from the extensions.\r\n     * @returns An object with all node views where the key is the node name and the value is the node view function\r\n     */ get nodeViews() {\n        const { editor } = this;\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(nodeExtensions.filter((extension)=>!!getExtensionField(extension, \"addNodeView\")).map((extension)=>{\n            const extensionAttributes = this.attributes.filter((attribute)=>attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getNodeType(extension.name, this.schema)\n            };\n            const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n            if (!addNodeView) {\n                return [];\n            }\n            const nodeview = (node, view, getPos, decorations)=>{\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n                return addNodeView()({\n                    editor,\n                    node,\n                    getPos,\n                    decorations,\n                    HTMLAttributes,\n                    extension\n                });\n            };\n            return [\n                extension.name,\n                nodeview\n            ];\n        }));\n    }\n    /**\r\n     * Go through all extensions, create extension storages & setup marks\r\n     * & bind editor event listener.\r\n     */ setupExtensions() {\n        this.extensions.forEach((extension)=>{\n            var _a;\n            // store extension storage in editor\n            this.editor.extensionStorage[extension.name] = extension.storage;\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            if (extension.type === \"mark\") {\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) !== null && _a !== void 0 ? _a : true;\n                if (keepOnSplit) {\n                    this.splittableMarks.push(extension.name);\n                }\n            }\n            const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n            const onCreate = getExtensionField(extension, \"onCreate\", context);\n            const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n            const onSelectionUpdate = getExtensionField(extension, \"onSelectionUpdate\", context);\n            const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n            const onFocus = getExtensionField(extension, \"onFocus\", context);\n            const onBlur = getExtensionField(extension, \"onBlur\", context);\n            const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n            if (onBeforeCreate) {\n                this.editor.on(\"beforeCreate\", onBeforeCreate);\n            }\n            if (onCreate) {\n                this.editor.on(\"create\", onCreate);\n            }\n            if (onUpdate) {\n                this.editor.on(\"update\", onUpdate);\n            }\n            if (onSelectionUpdate) {\n                this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n            }\n            if (onTransaction) {\n                this.editor.on(\"transaction\", onTransaction);\n            }\n            if (onFocus) {\n                this.editor.on(\"focus\", onFocus);\n            }\n            if (onBlur) {\n                this.editor.on(\"blur\", onBlur);\n            }\n            if (onDestroy) {\n                this.editor.on(\"destroy\", onDestroy);\n            }\n        });\n    }\n}\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n    if (getType(value) !== \"Object\") {\n        return false;\n    }\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n    const output = {\n        ...target\n    };\n    if (isPlainObject(target) && isPlainObject(source)) {\n        Object.keys(source).forEach((key)=>{\n            if (isPlainObject(source[key])) {\n                if (!(key in target)) {\n                    Object.assign(output, {\n                        [key]: source[key]\n                    });\n                } else {\n                    output[key] = mergeDeep(target[key], source[key]);\n                }\n            } else {\n                Object.assign(output, {\n                    [key]: source[key]\n                });\n            }\n        });\n    }\n    return output;\n}\n/**\r\n * The Extension class is the base class for all extensions.\r\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\r\n */ class Extension {\n    constructor(config = {}){\n        this.type = \"extension\";\n        this.name = \"extension\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Extension(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend();\n        extension.parent = this.parent;\n        extension.options = mergeDeep(this.options, options);\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Extension({\n            ...this.config,\n            ...extendedConfig\n        });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n}\n/**\r\n * Gets the text between two positions in a Prosemirror node\r\n * and serializes it using the given text serializers and block separator (see getText)\r\n * @param startNode The Prosemirror node to start from\r\n * @param range The range of the text to get\r\n * @param options Options for the text serializer & block separator\r\n * @returns The text between the two positions\r\n */ function getTextBetween(startNode, range, options) {\n    const { from, to } = range;\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    let text = \"\";\n    startNode.nodesBetween(from, to, (node, pos, parent, index)=>{\n        var _a;\n        if (node.isBlock && pos > from) {\n            text += blockSeparator;\n        }\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n        if (textSerializer) {\n            if (parent) {\n                text += textSerializer({\n                    node,\n                    pos,\n                    parent,\n                    index,\n                    range\n                });\n            }\n            // do not descend into child nodes when there exists a serializer\n            return false;\n        }\n        if (node.isText) {\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n        }\n    });\n    return text;\n}\n/**\r\n * Find text serializers `toText` in a Prosemirror schema\r\n * @param schema The Prosemirror schema to search in\r\n * @returns A record of text serializers by node name\r\n */ function getTextSerializersFromSchema(schema) {\n    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node])=>node.spec.toText).map(([name, node])=>[\n            name,\n            node.spec.toText\n        ]));\n}\nconst ClipboardTextSerializer = Extension.create({\n    name: \"clipboardTextSerializer\",\n    addOptions () {\n        return {\n            blockSeparator: undefined\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clipboardTextSerializer\"),\n                props: {\n                    clipboardTextSerializer: ()=>{\n                        const { editor } = this;\n                        const { state, schema } = editor;\n                        const { doc, selection } = state;\n                        const { ranges } = selection;\n                        const from = Math.min(...ranges.map((range)=>range.$from.pos));\n                        const to = Math.max(...ranges.map((range)=>range.$to.pos));\n                        const textSerializers = getTextSerializersFromSchema(schema);\n                        const range = {\n                            from,\n                            to\n                        };\n                        return getTextBetween(doc, range, {\n                            ...this.options.blockSeparator !== undefined ? {\n                                blockSeparator: this.options.blockSeparator\n                            } : {},\n                            textSerializers\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst blur = ()=>({ editor, view })=>{\n        requestAnimationFrame(()=>{\n            var _a;\n            if (!editor.isDestroyed) {\n                view.dom.blur();\n                // Browsers should remove the caret on blur but safari does not.\n                // See: https://github.com/ueberdosis/tiptap/issues/2405\n                (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n            }\n        });\n        return true;\n    };\nconst clearContent = (emitUpdate = false)=>({ commands })=>{\n        return commands.setContent(\"\", emitUpdate);\n    };\nconst clearNodes = ()=>({ state, tr, dispatch })=>{\n        const { selection } = tr;\n        const { ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        ranges.forEach(({ $from, $to })=>{\n            state.doc.nodesBetween($from.pos, $to.pos, (node, pos)=>{\n                if (node.type.isText) {\n                    return;\n                }\n                const { doc, mapping } = tr;\n                const $mappedFrom = doc.resolve(mapping.map(pos));\n                const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n                const nodeRange = $mappedFrom.blockRange($mappedTo);\n                if (!nodeRange) {\n                    return;\n                }\n                const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);\n                if (node.type.isTextblock) {\n                    const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n                    tr.setNodeMarkup(nodeRange.start, defaultType);\n                }\n                if (targetLiftDepth || targetLiftDepth === 0) {\n                    tr.lift(nodeRange, targetLiftDepth);\n                }\n            });\n        });\n        return true;\n    };\nconst command = (fn)=>(props)=>{\n        return fn(props);\n    };\nconst createParagraphNear = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\n    };\nconst cut = (originRange, targetPos)=>({ editor, tr })=>{\n        const { state } = editor;\n        const contentSlice = state.doc.slice(originRange.from, originRange.to);\n        tr.deleteRange(originRange.from, originRange.to);\n        const newPos = tr.mapping.map(targetPos);\n        tr.insert(newPos, contentSlice.content);\n        tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(newPos - 1)));\n        return true;\n    };\nconst deleteCurrentNode = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const currentNode = selection.$anchor.node();\n        // if there is content inside the current node, break out of this command\n        if (currentNode.content.size > 0) {\n            return false;\n        }\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === currentNode.type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst deleteNode = (typeOrName)=>({ tr, state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst deleteRange = (range)=>({ tr, dispatch })=>{\n        const { from, to } = range;\n        if (dispatch) {\n            tr.delete(from, to);\n        }\n        return true;\n    };\nconst deleteSelection = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\n    };\nconst enter = ()=>({ commands })=>{\n        return commands.keyboardShortcut(\"Enter\");\n    };\nconst exitCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\n    };\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */ function objectIncludes(object1, object2, options = {\n    strict: true\n}) {\n    const keys = Object.keys(object2);\n    if (!keys.length) {\n        return true;\n    }\n    return keys.every((key)=>{\n        if (options.strict) {\n            return object2[key] === object1[key];\n        }\n        if (isRegExp(object2[key])) {\n            return object2[key].test(object1[key]);\n        }\n        return object2[key] === object1[key];\n    });\n}\nfunction findMarkInSet(marks, type, attributes = {}) {\n    return marks.find((item)=>{\n        return item.type === type && objectIncludes(item.attrs, attributes);\n    });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n    return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes = {}) {\n    if (!$pos || !type) {\n        return;\n    }\n    let start = $pos.parent.childAfter($pos.parentOffset);\n    if ($pos.parentOffset === start.offset && start.offset !== 0) {\n        start = $pos.parent.childBefore($pos.parentOffset);\n    }\n    if (!start.node) {\n        return;\n    }\n    const mark = findMarkInSet([\n        ...start.node.marks\n    ], type, attributes);\n    if (!mark) {\n        return;\n    }\n    let startIndex = start.index;\n    let startPos = $pos.start() + start.offset;\n    let endIndex = startIndex + 1;\n    let endPos = startPos + start.node.nodeSize;\n    findMarkInSet([\n        ...start.node.marks\n    ], type, attributes);\n    while(startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)){\n        startIndex -= 1;\n        startPos -= $pos.parent.child(startIndex).nodeSize;\n    }\n    while(endIndex < $pos.parent.childCount && isMarkInSet([\n        ...$pos.parent.child(endIndex).marks\n    ], type, attributes)){\n        endPos += $pos.parent.child(endIndex).nodeSize;\n        endIndex += 1;\n    }\n    return {\n        from: startPos,\n        to: endPos\n    };\n}\nfunction getMarkType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.marks[nameOrType]) {\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.marks[nameOrType];\n    }\n    return nameOrType;\n}\nconst extendMarkRange = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const type = getMarkType(typeOrName, state.schema);\n        const { doc, selection } = tr;\n        const { $from, from, to } = selection;\n        if (dispatch) {\n            const range = getMarkRange($from, type, attributes);\n            if (range && range.from <= from && range.to >= to) {\n                const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\n                tr.setSelection(newSelection);\n            }\n        }\n        return true;\n    };\nconst first = (commands)=>(props)=>{\n        const items = typeof commands === \"function\" ? commands(props) : commands;\n        for(let i = 0; i < items.length; i += 1){\n            if (items[i](props)) {\n                return true;\n            }\n        }\n        return false;\n    };\nfunction isTextSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n}\nfunction minMax(value = 0, min = 0, max = 0) {\n    return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc, position = null) {\n    if (!position) {\n        return null;\n    }\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\n    if (position === \"start\" || position === true) {\n        return selectionAtStart;\n    }\n    if (position === \"end\") {\n        return selectionAtEnd;\n    }\n    const minPos = selectionAtStart.from;\n    const maxPos = selectionAtEnd.to;\n    if (position === \"all\") {\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n    }\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n    return [\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\"\n    ].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\nconst focus = (position = null, options = {})=>({ editor, view, tr, dispatch })=>{\n        options = {\n            scrollIntoView: true,\n            ...options\n        };\n        const delayedFocus = ()=>{\n            // focus within `requestAnimationFrame` breaks focus on iOS\n            // so we have to call this\n            if (isiOS()) {\n                view.dom.focus();\n            }\n            // For React we have to focus asynchronously. Otherwise wild things happen.\n            // see: https://github.com/ueberdosis/tiptap/issues/1520\n            requestAnimationFrame(()=>{\n                if (!editor.isDestroyed) {\n                    view.focus();\n                    if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n                        editor.commands.scrollIntoView();\n                    }\n                }\n            });\n        };\n        if (view.hasFocus() && position === null || position === false) {\n            return true;\n        }\n        // we don’t try to resolve a NodeSelection or CellSelection\n        if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n            delayedFocus();\n            return true;\n        }\n        // pass through tr.doc instead of editor.state.doc\n        // since transactions could change the editors state before this command has been run\n        const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n        const isSameSelection = editor.state.selection.eq(selection);\n        if (dispatch) {\n            if (!isSameSelection) {\n                tr.setSelection(selection);\n            }\n            // `tr.setSelection` resets the stored marks\n            // so we’ll restore them if the selection is the same as before\n            if (isSameSelection && tr.storedMarks) {\n                tr.setStoredMarks(tr.storedMarks);\n            }\n            delayedFocus();\n        }\n        return true;\n    };\nconst forEach = (items, fn)=>(props)=>{\n        return items.every((item, index)=>fn(item, {\n                ...props,\n                index\n            }));\n    };\nconst insertContent = (value, options)=>({ tr, commands })=>{\n        return commands.insertContentAt({\n            from: tr.selection.from,\n            to: tr.selection.to\n        }, value, options);\n    };\nconst removeWhitespaces = (node)=>{\n    const children = node.childNodes;\n    for(let i = children.length - 1; i >= 0; i -= 1){\n        const child = children[i];\n        if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n            node.removeChild(child);\n        } else if (child.nodeType === 1) {\n            removeWhitespaces(child);\n        }\n    }\n    return node;\n};\nfunction elementFromString(value) {\n    // add a wrapper to preserve leading and trailing whitespace\n    const wrappedValue = `<body>${value}</body>`;\n    const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n    return removeWhitespaces(html);\n}\n/**\r\n * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.\r\n * @param content The JSON or HTML content to create the node from\r\n * @param schema The Prosemirror schema to use for the node\r\n * @param options Options for the parser\r\n * @returns The created Prosemirror node or fragment\r\n */ function createNodeFromContent(content, schema, options) {\n    options = {\n        slice: true,\n        parseOptions: {},\n        ...options\n    };\n    const isJSONContent = typeof content === \"object\" && content !== null;\n    const isTextContent = typeof content === \"string\";\n    if (isJSONContent) {\n        try {\n            const isArrayContent = Array.isArray(content) && content.length > 0;\n            // if the JSON Content is an array of nodes, create a fragment for each node\n            if (isArrayContent) {\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map((item)=>schema.nodeFromJSON(item)));\n            }\n            return schema.nodeFromJSON(content);\n        } catch (error) {\n            console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n            return createNodeFromContent(\"\", schema, options);\n        }\n    }\n    if (isTextContent) {\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n        return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n    }\n    return createNodeFromContent(\"\", schema, options);\n}\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    const last = tr.steps.length - 1;\n    if (last < startLen) {\n        return;\n    }\n    const step = tr.steps[last];\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {\n        return;\n    }\n    const map = tr.mapping.maps[last];\n    let end = 0;\n    map.forEach((_from, _to, _newFrom, newTo)=>{\n        if (end === 0) {\n            end = newTo;\n        }\n    });\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = (nodeOrFragment)=>{\n    return nodeOrFragment.toString().startsWith(\"<\");\n};\nconst insertContentAt = (position, value, options)=>({ tr, dispatch, editor })=>{\n        if (dispatch) {\n            options = {\n                parseOptions: {},\n                updateSelection: true,\n                applyInputRules: false,\n                applyPasteRules: false,\n                ...options\n            };\n            const content = createNodeFromContent(value, editor.schema, {\n                parseOptions: {\n                    preserveWhitespace: \"full\",\n                    ...options.parseOptions\n                }\n            });\n            // don’t dispatch an empty fragment because this can lead to strange errors\n            if (content.toString() === \"<>\") {\n                return true;\n            }\n            let { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : {\n                from: position.from,\n                to: position.to\n            };\n            let isOnlyTextContent = true;\n            let isOnlyBlockContent = true;\n            const nodes = isFragment(content) ? content : [\n                content\n            ];\n            nodes.forEach((node)=>{\n                // check if added node is valid\n                node.check();\n                isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n                isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n            });\n            // check if we can replace the wrapping node by\n            // the newly inserted content\n            // example:\n            // replace an empty paragraph by an inserted image\n            // instead of inserting the image below the paragraph\n            if (from === to && isOnlyBlockContent) {\n                const { parent } = tr.doc.resolve(from);\n                const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n                if (isEmptyTextBlock) {\n                    from -= 1;\n                    to += 1;\n                }\n            }\n            let newContent;\n            // if there is only plain text we have to use `insertText`\n            // because this will keep the current marks\n            if (isOnlyTextContent) {\n                // if value is string, we can use it directly\n                // otherwise if it is an array, we have to join it\n                if (Array.isArray(value)) {\n                    newContent = value.map((v)=>v.text || \"\").join(\"\");\n                } else if (typeof value === \"object\" && !!value && !!value.text) {\n                    newContent = value.text;\n                } else {\n                    newContent = value;\n                }\n                tr.insertText(newContent, from, to);\n            } else {\n                newContent = content;\n                tr.replaceWith(from, to, newContent);\n            }\n            // set cursor at end of inserted content\n            if (options.updateSelection) {\n                selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n            }\n            if (options.applyInputRules) {\n                tr.setMeta(\"applyInputRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n            if (options.applyPasteRules) {\n                tr.setMeta(\"applyPasteRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n        }\n        return true;\n    };\nconst joinUp = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\n    };\nconst joinDown = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\n    };\nconst joinBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\n    };\nconst joinForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\n    };\nconst joinItemBackward = ()=>({ tr, state, dispatch })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n            if (point === null || point === undefined) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\nconst joinItemForward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);\n            if (point === null || point === undefined) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\nconst joinTextblockBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockBackward)(state, dispatch);\n    };\nconst joinTextblockForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockForward)(state, dispatch);\n    };\nfunction isMacOS() {\n    return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result === \"Space\") {\n        result = \" \";\n    }\n    let alt;\n    let ctrl;\n    let shift;\n    let meta;\n    for(let i = 0; i < parts.length - 1; i += 1){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n            meta = true;\n        } else if (/^a(lt)?$/i.test(mod)) {\n            alt = true;\n        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n            ctrl = true;\n        } else if (/^s(hift)?$/i.test(mod)) {\n            shift = true;\n        } else if (/^mod$/i.test(mod)) {\n            if (isiOS() || isMacOS()) {\n                meta = true;\n            } else {\n                ctrl = true;\n            }\n        } else {\n            throw new Error(`Unrecognized modifier name: ${mod}`);\n        }\n    }\n    if (alt) {\n        result = `Alt-${result}`;\n    }\n    if (ctrl) {\n        result = `Ctrl-${result}`;\n    }\n    if (meta) {\n        result = `Meta-${result}`;\n    }\n    if (shift) {\n        result = `Shift-${result}`;\n    }\n    return result;\n}\nconst keyboardShortcut = (name)=>({ editor, view, tr, dispatch })=>{\n        const keys = normalizeKeyName(name).split(/-(?!$)/);\n        const key = keys.find((item)=>![\n                \"Alt\",\n                \"Ctrl\",\n                \"Meta\",\n                \"Shift\"\n            ].includes(item));\n        const event = new KeyboardEvent(\"keydown\", {\n            key: key === \"Space\" ? \" \" : key,\n            altKey: keys.includes(\"Alt\"),\n            ctrlKey: keys.includes(\"Ctrl\"),\n            metaKey: keys.includes(\"Meta\"),\n            shiftKey: keys.includes(\"Shift\"),\n            bubbles: true,\n            cancelable: true\n        });\n        const capturedTransaction = editor.captureTransaction(()=>{\n            view.someProp(\"handleKeyDown\", (f)=>f(view, event));\n        });\n        capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step)=>{\n            const newStep = step.map(tr.mapping);\n            if (newStep && dispatch) {\n                tr.maybeStep(newStep);\n            }\n        });\n        return true;\n    };\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n    const { from, to, empty } = state.selection;\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n    const nodeRanges = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (node.isText) {\n            return;\n        }\n        const relativeFrom = Math.max(from, pos);\n        const relativeTo = Math.min(to, pos + node.nodeSize);\n        nodeRanges.push({\n            node,\n            from: relativeFrom,\n            to: relativeTo\n        });\n    });\n    const selectionRange = to - from;\n    const matchedNodeRanges = nodeRanges.filter((nodeRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === nodeRange.node.type.name;\n    }).filter((nodeRange)=>objectIncludes(nodeRange.node.attrs, attributes, {\n            strict: false\n        }));\n    if (empty) {\n        return !!matchedNodeRanges.length;\n    }\n    const range = matchedNodeRanges.reduce((sum, nodeRange)=>sum + nodeRange.to - nodeRange.from, 0);\n    return range >= selectionRange;\n}\nconst lift = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (!isActive) {\n            return false;\n        }\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\n    };\nconst liftEmptyBlock = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\n    };\nconst liftListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\n    };\nconst newlineInCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\n    };\n/**\r\n * Get the type of a schema item by its name.\r\n * @param name The name of the schema item\r\n * @param schema The Prosemiror schema to search in\r\n * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist\r\n */ function getSchemaTypeNameByName(name, schema) {\n    if (schema.nodes[name]) {\n        return \"node\";\n    }\n    if (schema.marks[name]) {\n        return \"mark\";\n    }\n    return null;\n}\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */ function deleteProps(obj, propOrProps) {\n    const props = typeof propOrProps === \"string\" ? [\n        propOrProps\n    ] : propOrProps;\n    return Object.keys(obj).reduce((newObj, prop)=>{\n        if (!props.includes(prop)) {\n            newObj[prop] = obj[prop];\n        }\n        return newObj;\n    }, {});\n}\nconst resetAttributes = (typeOrName, attributes)=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        if (dispatch) {\n            tr.selection.ranges.forEach((range)=>{\n                state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos)=>{\n                    if (nodeType && nodeType === node.type) {\n                        tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n                    }\n                    if (markType && node.marks.length) {\n                        node.marks.forEach((mark)=>{\n                            if (markType === mark.type) {\n                                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        return true;\n    };\nconst scrollIntoView = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            tr.scrollIntoView();\n        }\n        return true;\n    };\nconst selectAll = ()=>({ tr, commands })=>{\n        return commands.setTextSelection({\n            from: 0,\n            to: tr.doc.content.size\n        });\n    };\nconst selectNodeBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\n    };\nconst selectNodeForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\n    };\nconst selectParentNode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\n    };\n// @ts-ignore\nconst selectTextblockEnd = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\n    };\n// @ts-ignore\nconst selectTextblockStart = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\n    };\n/**\r\n * Create a new Prosemirror document node from content.\r\n * @param content The JSON or HTML content to create the document from\r\n * @param schema The Prosemirror schema to use for the document\r\n * @param parseOptions Options for the parser\r\n * @returns The created Prosemirror document node\r\n */ function createDocument(content, schema, parseOptions = {}) {\n    return createNodeFromContent(content, schema, {\n        slice: false,\n        parseOptions\n    });\n}\nconst setContent = (content, emitUpdate = false, parseOptions = {})=>({ tr, editor, dispatch })=>{\n        const { doc } = tr;\n        const document1 = createDocument(content, editor.schema, parseOptions);\n        if (dispatch) {\n            tr.replaceWith(0, doc.content.size, document1).setMeta(\"preventUpdate\", !emitUpdate);\n        }\n        return true;\n    };\nfunction getMarkAttributes(state, typeOrName) {\n    const type = getMarkType(typeOrName, state.schema);\n    const { from, to, empty } = state.selection;\n    const marks = [];\n    if (empty) {\n        if (state.storedMarks) {\n            marks.push(...state.storedMarks);\n        }\n        marks.push(...state.selection.$head.marks());\n    } else {\n        state.doc.nodesBetween(from, to, (node)=>{\n            marks.push(...node.marks);\n        });\n    }\n    const mark = marks.find((markItem)=>markItem.type.name === type.name);\n    if (!mark) {\n        return {};\n    }\n    return {\n        ...mark.attrs\n    };\n}\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n * @param oldDoc The Prosemirror node to start from\r\n * @param transactions The transactions to combine\r\n * @returns A new `Transform` with all steps of the passed transactions\r\n */ function combineTransactionSteps(oldDoc, transactions) {\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);\n    transactions.forEach((transaction)=>{\n        transaction.steps.forEach((step)=>{\n            transform.step(step);\n        });\n    });\n    return transform;\n}\n/**\r\n * Gets the default block type at a given match\r\n * @param match The content match to get the default block type from\r\n * @returns The default block type or null\r\n */ function defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i += 1){\n        const { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\n            return type;\n        }\n    }\n    return null;\n}\n/**\r\n * Find children inside a Prosemirror node that match a predicate.\r\n * @param node The Prosemirror node to search in\r\n * @param predicate The predicate to match\r\n * @returns An array of nodes with their positions\r\n */ function findChildren(node, predicate) {\n    const nodesWithPos = [];\n    node.descendants((child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n * @param node The Prosemirror node to search in\r\n * @param range The range to search in\r\n * @param predicate The predicate to match\r\n * @returns An array of nodes with their positions\r\n */ function findChildrenInRange(node, range, predicate) {\n    const nodesWithPos = [];\n    // if (range.from === range.to) {\n    //   const nodeAt = node.nodeAt(range.from)\n    //   if (nodeAt) {\n    //     nodesWithPos.push({\n    //       node: nodeAt,\n    //       pos: range.from,\n    //     })\n    //   }\n    // }\n    node.nodesBetween(range.from, range.to, (child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n/**\r\n * Finds the closest parent node to a resolved position that matches a predicate.\r\n * @param $pos The resolved position to search from\r\n * @param predicate The predicate to match\r\n * @returns The closest parent node to the resolved position that matches the predicate\r\n * @example ```js\r\n * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')\r\n * ```\r\n */ function findParentNodeClosestToPos($pos, predicate) {\n    for(let i = $pos.depth; i > 0; i -= 1){\n        const node = $pos.node(i);\n        if (predicate(node)) {\n            return {\n                pos: i > 0 ? $pos.before(i) : 0,\n                start: $pos.start(i),\n                depth: i,\n                node\n            };\n        }\n    }\n}\n/**\r\n * Finds the closest parent node to the current selection that matches a predicate.\r\n * @param predicate The predicate to match\r\n * @returns A command that finds the closest parent node to the current selection that matches the predicate\r\n * @example ```js\r\n * findParentNode(node => node.type.name === 'paragraph')\r\n * ```\r\n */ function findParentNode(predicate) {\n    return (selection)=>findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n    const temporaryDocument = document.implementation.createHTMLDocument();\n    const container = temporaryDocument.createElement(\"div\");\n    container.appendChild(documentFragment);\n    return container.innerHTML;\n}\nfunction getSchema(extensions, editor) {\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n/**\r\n * Generate HTML from a JSONContent\r\n * @param doc The JSONContent to generate HTML from\r\n * @param extensions The extensions to use for the schema\r\n * @returns The generated HTML\r\n */ function generateHTML(doc, extensions) {\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getHTMLFromFragment(contentNode.content, schema);\n}\n/**\r\n * Generate JSONContent from HTML\r\n * @param html The HTML to generate JSONContent from\r\n * @param extensions The extensions to use for the schema\r\n * @returns The generated JSONContent\r\n */ function generateJSON(html, extensions) {\n    const schema = getSchema(extensions);\n    const dom = elementFromString(html);\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n/**\r\n * Gets the text of a Prosemirror node\r\n * @param node The Prosemirror node\r\n * @param options Options for the text serializer & block separator\r\n * @returns The text of the node\r\n * @example ```js\r\n * const text = getText(node, { blockSeparator: '\\n' })\r\n * ```\r\n */ function getText(node, options) {\n    const range = {\n        from: 0,\n        to: node.content.size\n    };\n    return getTextBetween(node, range, options);\n}\n/**\r\n * Generate raw text from a JSONContent\r\n * @param doc The JSONContent to generate text from\r\n * @param extensions The extensions to use for the schema\r\n * @param options Options for the text generation f.e. blockSeparator or textSerializers\r\n * @returns The generated text\r\n */ function generateText(doc, extensions, options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getText(contentNode, {\n        blockSeparator,\n        textSerializers: {\n            ...getTextSerializersFromSchema(schema),\n            ...textSerializers\n        }\n    });\n}\nfunction getNodeAttributes(state, typeOrName) {\n    const type = getNodeType(typeOrName, state.schema);\n    const { from, to } = state.selection;\n    const nodes = [];\n    state.doc.nodesBetween(from, to, (node)=>{\n        nodes.push(node);\n    });\n    const node = nodes.reverse().find((nodeItem)=>nodeItem.type.name === type.name);\n    if (!node) {\n        return {};\n    }\n    return {\n        ...node.attrs\n    };\n}\n/**\r\n * Get node or mark attributes by type or name on the current editor state\r\n * @param state The current editor state\r\n * @param typeOrName The node or mark type or name\r\n * @returns The attributes of the node or mark or an empty object\r\n */ function getAttributes(state, typeOrName) {\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n    if (schemaType === \"node\") {\n        return getNodeAttributes(state, typeOrName);\n    }\n    if (schemaType === \"mark\") {\n        return getMarkAttributes(state, typeOrName);\n    }\n    return {};\n}\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */ function removeDuplicates(array, by = JSON.stringify) {\n    const seen = {};\n    return array.filter((item)=>{\n        const key = by(item);\n        return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n    });\n}\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */ function simplifyChangedRanges(changes) {\n    const uniqueChanges = removeDuplicates(changes);\n    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index)=>{\n        const rest = uniqueChanges.filter((_, i)=>i !== index);\n        return !rest.some((otherChange)=>{\n            return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n        });\n    });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */ function getChangedRanges(transform) {\n    const { mapping, steps } = transform;\n    const changes = [];\n    mapping.maps.forEach((stepMap, index)=>{\n        const ranges = [];\n        // This accounts for step changes where no range was actually altered\n        // e.g. when setting a mark, node attribute, etc.\n        // @ts-ignore\n        if (!stepMap.ranges.length) {\n            const { from, to } = steps[index];\n            if (from === undefined || to === undefined) {\n                return;\n            }\n            ranges.push({\n                from,\n                to\n            });\n        } else {\n            stepMap.forEach((from, to)=>{\n                ranges.push({\n                    from,\n                    to\n                });\n            });\n        }\n        ranges.forEach(({ from, to })=>{\n            const newStart = mapping.slice(index).map(from, -1);\n            const newEnd = mapping.slice(index).map(to);\n            const oldStart = mapping.invert().map(newStart, -1);\n            const oldEnd = mapping.invert().map(newEnd);\n            changes.push({\n                oldRange: {\n                    from: oldStart,\n                    to: oldEnd\n                },\n                newRange: {\n                    from: newStart,\n                    to: newEnd\n                }\n            });\n        });\n    });\n    return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node, startOffset = 0) {\n    const isTopNode = node.type === node.type.schema.topNodeType;\n    const increment = isTopNode ? 0 : 1;\n    const from = startOffset;\n    const to = from + node.nodeSize;\n    const marks = node.marks.map((mark)=>{\n        const output = {\n            type: mark.type.name\n        };\n        if (Object.keys(mark.attrs).length) {\n            output.attrs = {\n                ...mark.attrs\n            };\n        }\n        return output;\n    });\n    const attrs = {\n        ...node.attrs\n    };\n    const output = {\n        type: node.type.name,\n        from,\n        to\n    };\n    if (Object.keys(attrs).length) {\n        output.attrs = attrs;\n    }\n    if (marks.length) {\n        output.marks = marks;\n    }\n    if (node.content.childCount) {\n        output.content = [];\n        node.forEach((child, offset)=>{\n            var _a;\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n        });\n    }\n    if (node.text) {\n        output.text = node.text;\n    }\n    return output;\n}\nfunction getMarksBetween(from, to, doc) {\n    const marks = [];\n    // get all inclusive marks on empty selection\n    if (from === to) {\n        doc.resolve(from).marks().forEach((mark)=>{\n            const $pos = doc.resolve(from - 1);\n            const range = getMarkRange($pos, mark.type);\n            if (!range) {\n                return;\n            }\n            marks.push({\n                mark,\n                ...range\n            });\n        });\n    } else {\n        doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === undefined) {\n                return;\n            }\n            marks.push(...node.marks.map((mark)=>({\n                    from: pos,\n                    to: pos + node.nodeSize,\n                    mark\n                })));\n        });\n    }\n    return marks;\n}\n/**\r\n * Finds the first node of a given type or name in the current selection.\r\n * @param state The editor state.\r\n * @param typeOrName The node type or name.\r\n * @param pos The position to start searching from.\r\n * @param maxDepth The maximum depth to search.\r\n * @returns The node and the depth as an array.\r\n */ const getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20)=>{\n    const $pos = state.doc.resolve(pos);\n    let currentDepth = maxDepth;\n    let node = null;\n    while(currentDepth > 0 && node === null){\n        const currentNode = $pos.node(currentDepth);\n        if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n            node = currentNode;\n        } else {\n            currentDepth -= 1;\n        }\n    }\n    return [\n        node,\n        currentDepth\n    ];\n};\n/**\r\n * Return attributes of an extension that should be splitted by keepOnSplit flag\r\n * @param extensionAttributes Array of extension attributes\r\n * @param typeName The type of the extension\r\n * @param attributes The attributes of the extension\r\n * @returns The splitted attributes\r\n */ function getSplittedAttributes(extensionAttributes, typeName, attributes) {\n    return Object.fromEntries(Object.entries(attributes).filter(([name])=>{\n        const extensionAttribute = extensionAttributes.find((item)=>{\n            return item.type === typeName && item.name === name;\n        });\n        if (!extensionAttribute) {\n            return false;\n        }\n        return extensionAttribute.attribute.keepOnSplit;\n    }));\n}\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n    const { empty, ranges } = state.selection;\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n    if (empty) {\n        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark)=>{\n            if (!type) {\n                return true;\n            }\n            return type.name === mark.type.name;\n        }).find((mark)=>objectIncludes(mark.attrs, attributes, {\n                strict: false\n            }));\n    }\n    let selectionRange = 0;\n    const markRanges = [];\n    ranges.forEach(({ $from, $to })=>{\n        const from = $from.pos;\n        const to = $to.pos;\n        state.doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node.isText && !node.marks.length) {\n                return;\n            }\n            const relativeFrom = Math.max(from, pos);\n            const relativeTo = Math.min(to, pos + node.nodeSize);\n            const range = relativeTo - relativeFrom;\n            selectionRange += range;\n            markRanges.push(...node.marks.map((mark)=>({\n                    mark,\n                    from: relativeFrom,\n                    to: relativeTo\n                })));\n        });\n    });\n    if (selectionRange === 0) {\n        return false;\n    }\n    // calculate range of matched mark\n    const matchedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === markRange.mark.type.name;\n    }).filter((markRange)=>objectIncludes(markRange.mark.attrs, attributes, {\n            strict: false\n        })).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    // calculate range of marks that excludes the searched mark\n    // for example `code` doesn’t allow any other marks\n    const excludedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n    }).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    // we only include the result of `excludedRange`\n    // if there is a match at all\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n    return range >= selectionRange;\n}\nfunction isActive(state, name, attributes = {}) {\n    if (!name) {\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n    }\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\n    if (schemaType === \"node\") {\n        return isNodeActive(state, name, attributes);\n    }\n    if (schemaType === \"mark\") {\n        return isMarkActive(state, name, attributes);\n    }\n    return false;\n}\nconst isAtEndOfNode = (state, nodeType)=>{\n    const { $from, $to, $anchor } = state.selection;\n    if (nodeType) {\n        const parentNode = findParentNode((node)=>node.type.name === nodeType)(state.selection);\n        if (!parentNode) {\n            return false;\n        }\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\n        if ($anchor.pos + 1 === $parentPos.end()) {\n            return true;\n        }\n        return false;\n    }\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\nconst isAtStartOfNode = (state)=>{\n    const { $from, $to } = state.selection;\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\nfunction isList(name, extensions) {\n    const { nodeExtensions } = splitExtensions(extensions);\n    const extension = nodeExtensions.find((item)=>item.name === name);\n    if (!extension) {\n        return false;\n    }\n    const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n    };\n    const group = callOrReturn(getExtensionField(extension, \"group\", context));\n    if (typeof group !== \"string\") {\n        return false;\n    }\n    return group.split(\" \").includes(\"list\");\n}\nfunction isNodeEmpty(node) {\n    var _a;\n    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n    const content = node.toJSON();\n    return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n    const minPos = 0;\n    const maxPos = view.state.doc.content.size;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const start = view.coordsAtPos(resolvedFrom);\n    const end = view.coordsAtPos(resolvedEnd, -1);\n    const top = Math.min(start.top, end.top);\n    const bottom = Math.max(start.bottom, end.bottom);\n    const left = Math.min(start.left, end.left);\n    const right = Math.max(start.right, end.right);\n    const width = right - left;\n    const height = bottom - top;\n    const x = left;\n    const y = top;\n    const data = {\n        top,\n        bottom,\n        left,\n        right,\n        width,\n        height,\n        x,\n        y\n    };\n    return {\n        ...data,\n        toJSON: ()=>data\n    };\n}\nfunction canSetMark(state, tr, newMarkType) {\n    var _a;\n    const { selection } = tr;\n    let cursor = null;\n    if (isTextSelection(selection)) {\n        cursor = selection.$cursor;\n    }\n    if (cursor) {\n        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n        // There can be no current marks that exclude the new mark\n        return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark)=>mark.type.excludes(newMarkType));\n    }\n    const { ranges } = selection;\n    return ranges.some(({ $from, $to })=>{\n        let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent)=>{\n            // If we already found a mark that we can enable, return false to bypass the remaining search\n            if (someNodeSupportsMark) {\n                return false;\n            }\n            if (node.isInline) {\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark)=>otherMark.type.excludes(newMarkType));\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n            }\n            return !someNodeSupportsMark;\n        });\n        return someNodeSupportsMark;\n    });\n}\nconst setMark = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        const type = getMarkType(typeOrName, state.schema);\n        if (dispatch) {\n            if (empty) {\n                const oldAttributes = getMarkAttributes(state, type);\n                tr.addStoredMark(type.create({\n                    ...oldAttributes,\n                    ...attributes\n                }));\n            } else {\n                ranges.forEach((range)=>{\n                    const from = range.$from.pos;\n                    const to = range.$to.pos;\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        const trimmedFrom = Math.max(pos, from);\n                        const trimmedTo = Math.min(pos + node.nodeSize, to);\n                        const someHasMark = node.marks.find((mark)=>mark.type === type);\n                        // if there is already a mark of this type\n                        // we know that we have to merge its attributes\n                        // otherwise we add a fresh new mark\n                        if (someHasMark) {\n                            node.marks.forEach((mark)=>{\n                                if (type === mark.type) {\n                                    tr.addMark(trimmedFrom, trimmedTo, type.create({\n                                        ...mark.attrs,\n                                        ...attributes\n                                    }));\n                                }\n                            });\n                        } else {\n                            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n                        }\n                    });\n                });\n            }\n        }\n        return canSetMark(state, tr, type);\n    };\nconst setMeta = (key, value)=>({ tr })=>{\n        tr.setMeta(key, value);\n        return true;\n    };\nconst setNode = (typeOrName, attributes = {})=>({ state, dispatch, chain })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        // TODO: use a fallback like insertContent?\n        if (!type.isTextblock) {\n            console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n            return false;\n        }\n        return chain()// try to convert node to default node if needed\n        .command(({ commands })=>{\n            const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, attributes)(state);\n            if (canSetBlock) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).command(({ state: updatedState })=>{\n            return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, attributes)(updatedState, dispatch);\n        }).run();\n    };\nconst setNodeSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const from = minMax(position, 0, doc.content.size);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst setTextSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : position;\n            const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\n            const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\n            const resolvedFrom = minMax(from, minPos, maxPos);\n            const resolvedEnd = minMax(to, minPos, maxPos);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst sinkListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\n    };\nfunction ensureMarks(state, splittableMarks) {\n    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) {\n        const filteredMarks = marks.filter((mark)=>splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n        state.tr.ensureMarks(filteredMarks);\n    }\n}\nconst splitBlock = ({ keepMarks = true } = {})=>({ tr, state, dispatch, editor })=>{\n        const { selection, doc } = tr;\n        const { $from, $to } = selection;\n        const extensionAttributes = editor.extensionManager.attributes;\n        const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n        if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {\n                return false;\n            }\n            if (dispatch) {\n                if (keepMarks) {\n                    ensureMarks(state, editor.extensionManager.splittableMarks);\n                }\n                tr.split($from.pos).scrollIntoView();\n            }\n            return true;\n        }\n        if (!$from.parent.isBlock) {\n            return false;\n        }\n        if (dispatch) {\n            const atEnd = $to.parentOffset === $to.parent.content.size;\n            if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n                tr.deleteSelection();\n            }\n            const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let types = atEnd && deflt ? [\n                {\n                    type: deflt,\n                    attrs: newAttributes\n                }\n            ] : undefined;\n            let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined)) {\n                can = true;\n                types = deflt ? [\n                    {\n                        type: deflt,\n                        attrs: newAttributes\n                    }\n                ] : undefined;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n                    const first = tr.mapping.map($from.before());\n                    const $first = tr.doc.resolve(first);\n                    if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                    }\n                }\n            }\n            if (keepMarks) {\n                ensureMarks(state, editor.extensionManager.splittableMarks);\n            }\n            tr.scrollIntoView();\n        }\n        return true;\n    };\nconst splitListItem = (typeOrName)=>({ tr, state, dispatch, editor })=>{\n        var _a;\n        const type = getNodeType(typeOrName, state.schema);\n        const { $from, $to } = state.selection;\n        // @ts-ignore\n        // eslint-disable-next-line\n        const node = state.selection.node;\n        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== type) {\n            return false;\n        }\n        const extensionAttributes = editor.extensionManager.attributes;\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n                // eslint-disable-next-line\n                const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for(let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1){\n                    wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n                }\n                // eslint-disable-next-line\n                const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n                const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n                wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType) || undefined));\n                const start = $from.before($from.depth - (depthBefore - 1));\n                tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos)=>{\n                    if (sel > -1) {\n                        return false;\n                    }\n                    if (n.isTextblock && n.content.size === 0) {\n                        sel = pos + 1;\n                    }\n                });\n                if (sel > -1) {\n                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\n                }\n                tr.scrollIntoView();\n            }\n            return true;\n        }\n        const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n        const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n        tr.delete($from.pos, $to.pos);\n        const types = nextType ? [\n            {\n                type,\n                attrs: newTypeAttributes\n            },\n            {\n                type: nextType,\n                attrs: newNextTypeAttributes\n            }\n        ] : [\n            {\n                type,\n                attrs: newTypeAttributes\n            }\n        ];\n        if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {\n            return false;\n        }\n        if (dispatch) {\n            const { selection, storedMarks } = state;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            tr.split($from.pos, 2, types).scrollIntoView();\n            if (!marks || !dispatch) {\n                return true;\n            }\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n        }\n        return true;\n    };\nconst joinListBackwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n    if (before === undefined) {\n        return true;\n    }\n    const nodeBefore = tr.doc.nodeAt(before);\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);\n    if (!canJoinBackwards) {\n        return true;\n    }\n    tr.join(list.pos);\n    return true;\n};\nconst joinListForwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const after = tr.doc.resolve(list.start).after(list.depth);\n    if (after === undefined) {\n        return true;\n    }\n    const nodeAfter = tr.doc.nodeAt(after);\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);\n    if (!canJoinForwards) {\n        return true;\n    }\n    tr.join(after);\n    return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {})=>({ editor, tr, state, dispatch, chain, commands, can })=>{\n        const { extensions, splittableMarks } = editor.extensionManager;\n        const listType = getNodeType(listTypeOrName, state.schema);\n        const itemType = getNodeType(itemTypeOrName, state.schema);\n        const { selection, storedMarks } = state;\n        const { $from, $to } = selection;\n        const range = $from.blockRange($to);\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (!range) {\n            return false;\n        }\n        const parentList = findParentNode((node)=>isList(node.type.name, extensions))(selection);\n        if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n            // remove list\n            if (parentList.node.type === listType) {\n                return commands.liftListItem(itemType);\n            }\n            // change list type\n            if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n                return chain().command(()=>{\n                    tr.setNodeMarkup(parentList.pos, listType);\n                    return true;\n                }).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n            }\n        }\n        if (!keepMarks || !marks || !dispatch) {\n            return chain()// try to convert node to default node if needed\n            .command(()=>{\n                const canWrapInList = can().wrapInList(listType, attributes);\n                if (canWrapInList) {\n                    return true;\n                }\n                return commands.clearNodes();\n            }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n        }\n        return chain()// try to convert node to default node if needed\n        .command(()=>{\n            const canWrapInList = can().wrapInList(listType, attributes);\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n            if (canWrapInList) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n    };\nconst toggleMark = (typeOrName, attributes = {}, options = {})=>({ state, commands })=>{\n        const { extendEmptyMarkRange = false } = options;\n        const type = getMarkType(typeOrName, state.schema);\n        const isActive = isMarkActive(state, type, attributes);\n        if (isActive) {\n            return commands.unsetMark(type, {\n                extendEmptyMarkRange\n            });\n        }\n        return commands.setMark(type, attributes);\n    };\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const toggleType = getNodeType(toggleTypeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (isActive) {\n            return commands.setNode(toggleType);\n        }\n        return commands.setNode(type, attributes);\n    };\nconst toggleWrap = (typeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (isActive) {\n            return commands.lift(type);\n        }\n        return commands.wrapIn(type, attributes);\n    };\nconst undoInputRule = ()=>({ state, dispatch })=>{\n        const plugins = state.plugins;\n        for(let i = 0; i < plugins.length; i += 1){\n            const plugin = plugins[i];\n            let undoable;\n            // @ts-ignore\n            // eslint-disable-next-line\n            if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n                if (dispatch) {\n                    const tr = state.tr;\n                    const toUndo = undoable.transform;\n                    for(let j = toUndo.steps.length - 1; j >= 0; j -= 1){\n                        tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                    }\n                    if (undoable.text) {\n                        const marks = tr.doc.resolve(undoable.from).marks();\n                        tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                    } else {\n                        tr.delete(undoable.from, undoable.to);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst unsetAllMarks = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        if (empty) {\n            return true;\n        }\n        if (dispatch) {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos);\n            });\n        }\n        return true;\n    };\nconst unsetMark = (typeOrName, options = {})=>({ tr, state, dispatch })=>{\n        var _a;\n        const { extendEmptyMarkRange = false } = options;\n        const { selection } = tr;\n        const type = getMarkType(typeOrName, state.schema);\n        const { $from, empty, ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        if (empty && extendEmptyMarkRange) {\n            let { from, to } = selection;\n            const attrs = (_a = $from.marks().find((mark)=>mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n            const range = getMarkRange($from, type, attrs);\n            if (range) {\n                from = range.from;\n                to = range.to;\n            }\n            tr.removeMark(from, to, type);\n        } else {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos, type);\n            });\n        }\n        tr.removeStoredMark(type);\n        return true;\n    };\nconst updateAttributes = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        if (dispatch) {\n            tr.selection.ranges.forEach((range)=>{\n                const from = range.$from.pos;\n                const to = range.$to.pos;\n                state.doc.nodesBetween(from, to, (node, pos)=>{\n                    if (nodeType && nodeType === node.type) {\n                        tr.setNodeMarkup(pos, undefined, {\n                            ...node.attrs,\n                            ...attributes\n                        });\n                    }\n                    if (markType && node.marks.length) {\n                        node.marks.forEach((mark)=>{\n                            if (markType === mark.type) {\n                                const trimmedFrom = Math.max(pos, from);\n                                const trimmedTo = Math.min(pos + node.nodeSize, to);\n                                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                                    ...mark.attrs,\n                                    ...attributes\n                                }));\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        return true;\n    };\nconst wrapIn = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\n    };\nconst wrapInList = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\n    };\nvar commands = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    blur: blur,\n    clearContent: clearContent,\n    clearNodes: clearNodes,\n    command: command,\n    createParagraphNear: createParagraphNear,\n    cut: cut,\n    deleteCurrentNode: deleteCurrentNode,\n    deleteNode: deleteNode,\n    deleteRange: deleteRange,\n    deleteSelection: deleteSelection,\n    enter: enter,\n    exitCode: exitCode,\n    extendMarkRange: extendMarkRange,\n    first: first,\n    focus: focus,\n    forEach: forEach,\n    insertContent: insertContent,\n    insertContentAt: insertContentAt,\n    joinUp: joinUp,\n    joinDown: joinDown,\n    joinBackward: joinBackward,\n    joinForward: joinForward,\n    joinItemBackward: joinItemBackward,\n    joinItemForward: joinItemForward,\n    joinTextblockBackward: joinTextblockBackward,\n    joinTextblockForward: joinTextblockForward,\n    keyboardShortcut: keyboardShortcut,\n    lift: lift,\n    liftEmptyBlock: liftEmptyBlock,\n    liftListItem: liftListItem,\n    newlineInCode: newlineInCode,\n    resetAttributes: resetAttributes,\n    scrollIntoView: scrollIntoView,\n    selectAll: selectAll,\n    selectNodeBackward: selectNodeBackward,\n    selectNodeForward: selectNodeForward,\n    selectParentNode: selectParentNode,\n    selectTextblockEnd: selectTextblockEnd,\n    selectTextblockStart: selectTextblockStart,\n    setContent: setContent,\n    setMark: setMark,\n    setMeta: setMeta,\n    setNode: setNode,\n    setNodeSelection: setNodeSelection,\n    setTextSelection: setTextSelection,\n    sinkListItem: sinkListItem,\n    splitBlock: splitBlock,\n    splitListItem: splitListItem,\n    toggleList: toggleList,\n    toggleMark: toggleMark,\n    toggleNode: toggleNode,\n    toggleWrap: toggleWrap,\n    undoInputRule: undoInputRule,\n    unsetAllMarks: unsetAllMarks,\n    unsetMark: unsetMark,\n    updateAttributes: updateAttributes,\n    wrapIn: wrapIn,\n    wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n    name: \"commands\",\n    addCommands () {\n        return {\n            ...commands\n        };\n    }\n});\nconst Editable = Extension.create({\n    name: \"editable\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"editable\"),\n                props: {\n                    editable: ()=>this.editor.options.editable\n                }\n            })\n        ];\n    }\n});\nconst FocusEvents = Extension.create({\n    name: \"focusEvents\",\n    addProseMirrorPlugins () {\n        const { editor } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focusEvents\"),\n                props: {\n                    handleDOMEvents: {\n                        focus: (view, event)=>{\n                            editor.isFocused = true;\n                            const transaction = editor.state.tr.setMeta(\"focus\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                        blur: (view, event)=>{\n                            editor.isFocused = false;\n                            const transaction = editor.state.tr.setMeta(\"blur\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        }\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Keymap = Extension.create({\n    name: \"keymap\",\n    addKeyboardShortcuts () {\n        const handleBackspace = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.undoInputRule(),\n                    // maybe convert first text block node to default node\n                    ()=>commands.command(({ tr })=>{\n                            const { selection, doc } = tr;\n                            const { empty, $anchor } = selection;\n                            const { pos, parent } = $anchor;\n                            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n                            const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n                            const parentPos = $anchor.pos - $anchor.parentOffset;\n                            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\n                            if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\" // prevent clearNodes when no nodes to clear, otherwise history stack is appended\n                            ) {\n                                return false;\n                            }\n                            return commands.clearNodes();\n                        }),\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.joinBackward(),\n                    ()=>commands.selectNodeBackward()\n                ]);\n        const handleDelete = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.deleteCurrentNode(),\n                    ()=>commands.joinForward(),\n                    ()=>commands.selectNodeForward()\n                ]);\n        const handleEnter = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.newlineInCode(),\n                    ()=>commands.createParagraphNear(),\n                    ()=>commands.liftEmptyBlock(),\n                    ()=>commands.splitBlock()\n                ]);\n        const baseKeymap = {\n            Enter: handleEnter,\n            \"Mod-Enter\": ()=>this.editor.commands.exitCode(),\n            Backspace: handleBackspace,\n            \"Mod-Backspace\": handleBackspace,\n            \"Shift-Backspace\": handleBackspace,\n            Delete: handleDelete,\n            \"Mod-Delete\": handleDelete,\n            \"Mod-a\": ()=>this.editor.commands.selectAll()\n        };\n        const pcKeymap = {\n            ...baseKeymap\n        };\n        const macKeymap = {\n            ...baseKeymap,\n            \"Ctrl-h\": handleBackspace,\n            \"Alt-Backspace\": handleBackspace,\n            \"Ctrl-d\": handleDelete,\n            \"Ctrl-Alt-Backspace\": handleDelete,\n            \"Alt-Delete\": handleDelete,\n            \"Alt-d\": handleDelete,\n            \"Ctrl-a\": ()=>this.editor.commands.selectTextblockStart(),\n            \"Ctrl-e\": ()=>this.editor.commands.selectTextblockEnd()\n        };\n        if (isiOS() || isMacOS()) {\n            return macKeymap;\n        }\n        return pcKeymap;\n    },\n    addProseMirrorPlugins () {\n        return [\n            // With this plugin we check if the whole document was selected and deleted.\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n            // to a paragraph if necessary.\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n            // with many other commands.\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clearDocument\"),\n                appendTransaction: (transactions, oldState, newState)=>{\n                    const docChanges = transactions.some((transaction)=>transaction.docChanged) && !oldState.doc.eq(newState.doc);\n                    if (!docChanges) {\n                        return;\n                    }\n                    const { empty, from, to } = oldState.selection;\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\n                    const allWasSelected = from === allFrom && to === allEnd;\n                    if (empty || !allWasSelected) {\n                        return;\n                    }\n                    const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, \" \", \" \").length === 0;\n                    if (!isEmpty) {\n                        return;\n                    }\n                    const tr = newState.tr;\n                    const state = createChainableState({\n                        state: newState,\n                        transaction: tr\n                    });\n                    const { commands } = new CommandManager({\n                        editor: this.editor,\n                        state\n                    });\n                    commands.clearNodes();\n                    if (!tr.steps.length) {\n                        return;\n                    }\n                    return tr;\n                }\n            })\n        ];\n    }\n});\nconst Tabindex = Extension.create({\n    name: \"tabindex\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tabindex\"),\n                props: {\n                    attributes: this.editor.isEditable ? {\n                        tabindex: \"0\"\n                    } : {}\n                }\n            })\n        ];\n    }\n});\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ClipboardTextSerializer: ClipboardTextSerializer,\n    Commands: Commands,\n    Editable: Editable,\n    FocusEvents: FocusEvents,\n    Keymap: Keymap,\n    Tabindex: Tabindex\n});\nclass NodePos {\n    constructor(pos, editor, isBlock = false, node = null){\n        this.currentNode = null;\n        this.actualDepth = null;\n        this.isBlock = isBlock;\n        this.resolvedPos = pos;\n        this.editor = editor;\n        this.currentNode = node;\n    }\n    get name() {\n        return this.node.type.name;\n    }\n    get node() {\n        return this.currentNode || this.resolvedPos.node();\n    }\n    get element() {\n        return this.editor.view.domAtPos(this.pos).node;\n    }\n    get depth() {\n        var _a;\n        return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;\n    }\n    get pos() {\n        return this.resolvedPos.pos;\n    }\n    get content() {\n        return this.node.content;\n    }\n    set content(content) {\n        let from = this.from;\n        let to = this.to;\n        if (this.isBlock) {\n            if (this.content.size === 0) {\n                console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n                return;\n            }\n            from = this.from + 1;\n            to = this.to - 1;\n        }\n        this.editor.commands.insertContentAt({\n            from,\n            to\n        }, content);\n    }\n    get attributes() {\n        return this.node.attrs;\n    }\n    get textContent() {\n        return this.node.textContent;\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get from() {\n        if (this.isBlock) {\n            return this.pos;\n        }\n        return this.resolvedPos.start(this.resolvedPos.depth);\n    }\n    get range() {\n        return {\n            from: this.from,\n            to: this.to\n        };\n    }\n    get to() {\n        if (this.isBlock) {\n            return this.pos + this.size;\n        }\n        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n    }\n    get parent() {\n        if (this.depth === 0) {\n            return null;\n        }\n        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n        const $pos = this.resolvedPos.doc.resolve(parentPos);\n        return new NodePos($pos, this.editor);\n    }\n    get before() {\n        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.from - 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get after() {\n        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.to + 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get children() {\n        const children = [];\n        this.node.content.forEach((node, offset)=>{\n            const isBlock = node.isBlock && !node.isTextblock;\n            const targetPos = this.pos + offset + 1;\n            const $pos = this.resolvedPos.doc.resolve(targetPos);\n            if (!isBlock && $pos.depth <= this.depth) {\n                return;\n            }\n            const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n            if (isBlock) {\n                childNodePos.actualDepth = this.depth + 1;\n            }\n            children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n        });\n        return children;\n    }\n    get firstChild() {\n        return this.children[0] || null;\n    }\n    get lastChild() {\n        const children = this.children;\n        return children[children.length - 1] || null;\n    }\n    closest(selector, attributes = {}) {\n        let node = null;\n        let currentNode = this.parent;\n        while(currentNode && !node){\n            if (currentNode.node.type.name === selector) {\n                if (Object.keys(attributes).length > 0) {\n                    const nodeAttributes = currentNode.node.attrs;\n                    const attrKeys = Object.keys(attributes);\n                    for(let index = 0; index < attrKeys.length; index += 1){\n                        const key = attrKeys[index];\n                        if (nodeAttributes[key] !== attributes[key]) {\n                            break;\n                        }\n                    }\n                } else {\n                    node = currentNode;\n                }\n            }\n            currentNode = currentNode.parent;\n        }\n        return node;\n    }\n    querySelector(selector, attributes = {}) {\n        return this.querySelectorAll(selector, attributes, true)[0] || null;\n    }\n    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n        let nodes = [];\n        if (!this.children || this.children.length === 0) {\n            return nodes;\n        }\n        const attrKeys = Object.keys(attributes);\n        /**\r\n         * Finds all children recursively that match the selector and attributes\r\n         * If firstItemOnly is true, it will return the first item found\r\n         */ this.children.forEach((childPos)=>{\n            // If we already found a node and we only want the first item, we dont need to keep going\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            if (childPos.node.type.name === selector) {\n                const doesAllAttributesMatch = attrKeys.every((key)=>attributes[key] === childPos.node.attrs[key]);\n                if (doesAllAttributesMatch) {\n                    nodes.push(childPos);\n                }\n            }\n            // If we already found a node and we only want the first item, we can stop here and skip the recursion\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n        });\n        return nodes;\n    }\n    setAttribute(attributes) {\n        const oldSelection = this.editor.state.selection;\n        this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();\n    }\n}\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce, suffix) {\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n    if (tiptapStyleTag !== null) {\n        return tiptapStyleTag;\n    }\n    const styleNode = document.createElement(\"style\");\n    if (nonce) {\n        styleNode.setAttribute(\"nonce\", nonce);\n    }\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n    styleNode.innerHTML = style;\n    document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n    return styleNode;\n}\nclass Editor extends EventEmitter {\n    constructor(options = {}){\n        super();\n        this.isFocused = false;\n        this.extensionStorage = {};\n        this.options = {\n            element: document.createElement(\"div\"),\n            content: \"\",\n            injectCSS: true,\n            injectNonce: undefined,\n            extensions: [],\n            autofocus: false,\n            editable: true,\n            editorProps: {},\n            parseOptions: {},\n            coreExtensionOptions: {},\n            enableInputRules: true,\n            enablePasteRules: true,\n            enableCoreExtensions: true,\n            onBeforeCreate: ()=>null,\n            onCreate: ()=>null,\n            onUpdate: ()=>null,\n            onSelectionUpdate: ()=>null,\n            onTransaction: ()=>null,\n            onFocus: ()=>null,\n            onBlur: ()=>null,\n            onDestroy: ()=>null\n        };\n        this.isCapturingTransaction = false;\n        this.capturedTransaction = null;\n        this.setOptions(options);\n        this.createExtensionManager();\n        this.createCommandManager();\n        this.createSchema();\n        this.on(\"beforeCreate\", this.options.onBeforeCreate);\n        this.emit(\"beforeCreate\", {\n            editor: this\n        });\n        this.createView();\n        this.injectCSS();\n        this.on(\"create\", this.options.onCreate);\n        this.on(\"update\", this.options.onUpdate);\n        this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n        this.on(\"transaction\", this.options.onTransaction);\n        this.on(\"focus\", this.options.onFocus);\n        this.on(\"blur\", this.options.onBlur);\n        this.on(\"destroy\", this.options.onDestroy);\n        window.setTimeout(()=>{\n            if (this.isDestroyed) {\n                return;\n            }\n            this.commands.focus(this.options.autofocus);\n            this.emit(\"create\", {\n                editor: this\n            });\n        }, 0);\n    }\n    /**\r\n     * Returns the editor storage.\r\n     */ get storage() {\n        return this.extensionStorage;\n    }\n    /**\r\n     * An object of all registered commands.\r\n     */ get commands() {\n        return this.commandManager.commands;\n    }\n    /**\r\n     * Create a command chain to call multiple commands at once.\r\n     */ chain() {\n        return this.commandManager.chain();\n    }\n    /**\r\n     * Check if a command or a command chain can be executed. Without executing it.\r\n     */ can() {\n        return this.commandManager.can();\n    }\n    /**\r\n     * Inject CSS styles.\r\n     */ injectCSS() {\n        if (this.options.injectCSS && document) {\n            this.css = createStyleTag(style, this.options.injectNonce);\n        }\n    }\n    /**\r\n     * Update editor options.\r\n     *\r\n     * @param options A list of options\r\n     */ setOptions(options = {}) {\n        this.options = {\n            ...this.options,\n            ...options\n        };\n        if (!this.view || !this.state || this.isDestroyed) {\n            return;\n        }\n        if (this.options.editorProps) {\n            this.view.setProps(this.options.editorProps);\n        }\n        this.view.updateState(this.state);\n    }\n    /**\r\n     * Update editable state of the editor.\r\n     */ setEditable(editable, emitUpdate = true) {\n        this.setOptions({\n            editable\n        });\n        if (emitUpdate) {\n            this.emit(\"update\", {\n                editor: this,\n                transaction: this.state.tr\n            });\n        }\n    }\n    /**\r\n     * Returns whether the editor is editable.\r\n     */ get isEditable() {\n        // since plugins are applied after creating the view\n        // `editable` is always `true` for one tick.\n        // that’s why we also have to check for `options.editable`\n        return this.options.editable && this.view && this.view.editable;\n    }\n    /**\r\n     * Returns the editor state.\r\n     */ get state() {\n        return this.view.state;\n    }\n    /**\r\n     * Register a ProseMirror plugin.\r\n     *\r\n     * @param plugin A ProseMirror plugin\r\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n     */ registerPlugin(plugin, handlePlugins) {\n        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [\n            ...this.state.plugins\n        ]) : [\n            ...this.state.plugins,\n            plugin\n        ];\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n    }\n    /**\r\n     * Unregister a ProseMirror plugin.\r\n     *\r\n     * @param nameOrPluginKey The plugins name\r\n     */ unregisterPlugin(nameOrPluginKey) {\n        if (this.isDestroyed) {\n            return;\n        }\n        // @ts-ignore\n        const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n        const state = this.state.reconfigure({\n            // @ts-ignore\n            plugins: this.state.plugins.filter((plugin)=>!plugin.key.startsWith(name))\n        });\n        this.view.updateState(state);\n    }\n    /**\r\n     * Creates an extension manager.\r\n     */ createExtensionManager() {\n        var _a, _b;\n        const coreExtensions = this.options.enableCoreExtensions ? [\n            Editable,\n            ClipboardTextSerializer.configure({\n                blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator\n            }),\n            Commands,\n            FocusEvents,\n            Keymap,\n            Tabindex\n        ] : [];\n        const allExtensions = [\n            ...coreExtensions,\n            ...this.options.extensions\n        ].filter((extension)=>{\n            return [\n                \"extension\",\n                \"node\",\n                \"mark\"\n            ].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n        });\n        this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\r\n     * Creates an command manager.\r\n     */ createCommandManager() {\n        this.commandManager = new CommandManager({\n            editor: this\n        });\n    }\n    /**\r\n     * Creates a ProseMirror schema.\r\n     */ createSchema() {\n        this.schema = this.extensionManager.schema;\n    }\n    /**\r\n     * Creates a ProseMirror view.\r\n     */ createView() {\n        const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\n        this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, {\n            ...this.options.editorProps,\n            dispatchTransaction: this.dispatchTransaction.bind(this),\n            state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                doc,\n                selection: selection || undefined\n            })\n        });\n        // `editor.view` is not yet available at this time.\n        // Therefore we will add all plugins and node views directly afterwards.\n        const newState = this.state.reconfigure({\n            plugins: this.extensionManager.plugins\n        });\n        this.view.updateState(newState);\n        this.createNodeViews();\n        this.prependClass();\n        // Let’s store the editor instance in the DOM element.\n        // So we’ll have access to it for tests.\n        const dom = this.view.dom;\n        dom.editor = this;\n    }\n    /**\r\n     * Creates all node views.\r\n     */ createNodeViews() {\n        this.view.setProps({\n            nodeViews: this.extensionManager.nodeViews\n        });\n    }\n    /**\r\n     * Prepend class name to element.\r\n     */ prependClass() {\n        this.view.dom.className = `tiptap ${this.view.dom.className}`;\n    }\n    captureTransaction(fn) {\n        this.isCapturingTransaction = true;\n        fn();\n        this.isCapturingTransaction = false;\n        const tr = this.capturedTransaction;\n        this.capturedTransaction = null;\n        return tr;\n    }\n    /**\r\n     * The callback over which to send transactions (state updates) produced by the view.\r\n     *\r\n     * @param transaction An editor state transaction\r\n     */ dispatchTransaction(transaction) {\n        // if the editor / the view of the editor was destroyed\n        // the transaction should not be dispatched as there is no view anymore.\n        if (this.view.isDestroyed) {\n            return;\n        }\n        if (this.isCapturingTransaction) {\n            if (!this.capturedTransaction) {\n                this.capturedTransaction = transaction;\n                return;\n            }\n            transaction.steps.forEach((step)=>{\n                var _a;\n                return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n            });\n            return;\n        }\n        const state = this.state.apply(transaction);\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\n        this.view.updateState(state);\n        this.emit(\"transaction\", {\n            editor: this,\n            transaction\n        });\n        if (selectionHasChanged) {\n            this.emit(\"selectionUpdate\", {\n                editor: this,\n                transaction\n            });\n        }\n        const focus = transaction.getMeta(\"focus\");\n        const blur = transaction.getMeta(\"blur\");\n        if (focus) {\n            this.emit(\"focus\", {\n                editor: this,\n                event: focus.event,\n                transaction\n            });\n        }\n        if (blur) {\n            this.emit(\"blur\", {\n                editor: this,\n                event: blur.event,\n                transaction\n            });\n        }\n        if (!transaction.docChanged || transaction.getMeta(\"preventUpdate\")) {\n            return;\n        }\n        this.emit(\"update\", {\n            editor: this,\n            transaction\n        });\n    }\n    /**\r\n     * Get attributes of the currently selected node or mark.\r\n     */ getAttributes(nameOrType) {\n        return getAttributes(this.state, nameOrType);\n    }\n    isActive(nameOrAttributes, attributesOrUndefined) {\n        const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n        const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n        return isActive(this.state, name, attributes);\n    }\n    /**\r\n     * Get the document as JSON.\r\n     */ getJSON() {\n        return this.state.doc.toJSON();\n    }\n    /**\r\n     * Get the document as HTML.\r\n     */ getHTML() {\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\n    }\n    /**\r\n     * Get the document as text.\r\n     */ getText(options) {\n        const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n        return getText(this.state.doc, {\n            blockSeparator,\n            textSerializers: {\n                ...getTextSerializersFromSchema(this.schema),\n                ...textSerializers\n            }\n        });\n    }\n    /**\r\n     * Check if there is no content.\r\n     */ get isEmpty() {\n        return isNodeEmpty(this.state.doc);\n    }\n    /**\r\n     * Get the number of characters for the current document.\r\n     *\r\n     * @deprecated\r\n     */ getCharacterCount() {\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n        return this.state.doc.content.size - 2;\n    }\n    /**\r\n     * Destroy the editor.\r\n     */ destroy() {\n        this.emit(\"destroy\");\n        if (this.view) {\n            this.view.destroy();\n        }\n        this.removeAllListeners();\n    }\n    /**\r\n     * Check if the editor is already destroyed.\r\n     */ get isDestroyed() {\n        var _a;\n        // @ts-ignore\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n    $node(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;\n    }\n    $nodes(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n    }\n    $pos(pos) {\n        const $pos = this.state.doc.resolve(pos);\n        return new NodePos($pos, this);\n    }\n    get $doc() {\n        return this.$pos(0);\n    }\n}\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n * @see https://tiptap.dev/guide/custom-extensions/#input-rules\r\n */ function markInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                const markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n * @see https://tiptap.dev/guide/custom-extensions/#input-rules\r\n */ function nodeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const { tr } = state;\n            const start = range.from;\n            let end = range.to;\n            const newNode = config.type.create(attributes);\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                let matchStart = start + offset;\n                if (matchStart > end) {\n                    matchStart = end;\n                } else {\n                    end = matchStart + match[1].length;\n                }\n                // insert last typed character\n                const lastChar = match[0][match[0].length - 1];\n                tr.insertText(lastChar, start + match[0].length - 1);\n                // insert node from input rule\n                tr.replaceWith(matchStart, end, newNode);\n            } else if (match[0]) {\n                tr.insert(start - 1, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n            }\n            tr.scrollIntoView();\n        }\n    });\n}\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n * @see https://tiptap.dev/guide/custom-extensions/#input-rules\r\n */ function textblockTypeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const $start = state.doc.resolve(range.from);\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n                return null;\n            }\n            state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n        }\n    });\n}\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n * @see https://tiptap.dev/guide/custom-extensions/#input-rules\r\n */ function textInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n * @see https://tiptap.dev/guide/custom-extensions/#input-rules\r\n */ function wrappingInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match, chain })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const tr = state.tr.delete(range.from, range.to);\n            const $start = tr.doc.resolve(range.from);\n            const blockRange = $start.blockRange();\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);\n            if (!wrapping) {\n                return null;\n            }\n            tr.wrap(blockRange, wrapping);\n            if (config.keepMarks && config.editor) {\n                const { selection, storedMarks } = state;\n                const { splittableMarks } = config.editor.extensionManager;\n                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                if (marks) {\n                    const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                    tr.ensureMarks(filteredMarks);\n                }\n            }\n            if (config.keepAttributes) {\n                /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */ const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n                chain().updateAttributes(nodeType, attributes).run();\n            }\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\n            if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n                tr.join(range.from - 1);\n            }\n        }\n    });\n}\n/**\r\n * The Mark class is used to create custom mark extensions.\r\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\r\n */ class Mark {\n    constructor(config = {}){\n        this.type = \"mark\";\n        this.name = \"mark\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Mark(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend();\n        extension.options = mergeDeep(this.options, options);\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Mark({\n            ...this.config,\n            ...extendedConfig\n        });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n    static handleExit({ editor, mark }) {\n        const { tr } = editor.state;\n        const currentPos = editor.state.selection.$from;\n        const isAtEnd = currentPos.pos === currentPos.end();\n        if (isAtEnd) {\n            const currentMarks = currentPos.marks();\n            const isInMark = !!currentMarks.find((m)=>(m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (!isInMark) {\n                return false;\n            }\n            const removeMark = currentMarks.find((m)=>(m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (removeMark) {\n                tr.removeStoredMark(removeMark);\n            }\n            tr.insertText(\" \", currentPos.pos);\n            editor.view.dispatch(tr);\n            return true;\n        }\n        return false;\n    }\n}\n/**\r\n * The Node class is used to create custom node extensions.\r\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\r\n */ class Node {\n    constructor(config = {}){\n        this.type = \"node\";\n        this.name = \"node\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Node(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend();\n        extension.options = mergeDeep(this.options, options);\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Node({\n            ...this.config,\n            ...extendedConfig\n        });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n}\nfunction isAndroid() {\n    return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\n/**\r\n * Node views are used to customize the rendered DOM structure of a node.\r\n * @see https://tiptap.dev/guide/node-views\r\n */ class NodeView {\n    constructor(component, props, options){\n        this.isDragging = false;\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            stopEvent: null,\n            ignoreMutation: null,\n            ...options\n        };\n        this.extension = props.extension;\n        this.node = props.node;\n        this.decorations = props.decorations;\n        this.getPos = props.getPos;\n        this.mount();\n    }\n    mount() {\n        // eslint-disable-next-line\n        return;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    onDragStart(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const { view } = this.editor;\n        const target = event.target;\n        // get the drag handle element\n        // `closest` is not available for text nodes so we may have to use its parent\n        const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        // calculate offset for drag element if we use a different drag handle element\n        if (this.dom !== dragHandle) {\n            const domBox = this.dom.getBoundingClientRect();\n            const handleBox = dragHandle.getBoundingClientRect();\n            // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n            x = handleBox.x - domBox.x + offsetX;\n            y = handleBox.y - domBox.y + offsetY;\n        }\n        (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n        // we need to tell ProseMirror that we want to move the whole node\n        // so we create a NodeSelection\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, this.getPos());\n        const transaction = view.state.tr.setSelection(selection);\n        view.dispatch(transaction);\n    }\n    stopEvent(event) {\n        var _a;\n        if (!this.dom) {\n            return false;\n        }\n        if (typeof this.options.stopEvent === \"function\") {\n            return this.options.stopEvent({\n                event\n            });\n        }\n        const target = event.target;\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n        // any event from child nodes should be handled by ProseMirror\n        if (!isInElement) {\n            return false;\n        }\n        const isDragEvent = event.type.startsWith(\"drag\");\n        const isDropEvent = event.type === \"drop\";\n        const isInput = [\n            \"INPUT\",\n            \"BUTTON\",\n            \"SELECT\",\n            \"TEXTAREA\"\n        ].includes(target.tagName) || target.isContentEditable;\n        // any input event within node views should be ignored by ProseMirror\n        if (isInput && !isDropEvent && !isDragEvent) {\n            return true;\n        }\n        const { isEditable } = this.editor;\n        const { isDragging } = this;\n        const isDraggable = !!this.node.type.spec.draggable;\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\n        const isCopyEvent = event.type === \"copy\";\n        const isPasteEvent = event.type === \"paste\";\n        const isCutEvent = event.type === \"cut\";\n        const isClickEvent = event.type === \"mousedown\";\n        // ProseMirror tries to drag selectable nodes\n        // even if `draggable` is set to `false`\n        // this fix prevents that\n        if (!isDraggable && isSelectable && isDragEvent) {\n            event.preventDefault();\n        }\n        if (isDraggable && isDragEvent && !isDragging) {\n            event.preventDefault();\n            return false;\n        }\n        // we have to store that dragging started\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\n            const dragHandle = target.closest(\"[data-drag-handle]\");\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n            if (isValidDragHandle) {\n                this.isDragging = true;\n                document.addEventListener(\"dragend\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"drop\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"mouseup\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n            }\n        }\n        // these events are handled by prosemirror\n        if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n            return false;\n        }\n        return true;\n    }\n    ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === \"function\") {\n            return this.options.ignoreMutation({\n                mutation\n            });\n        }\n        // a leaf/atom node is like a black box for ProseMirror\n        // and should be fully handled by the node view\n        if (this.node.isLeaf || this.node.isAtom) {\n            return true;\n        }\n        // ProseMirror should handle any selections\n        if (mutation.type === \"selection\") {\n            return false;\n        }\n        // try to prevent a bug on iOS and Android that will break node views on enter\n        // this is because ProseMirror can’t preventDispatch on enter\n        // this will lead to a re-render of the node view on enter\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\n        // see: https://github.com/ueberdosis/tiptap/issues/2534\n        if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes)\n            ];\n            // we’ll check if every changed node is contentEditable\n            // to make sure it’s probably mutated by ProseMirror\n            if (changedNodes.every((node)=>node.isContentEditable)) {\n                return false;\n            }\n        }\n        // we will allow mutation contentDOM with attributes\n        // so we can for example adding classes within our node view\n        if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n            return true;\n        }\n        // ProseMirror should handle any changes within contentDOM\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n    updateAttributes(attributes) {\n        this.editor.commands.command(({ tr })=>{\n            const pos = this.getPos();\n            tr.setNodeMarkup(pos, undefined, {\n                ...this.node.attrs,\n                ...attributes\n            });\n            return true;\n        });\n    }\n    deleteNode() {\n        const from = this.getPos();\n        const to = from + this.node.nodeSize;\n        this.editor.commands.deleteRange({\n            from,\n            to\n        });\n    }\n}\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n * @see https://tiptap.dev/guide/custom-extensions/#paste-rules\r\n */ function markPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match, pasteEvent })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            let markEnd = range.to;\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n * @see https://tiptap.dev/guide/custom-extensions/#paste-rules\r\n */ function nodePasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler ({ match, chain, range, pasteEvent }) {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            if (match.input) {\n                chain().deleteRange(range).insertContentAt(range.from, {\n                    type: config.type.name,\n                    attrs: attributes\n                });\n            }\n        }\n    });\n}\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n * @see https://tiptap.dev/guide/custom-extensions/#paste-rules\r\n */ function textPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\nclass Tracker {\n    constructor(transaction){\n        this.transaction = transaction;\n        this.currentStep = this.transaction.steps.length;\n    }\n    map(position) {\n        let deleted = false;\n        const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step)=>{\n            const mapResult = step.getMap().mapResult(newPosition);\n            if (mapResult.deleted) {\n                deleted = true;\n            }\n            return mapResult.pos;\n        }, position);\n        return {\n            position: mappedPosition,\n            deleted\n        };\n    }\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkc7QUFDOUQ7QUFDRjtBQUMwRDtBQUNvQztBQUNzaUI7QUFDM2lCO0FBRXBJOzs7O0NBSUMsR0FDRCxTQUFTa0UscUJBQXFCQyxNQUFNO0lBQ2hDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxXQUFXLEVBQUUsR0FBR0Y7SUFDL0IsSUFBSSxFQUFFRyxTQUFTLEVBQUUsR0FBR0Q7SUFDcEIsSUFBSSxFQUFFRSxHQUFHLEVBQUUsR0FBR0Y7SUFDZCxJQUFJLEVBQUVHLFdBQVcsRUFBRSxHQUFHSDtJQUN0QixPQUFPO1FBQ0gsR0FBR0QsS0FBSztRQUNSSyxPQUFPTCxNQUFNSyxLQUFLLENBQUNDLElBQUksQ0FBQ047UUFDeEJPLGtCQUFrQlAsTUFBTU8sZ0JBQWdCLENBQUNELElBQUksQ0FBQ047UUFDOUNRLFNBQVNSLE1BQU1RLE9BQU87UUFDdEJDLFFBQVFULE1BQU1TLE1BQU07UUFDcEJDLGFBQWFWLE1BQU1VLFdBQVcsQ0FBQ0osSUFBSSxDQUFDTjtRQUNwQ1csUUFBUVgsTUFBTVcsTUFBTSxDQUFDTCxJQUFJLENBQUNOO1FBQzFCLElBQUlJLGVBQWM7WUFDZCxPQUFPQTtRQUNYO1FBQ0EsSUFBSUYsYUFBWTtZQUNaLE9BQU9BO1FBQ1g7UUFDQSxJQUFJQyxPQUFNO1lBQ04sT0FBT0E7UUFDWDtRQUNBLElBQUlTLE1BQUs7WUFDTFYsWUFBWUQsWUFBWUMsU0FBUztZQUNqQ0MsTUFBTUYsWUFBWUUsR0FBRztZQUNyQkMsY0FBY0gsWUFBWUcsV0FBVztZQUNyQyxPQUFPSDtRQUNYO0lBQ0o7QUFDSjtBQUVBLE1BQU1ZO0lBQ0ZDLFlBQVlDLEtBQUssQ0FBRTtRQUNmLElB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LFVBQVUvUSxLQUFLLENBQUMsRUFBRSxDQUFDa0UsS0FBSyxDQUFDcU8sU0FBU3ZTLEtBQUssQ0FBQyxFQUFFLENBQUNGLE1BQU07Z0JBQ2pEaUksU0FBU3dLO2dCQUNULE1BQU00WixTQUFTcGtCLFFBQVFDO2dCQUN2QixJQUFJbWtCLFNBQVMsR0FBRztvQkFDWnBiLFNBQVMvUSxLQUFLLENBQUMsRUFBRSxDQUFDa0UsS0FBSyxDQUFDcU8sU0FBUzRaLFFBQVE1WixVQUFVeEI7b0JBQ25EaEosUUFBUUM7Z0JBQ1o7WUFDSjtZQUNBdFAsTUFBTVksRUFBRSxDQUFDbWUsVUFBVSxDQUFDMUcsUUFBUWhKLE9BQU9DO1FBQ3ZDO0lBQ0o7QUFDSjtBQUVBLE1BQU04bkI7SUFDRnQyQixZQUFZYixXQUFXLENBQUU7UUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ28zQixXQUFXLEdBQUcsSUFBSSxDQUFDcDNCLFdBQVcsQ0FBQ2tOLEtBQUssQ0FBQy9GLE1BQU07SUFDcEQ7SUFDQXpGLElBQUlrWixRQUFRLEVBQUU7UUFDVixJQUFJeWMsVUFBVTtRQUNkLE1BQU1DLGlCQUFpQixJQUFJLENBQUN0M0IsV0FBVyxDQUFDa04sS0FBSyxDQUN4QzNCLEtBQUssQ0FBQyxJQUFJLENBQUM2ckIsV0FBVyxFQUN0QnB4QixNQUFNLENBQUMsQ0FBQ3V4QixhQUFhN1o7WUFDdEIsTUFBTThaLFlBQVk5WixLQUFLK1osTUFBTSxHQUFHRCxTQUFTLENBQUNEO1lBQzFDLElBQUlDLFVBQVVILE9BQU8sRUFBRTtnQkFDbkJBLFVBQVU7WUFDZDtZQUNBLE9BQU9HLFVBQVV4c0IsR0FBRztRQUN4QixHQUFHNFA7UUFDSCxPQUFPO1lBQ0hBLFVBQVUwYztZQUNWRDtRQUNKO0lBQ0o7QUFDSjtBQUVzOUMsQ0FDdDlDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcz9lNTQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uLCBTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3JztcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJztcbmltcG9ydCB7IFNjaGVtYSwgRnJhZ21lbnQsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgTm9kZSBhcyBOb2RlJDEsIFNsaWNlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBsaWZ0VGFyZ2V0LCBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGpvaW5Qb2ludCwgVHJhbnNmb3JtLCBjYW5TcGxpdCwgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nO1xuaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEsIGRlbGV0ZVNlbGVjdGlvbiBhcyBkZWxldGVTZWxlY3Rpb24kMSwgZXhpdENvZGUgYXMgZXhpdENvZGUkMSwgam9pblVwIGFzIGpvaW5VcCQxLCBqb2luRG93biBhcyBqb2luRG93biQxLCBqb2luQmFja3dhcmQgYXMgam9pbkJhY2t3YXJkJDEsIGpvaW5Gb3J3YXJkIGFzIGpvaW5Gb3J3YXJkJDEsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBqb2luVGV4dGJsb2NrQmFja3dhcmQkMSwgam9pblRleHRibG9ja0ZvcndhcmQgYXMgam9pblRleHRibG9ja0ZvcndhcmQkMSwgbGlmdCBhcyBsaWZ0JDEsIGxpZnRFbXB0eUJsb2NrIGFzIGxpZnRFbXB0eUJsb2NrJDEsIG5ld2xpbmVJbkNvZGUgYXMgbmV3bGluZUluQ29kZSQxLCBzZWxlY3ROb2RlQmFja3dhcmQgYXMgc2VsZWN0Tm9kZUJhY2t3YXJkJDEsIHNlbGVjdE5vZGVGb3J3YXJkIGFzIHNlbGVjdE5vZGVGb3J3YXJkJDEsIHNlbGVjdFBhcmVudE5vZGUgYXMgc2VsZWN0UGFyZW50Tm9kZSQxLCBzZWxlY3RUZXh0YmxvY2tFbmQgYXMgc2VsZWN0VGV4dGJsb2NrRW5kJDEsIHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEsIHNldEJsb2NrVHlwZSwgd3JhcEluIGFzIHdyYXBJbiQxIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcyc7XG5pbXBvcnQgeyBsaWZ0TGlzdEl0ZW0gYXMgbGlmdExpc3RJdGVtJDEsIHNpbmtMaXN0SXRlbSBhcyBzaW5rTGlzdEl0ZW0kMSwgd3JhcEluTGlzdCBhcyB3cmFwSW5MaXN0JDEgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0JztcblxuLyoqXHJcbiAqIFRha2VzIGEgVHJhbnNhY3Rpb24gJiBFZGl0b3IgU3RhdGUgYW5kIHR1cm5zIGl0IGludG8gYSBjaGFpbmFibGUgc3RhdGUgb2JqZWN0XHJcbiAqIEBwYXJhbSBjb25maWcgVGhlIHRyYW5zYWN0aW9uIGFuZCBzdGF0ZSB0byBjcmVhdGUgdGhlIGNoYWluYWJsZSBzdGF0ZSBmcm9tXHJcbiAqIEByZXR1cm5zIEEgY2hhaW5hYmxlIEVkaXRvciBzdGF0ZSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVN0YXRlKGNvbmZpZykge1xyXG4gICAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZztcclxuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XHJcbiAgICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGF0ZSxcclxuICAgICAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXHJcbiAgICAgICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcclxuICAgICAgICBwbHVnaW5zOiBzdGF0ZS5wbHVnaW5zLFxyXG4gICAgICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxyXG4gICAgICAgIHJlY29uZmlndXJlOiBzdGF0ZS5yZWNvbmZpZ3VyZS5iaW5kKHN0YXRlKSxcclxuICAgICAgICB0b0pTT046IHN0YXRlLnRvSlNPTi5iaW5kKHN0YXRlKSxcclxuICAgICAgICBnZXQgc3RvcmVkTWFya3MoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yZWRNYXJrcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgZG9jKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHRyKCkge1xyXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgIGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcclxuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrcztcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XHJcbiAgICAgICAgdGhpcy5yYXdDb21tYW5kcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuY29tbWFuZHM7XHJcbiAgICAgICAgdGhpcy5jdXN0b21TdGF0ZSA9IHByb3BzLnN0YXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0N1c3RvbVN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuY3VzdG9tU3RhdGU7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tU3RhdGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGU7XHJcbiAgICB9XHJcbiAgICBnZXQgY29tbWFuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcclxuICAgICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcclxuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0cik7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgbWV0aG9kXTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY2hhaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKTtcclxuICAgIH1cclxuICAgIGdldCBjYW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDaGFpbihzdGFydFRyLCBzaG91bGREaXNwYXRjaCA9IHRydWUpIHtcclxuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHI7XHJcbiAgICAgICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xyXG4gICAgICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFoYXNTdGFydFRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAmJiBzaG91bGREaXNwYXRjaFxyXG4gICAgICAgICAgICAgICAgJiYgIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpXHJcbiAgICAgICAgICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeShjYWxsYmFjayA9PiBjYWxsYmFjayA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjaGFpbiA9IHtcclxuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5lZENvbW1hbmQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZSwgY2hhaW5lZENvbW1hbmRdO1xyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIHJ1bixcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjaGFpbjtcclxuICAgIH1cclxuICAgIGNyZWF0ZUNhbihzdGFydFRyKSB7XHJcbiAgICAgICAgY29uc3QgeyByYXdDb21tYW5kcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHI7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIGRpc3BhdGNoKTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZCguLi5hcmdzKSh7IC4uLnByb3BzLCBkaXNwYXRjaDogdW5kZWZpbmVkIH0pXTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uZm9ybWF0dGVkQ29tbWFuZHMsXHJcbiAgICAgICAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBkaXNwYXRjaCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIHRyLFxyXG4gICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgIHZpZXcsXHJcbiAgICAgICAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIHNob3VsZERpc3BhdGNoKSxcclxuICAgICAgICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXHJcbiAgICAgICAgICAgIGdldCBjb21tYW5kcygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZCguLi5hcmdzKShwcm9wcyldO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudF0pIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGZuKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50LCBmbikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzLmZpbHRlcihjYWxsYmFjayA9PiBjYWxsYmFjayAhPT0gZm4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJlbW92ZUFsbExpc3RlbmVycygpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgZmllbGQgZnJvbSBhbiBleHRlbnNpb25cclxuICogQHBhcmFtIGV4dGVuc2lvbiBUaGUgVGlwdGFwIGV4dGVuc2lvblxyXG4gKiBAcGFyYW0gZmllbGQgVGhlIGZpZWxkLCBmb3IgZXhhbXBsZSBgcmVuZGVySFRNTGAgb3IgYHByaW9yaXR5YFxyXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGFzIGB0aGlzYCBpbnRvIHRoZSBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyBUaGUgZmllbGQgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcclxuICAgIGlmIChleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gdW5kZWZpbmVkICYmIGV4dGVuc2lvbi5wYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0uYmluZCh7XHJcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgICAgICAgIHBhcmVudDogZXh0ZW5zaW9uLnBhcmVudFxyXG4gICAgICAgICAgICAgICAgPyBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dClcclxuICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF07XHJcbn1cblxuZnVuY3Rpb24gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcclxuICAgIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJyk7XHJcbiAgICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ25vZGUnKTtcclxuICAgIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBiYXNlRXh0ZW5zaW9ucyxcclxuICAgICAgICBub2RlRXh0ZW5zaW9ucyxcclxuICAgICAgICBtYXJrRXh0ZW5zaW9ucyxcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxyXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBMaXN0IG9mIGV4dGVuc2lvbnNcclxuICovXHJcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XHJcbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gW107XHJcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XHJcbiAgICBjb25zdCBkZWZhdWx0QXR0cmlidXRlID0ge1xyXG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyZWQ6IHRydWUsXHJcbiAgICAgICAgcmVuZGVySFRNTDogbnVsbCxcclxuICAgICAgICBwYXJzZUhUTUw6IG51bGwsXHJcbiAgICAgICAga2VlcE9uU3BsaXQ6IHRydWUsXHJcbiAgICAgICAgaXNSZXF1aXJlZDogZmFsc2UsXHJcbiAgICB9O1xyXG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFkZEdsb2JhbEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRHbG9iYWxBdHRyaWJ1dGVzJywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCFhZGRHbG9iYWxBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhcyBHbG9iYWxBdHRyaWJ1dGVzYFxyXG4gICAgICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZXMgPSBhZGRHbG9iYWxBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcy5mb3JFYWNoKGdsb2JhbEF0dHJpYnV0ZSA9PiB7XHJcbiAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZS50eXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkQXR0cmlidXRlcycsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmICghYWRkQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgQXR0cmlidXRlc2BcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYWRkQXR0cmlidXRlcygpO1xyXG4gICAgICAgIE9iamVjdFxyXG4gICAgICAgICAgICAuZW50cmllcyhhdHRyaWJ1dGVzKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcclxuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXHJcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG1lcmdlZEF0dHIgPT09IG51bGwgfHwgbWVyZ2VkQXR0ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0ci5kZWZhdWx0ID0gbWVyZ2VkQXR0ci5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuaXNSZXF1aXJlZCkgJiYgKG1lcmdlZEF0dHIgPT09IG51bGwgfHwgbWVyZ2VkQXR0ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbWVyZ2VkQXR0ci5kZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IG1lcmdlZEF0dHIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlcztcclxufVxuXG5mdW5jdGlvbiBnZXROb2RlVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lT3JUeXBlO1xyXG59XG5cbmZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlcyguLi5vYmplY3RzKSB7XHJcbiAgICByZXR1cm4gb2JqZWN0c1xyXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiAhIWl0ZW0pXHJcbiAgICAgICAgLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcclxuICAgICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdHMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV07XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXMgPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KCcgJykgOiBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3NlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdCgnICcpIDogW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcih2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gWy4uLmV4aXN0aW5nQ2xhc3NlcywgLi4uaW5zZXJ0Q2xhc3Nlc10uam9pbignICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gW21lcmdlZEF0dHJpYnV0ZXNba2V5XSwgdmFsdWVdLmpvaW4oJzsgJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xyXG4gICAgfSwge30pO1xyXG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlT3JNYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xyXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcclxuICAgICAgICAubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmICghaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgW2l0ZW0ubmFtZV06IG5vZGVPck1hcmsuYXR0cnNbaXRlbS5uYW1lXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwobm9kZU9yTWFyay5hdHRycykgfHwge307XHJcbiAgICB9KVxyXG4gICAgICAgIC5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KTtcclxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG59XG5cbi8qKlxyXG4gKiBPcHRpb25hbGx5IGNhbGxzIGB2YWx1ZWAgYXMgYSBmdW5jdGlvbi5cclxuICogT3RoZXJ3aXNlIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LlxyXG4gKiBAcGFyYW0gdmFsdWUgRnVuY3Rpb24gb3IgYW55IHZhbHVlLlxyXG4gKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSBwcm9wcyBPcHRpb25hbCBwcm9wcyB0byBwYXNzIHRvIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsbE9yUmV0dXJuKHZhbHVlLCBjb250ZXh0ID0gdW5kZWZpbmVkLCAuLi5wcm9wcykge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJpbmQoY29udGV4dCkoLi4ucHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDAgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBtZXJnZXMgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgaW50byBwYXJzZXJ1bGUgYXR0cmlidXRlcyAoYGF0dHJzYCBvciBgZ2V0QXR0cnNgKS5cclxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cclxuICogQHBhcmFtIHBhcnNlUnVsZSBQcm9zZU1pcnJvciBQYXJzZVJ1bGVcclxuICogQHBhcmFtIGV4dGVuc2lvbkF0dHJpYnV0ZXMgTGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGluamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xyXG4gICAgaWYgKHBhcnNlUnVsZS5zdHlsZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZVJ1bGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnBhcnNlUnVsZSxcclxuICAgICAgICBnZXRBdHRyczogbm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnM7XHJcbiAgICAgICAgICAgIGlmIChvbGRBdHRyaWJ1dGVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSlcclxuICAgICAgICAgICAgICAgICAgICA6IGZyb21TdHJpbmcobm9kZS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uaXRlbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH07XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW0oZGF0YSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2F0dHJzJyAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfSkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IFByb3NlbWlycm9yIHNjaGVtYSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZXh0ZW5zaW9ucy5cclxuICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcclxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yIGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIEEgUHJvc2VtaXJyb3Igc2NoZW1hXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zLCBlZGl0b3IpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XHJcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgdG9wTm9kZSA9IChfYSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3RvcE5vZGUnKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGV4dHJhTm9kZUZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmROb2RlU2NoZW1hJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXHJcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xyXG4gICAgICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdjb250ZW50JywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBpbmxpbmU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdpbmxpbmUnLCBjb250ZXh0KSksXHJcbiAgICAgICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnc2VsZWN0YWJsZScsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZHJhZ2dhYmxlJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZGVmaW5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdkZWZpbmluZycsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgaXNvbGF0aW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnaXNvbGF0aW5nJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IChfYSA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBleHRlbnNpb25BdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0IH1dO1xyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpKTtcclxuICAgICAgICBpZiAocGFyc2VIVE1MKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlckhUTUwnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAocmVuZGVySFRNTCkge1xyXG4gICAgICAgICAgICBzY2hlbWEudG9ET00gPSBub2RlID0+IHJlbmRlckhUTUwoe1xyXG4gICAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW5kZXJUZXh0ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncmVuZGVyVGV4dCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZW5kZXJUZXh0KSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdO1xyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgbWFya3MgPSBPYmplY3QuZnJvbUVudHJpZXMobWFya0V4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTWFya1NjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmRNYXJrU2NoZW1hJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXHJcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xyXG4gICAgICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZXhjbHVkZXM6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdleGNsdWRlcycsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXHJcbiAgICAgICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09PSBudWxsIHx8IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQgfV07XHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpO1xyXG4gICAgICAgIGlmIChwYXJzZUhUTUwpIHtcclxuICAgICAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncmVuZGVySFRNTCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZW5kZXJIVE1MKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS50b0RPTSA9IG1hcmsgPT4gcmVuZGVySFRNTCh7XHJcbiAgICAgICAgICAgICAgICBtYXJrLFxyXG4gICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gbmV3IFNjaGVtYSh7XHJcbiAgICAgICAgdG9wTm9kZSxcclxuICAgICAgICBub2RlcyxcclxuICAgICAgICBtYXJrcyxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBUcmllcyB0byBnZXQgYSBub2RlIG9yIG1hcmsgdHlwZSBieSBpdHMgbmFtZS5cclxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5vZGUgb3IgbWFyayB0eXBlXHJcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlyb3Igc2NoZW1hIHRvIHNlYXJjaCBpblxyXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBvciBtYXJrIHR5cGUsIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcclxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZV0gfHwgc2NoZW1hLm1hcmtzW25hbWVdIHx8IG51bGw7XHJcbn1cblxuZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlbmFibGVkKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkKSkge1xyXG4gICAgICAgIHJldHVybiBlbmFibGVkLnNvbWUoZW5hYmxlZEV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gZW5hYmxlZEV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgOiBlbmFibGVkRXh0ZW5zaW9uLm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbmFibGVkO1xyXG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSByZXNvbHZlZCBwcm9zZW1pcnJvciBwb3NpdGlvblxyXG4gKiBAcGFyYW0gJGZyb20gVGhlIHJlc29sdmVkIHBvc2l0aW9uIHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb21cclxuICogQHBhcmFtIG1heE1hdGNoIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIG1hdGNoXHJcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IGNvbnRlbnRcclxuICovXHJcbmNvbnN0IGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tLCBtYXhNYXRjaCA9IDUwMCkgPT4ge1xyXG4gICAgbGV0IHRleHRCZWZvcmUgPSAnJztcclxuICAgIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0O1xyXG4gICAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSwgc2xpY2VFbmRQb3MsIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIHBvcyxcclxuICAgICAgICAgICAgcGFyZW50LFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICB9KSlcclxuICAgICAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxyXG4gICAgICAgICAgICB8fCAnJWxlYWYlJztcclxuICAgICAgICB0ZXh0QmVmb3JlICs9IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0ZXh0QmVmb3JlO1xyXG59O1xuXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG59XG5cbmNsYXNzIElucHV0UnVsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZDtcclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcclxuICAgIH1cclxufVxyXG5jb25zdCBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kKSA9PiB7XHJcbiAgICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcclxuICAgICAgICByZXR1cm4gZmluZC5leGVjKHRleHQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5wdXRSdWxlTWF0Y2ggPSBmaW5kKHRleHQpO1xyXG4gICAgaWYgKCFpbnB1dFJ1bGVNYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gW2lucHV0UnVsZU1hdGNoLnRleHRdO1xyXG4gICAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXg7XHJcbiAgICByZXN1bHQuaW5wdXQgPSB0ZXh0O1xyXG4gICAgcmVzdWx0LmRhdGEgPSBpbnB1dFJ1bGVNYXRjaC5kYXRhO1xyXG4gICAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XHJcbiAgICAgICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwiaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJpbnB1dFJ1bGVNYXRjaC50ZXh0XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmZ1bmN0aW9uIHJ1biQxKGNvbmZpZykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgeyBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luLCB9ID0gY29uZmlnO1xyXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XHJcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XHJcbiAgICBpZiAoXHJcbiAgICAvLyBjaGVjayBmb3IgY29kZSBub2RlXHJcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGVcclxuICAgICAgICAvLyBjaGVjayBmb3IgY29kZSBtYXJrXHJcbiAgICAgICAgfHwgISEoKF9hID0gKCRmcm9tLm5vZGVCZWZvcmUgfHwgJGZyb20ubm9kZUFmdGVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtzLmZpbmQobWFyayA9PiBtYXJrLnR5cGUuc3BlYy5jb2RlKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHQ7XHJcbiAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xyXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlcih0ZXh0QmVmb3JlLCBydWxlLmZpbmQpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHI7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XHJcbiAgICAgICAgICAgIHN0YXRlOiB2aWV3LnN0YXRlLFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7XHJcbiAgICAgICAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxyXG4gICAgICAgICAgICB0byxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XHJcbiAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgICAgIGNvbW1hbmRzLFxyXG4gICAgICAgICAgICBjaGFpbixcclxuICAgICAgICAgICAgY2FuLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcclxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3RvcmUgdHJhbnNmb3JtIGFzIG1ldGEgZGF0YVxyXG4gICAgICAgIC8vIHNvIHdlIGNhbiB1bmRvIGlucHV0IHJ1bGVzIHdpdGhpbiB0aGUgYHVuZG9JbnB1dFJ1bGVzYCBjb21tYW5kXHJcbiAgICAgICAgdHIuc2V0TWV0YShwbHVnaW4sIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cixcclxuICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XHJcbiAgICAgICAgbWF0Y2hlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtYXRjaGVkO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxyXG4gKiBpbnB1dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xyXG4gKiBhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XHJcbiAgICAgICAgc3RhdGU6IHtcclxuICAgICAgICAgICAgaW5pdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcHBseSh0ciwgcHJldikge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBJbnB1dFJ1bGUgaXMgdHJpZ2dlcmVkIGJ5IGluc2VydENvbnRlbnQoKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkSW5wdXRNZXRhID0gdHIuZ2V0TWV0YSgnYXBwbHlJbnB1dFJ1bGVzJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NpbXVsYXRlZElucHV0ID0gISFzaW11bGF0ZWRJbnB1dE1ldGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTaW11bGF0ZWRJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZyb20sIHRleHQgfSA9IHNpbXVsYXRlZElucHV0TWV0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1biQxKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1biQxKHtcclxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcclxuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uZW5kOiB2aWV3ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1biQxKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gYWRkIHN1cHBvcnQgZm9yIGlucHV0IHJ1bGVzIHRvIHRyaWdnZXIgb24gZW50ZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgZm9yIGNvZGUgYmxvY2tzXHJcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgIT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuJDEoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXG4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGlzSW5wdXRSdWxlczogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHBsdWdpbjtcclxufVxuXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XHJcbn1cblxuLyoqXHJcbiAqIFBhc3RlIHJ1bGVzIGFyZSB1c2VkIHRvIHJlYWN0IHRvIHBhc3RlZCBjb250ZW50LlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucy8jcGFzdGUtcnVsZXNcclxuICovXHJcbmNsYXNzIFBhc3RlUnVsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZDtcclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcclxuICAgIH1cclxufVxyXG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kLCBldmVudCkgPT4ge1xyXG4gICAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50ZXh0Lm1hdGNoQWxsKGZpbmQpXTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQsIGV2ZW50KTtcclxuICAgIGlmICghbWF0Y2hlcykge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVzLm1hcChwYXN0ZVJ1bGVNYXRjaCA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdO1xyXG4gICAgICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4O1xyXG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IHRleHQ7XHJcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhO1xyXG4gICAgICAgIGlmIChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xyXG4gICAgICAgICAgICBpZiAoIXBhc3RlUnVsZU1hdGNoLnRleHQuaW5jbHVkZXMocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIHJ1bihjb25maWcpIHtcclxuICAgIGNvbnN0IHsgZWRpdG9yLCBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZlbnQsIGRyb3BFdmVudCwgfSA9IGNvbmZpZztcclxuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XHJcbiAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xyXG4gICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLnR5cGUuc3BlYy5jb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcclxuICAgICAgICBjb25zdCByZXNvbHZlZFRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUuY29udGVudC5zaXplKTtcclxuICAgICAgICBjb25zdCB0ZXh0VG9NYXRjaCA9IG5vZGUudGV4dEJldHdlZW4ocmVzb2x2ZWRGcm9tIC0gcG9zLCByZXNvbHZlZFRvIC0gcG9zLCB1bmRlZmluZWQsICdcXHVmZmZjJyk7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpO1xyXG4gICAgICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByZXNvbHZlZEZyb20gKyBtYXRjaC5pbmRleCArIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIGZyb206IHN0YXRlLnRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBtYXRjaCxcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLFxyXG4gICAgICAgICAgICAgICAgY2hhaW4sXHJcbiAgICAgICAgICAgICAgICBjYW4sXHJcbiAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50LFxyXG4gICAgICAgICAgICAgICAgZHJvcEV2ZW50LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbCk7XHJcbiAgICByZXR1cm4gc3VjY2VzcztcclxufVxyXG5jb25zdCBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQpID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcclxuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXHJcbiAgICB9KTtcclxuICAgIChfYSA9IGV2ZW50LmNsaXBib2FyZERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXREYXRhKCd0ZXh0L2h0bWwnLCB0ZXh0KTtcclxuICAgIHJldHVybiBldmVudDtcclxufTtcclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcclxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xyXG4gKiBhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXN0ZVJ1bGVzUGx1Z2luKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzO1xyXG4gICAgbGV0IGRyYWdTb3VyY2VFbGVtZW50ID0gbnVsbDtcclxuICAgIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xyXG4gICAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xyXG4gICAgbGV0IHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcclxuICAgIGxldCBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBEcmFnRXZlbnQoJ2Ryb3AnKSA6IG51bGw7XHJcbiAgICBjb25zdCBwcm9jZXNzRXZlbnQgPSAoeyBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZ0LCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcclxuICAgICAgICBjb25zdCBjaGFpbmFibGVTdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcclxuICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gcnVuKHtcclxuICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICBzdGF0ZTogY2hhaW5hYmxlU3RhdGUsXHJcbiAgICAgICAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcclxuICAgICAgICAgICAgdG86IHRvLmIgLSAxLFxyXG4gICAgICAgICAgICBydWxlLFxyXG4gICAgICAgICAgICBwYXN0ZUV2ZW50OiBwYXN0ZUV2dCxcclxuICAgICAgICAgICAgZHJvcEV2ZW50LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcEV2ZW50ID0gdHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRHJhZ0V2ZW50KCdkcm9wJykgOiBudWxsO1xyXG4gICAgICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gdHI7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFBsdWdpbih7XHJcbiAgICAgICAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XHJcbiAgICAgICAgICAgIHZpZXcodmlldykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyb3A6ICh2aWV3LCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiAoX3ZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbCA9IChfYSA9IGV2ZW50LmNsaXBib2FyZERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHRtbC5pbmNsdWRlcygnZGF0YS1wbS1zbGljZScpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUGFzdGUgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdwYXN0ZScgJiYgIWlzUGFzdGVkRnJvbVByb3NlTWlycm9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNEcm9wID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAnZHJvcCcgJiYgIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcjtcclxuICAgICAgICAgICAgICAgIC8vIGlmIFBhc3RlUnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaW11bGF0ZWRQYXN0ZU1ldGEgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdhcHBseVBhc3RlUnVsZXMnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkUGFzdGUgPSAhIXNpbXVsYXRlZFBhc3RlTWV0YTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNpbXVsYXRlZCBwYXN0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2ltdWxhdGVkUGFzdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZyb20sIHRleHQgfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXN0ZUV2dCA9IGNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQodGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogeyBiOiB0byB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZUV2dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBhY3R1YWwgcGFzdGUvZHJvcFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IG9sZFN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoc3RhdGUuZG9jLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGlzIG5vIGNoYW5nZWQgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIoZnJvbSkgfHwgIXRvIHx8IGZyb20gPT09IHRvLmIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVFdnQ6IHBhc3RlRXZlbnQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHBsdWdpbnM7XHJcbn1cblxuZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoaXRlbXMpIHtcclxuICAgIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleCk7XHJcbiAgICByZXR1cm4gWy4uLm5ldyBTZXQoZmlsdGVyZWQpXTtcclxufVxuXG5jbGFzcyBFeHRlbnNpb25NYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xyXG4gICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzID0gW107XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zLCBlZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuc2V0dXBFeHRlbnNpb25zKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmbGF0dGVuZWQgYW5kIHNvcnRlZCBleHRlbnNpb24gbGlzdCB3aGlsZVxyXG4gICAgICogYWxzbyBjaGVja2luZyBmb3IgZHVwbGljYXRlZCBleHRlbnNpb25zIGFuZCB3YXJucyB0aGUgdXNlci5cclxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIEFuIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXHJcbiAgICAgKiBAcmV0dXJucyBBbiBmbGF0dGVuZWQgYW5kIHNvcnRlZCBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVzb2x2ZShleHRlbnNpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5zb3J0KEV4dGVuc2lvbk1hbmFnZXIuZmxhdHRlbihleHRlbnNpb25zKSk7XHJcbiAgICAgICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKTtcclxuICAgICAgICBpZiAoZHVwbGljYXRlZE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lc1xyXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IGAnJHtpdGVtfSdgKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGZsYXR0ZW5lZCBhcnJheSBvZiBleHRlbnNpb25zIGJ5IHRyYXZlcnNpbmcgdGhlIGBhZGRFeHRlbnNpb25zYCBmaWVsZC5cclxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIEFuIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXHJcbiAgICAgKiBAcmV0dXJucyBBIGZsYXR0ZW5lZCBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZmxhdHRlbihleHRlbnNpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIChleHRlbnNpb25zXHJcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEV4dGVuc2lvbnMnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGFkZEV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi50aGlzLmZsYXR0ZW4oYWRkRXh0ZW5zaW9ucygpKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyBgSW5maW5pdHlgIHdpbGwgYnJlYWsgVHlwZVNjcmlwdCBzbyB3ZSBzZXQgYSBudW1iZXIgdGhhdCBpcyBwcm9iYWJseSBoaWdoIGVub3VnaFxyXG4gICAgICAgICAgICAuZmxhdCgxMCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IGV4dGVuc2lvbnMgYnkgcHJpb3JpdHkuXHJcbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xyXG4gICAgICogQHJldHVybnMgQSBzb3J0ZWQgYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnMgYnkgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNvcnQoZXh0ZW5zaW9ucykge1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkKGEsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eTtcclxuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlCID0gZ2V0RXh0ZW5zaW9uRmllbGQoYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xyXG4gICAgICAgICAgICBpZiAocHJpb3JpdHlBID4gcHJpb3JpdHlCKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByaW9yaXR5QSA8IHByaW9yaXR5Qikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgY29tbWFuZHMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cclxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBjb21tYW5kcyB3aGVyZSB0aGUga2V5IGlzIHRoZSBjb21tYW5kIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29tbWFuZCBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgY29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5yZWR1Y2UoKGNvbW1hbmRzLCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZENvbW1hbmRzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkQ29tbWFuZHMnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5jb21tYW5kcyxcclxuICAgICAgICAgICAgICAgIC4uLmFkZENvbW1hbmRzKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgUHJvc2VtaXJyb3IgcGx1Z2lucyBmcm9tIHRoZSBleHRlbnNpb25zLlxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgUHJvc2VtaXJyb3IgcGx1Z2luc1xyXG4gICAgICovXHJcbiAgICBnZXQgcGx1Z2lucygpIHtcclxuICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcclxuICAgICAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXHJcbiAgICAgICAgLy8gSW4gVGlwdGFwLCB3ZSBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIG92ZXJyaWRlIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gc28gaXQgZmVlbHMgbW9yZSBuYXR1cmFsIHRvIHJ1biBwbHVnaW5zIGF0IHRoZSBlbmQgb2YgYW4gYXJyYXkgZmlyc3QuXHJcbiAgICAgICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXHJcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGBwcmlvcml0eWAgb3B0aW9uLlxyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoWy4uLnRoaXMuZXh0ZW5zaW9uc10ucmV2ZXJzZSgpKTtcclxuICAgICAgICBjb25zdCBpbnB1dFJ1bGVzID0gW107XHJcbiAgICAgICAgY29uc3QgcGFzdGVSdWxlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFsbFBsdWdpbnMgPSBleHRlbnNpb25zXHJcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcclxuICAgICAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcGx1Z2lucyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBkZWZhdWx0QmluZGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgLy8gYmluZCBleGl0IGhhbmRsaW5nXHJcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnICYmIGV4dGVuc2lvbi5jb25maWcuZXhpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncy5BcnJvd1JpZ2h0ID0gKCkgPT4gTWFyay5oYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrOiBleHRlbnNpb24gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhhZGRLZXlib2FyZFNob3J0Y3V0cygpKS5tYXAoKFtzaG9ydGN1dCwgbWV0aG9kXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV07XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmluZGluZ3MgPSB7IC4uLmRlZmF1bHRCaW5kaW5ncywgLi4uYmluZGluZ3MgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKTtcclxuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKGtleU1hcFBsdWdpbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZElucHV0UnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRJbnB1dFJ1bGVzJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0UnVsZXMucHVzaCguLi5hZGRJbnB1dFJ1bGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQYXN0ZVJ1bGVzJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZVBhc3RlUnVsZXMpICYmIGFkZFBhc3RlUnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHBhc3RlUnVsZXMucHVzaCguLi5hZGRQYXN0ZVJ1bGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZFByb3NlTWlycm9yUGx1Z2lucyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFByb3NlTWlycm9yUGx1Z2lucycsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoYWRkUHJvc2VNaXJyb3JQbHVnaW5zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKTtcclxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCguLi5wcm9zZU1pcnJvclBsdWdpbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5zO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5mbGF0KCk7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgaW5wdXRSdWxlc1BsdWdpbih7XHJcbiAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICBydWxlczogaW5wdXRSdWxlcyxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIC4uLnBhc3RlUnVsZXNQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgcnVsZXM6IHBhc3RlUnVsZXMsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAuLi5hbGxQbHVnaW5zLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBleHRlbnNpb25zLlxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgYXR0cmlidXRlcygpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbm9kZSB2aWV3cyBmcm9tIHRoZSBleHRlbnNpb25zLlxyXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgbm9kZVZpZXdzKCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnNcclxuICAgICAgICAgICAgLmZpbHRlcihleHRlbnNpb24gPT4gISFnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGROb2RlVmlldycpKVxyXG4gICAgICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0Tm9kZVR5cGUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgYWRkTm9kZVZpZXcgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGROb2RlVmlldycsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9kZXZpZXcgPSAobm9kZSwgdmlldywgZ2V0UG9zLCBkZWNvcmF0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkTm9kZVZpZXcoKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBub2Rldmlld107XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcclxuICAgICAqICYgYmluZCBlZGl0b3IgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgKi9cclxuICAgIHNldHVwRXh0ZW5zaW9ucygpIHtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlIGV4dGVuc2lvbiBzdG9yYWdlIGluIGVkaXRvclxyXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5zdG9yYWdlO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcclxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2tlZXBPblNwbGl0JywgY29udGV4dCkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtlZXBPblNwbGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MucHVzaChleHRlbnNpb24ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJlZm9yZUNyZWF0ZScsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uQ3JlYXRlJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25VcGRhdGUnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY29uc3Qgb25TZWxlY3Rpb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblNlbGVjdGlvblVwZGF0ZScsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBvblRyYW5zYWN0aW9uID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25UcmFuc2FjdGlvbicsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkZvY3VzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25Gb2N1cycsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkJsdXIgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJsdXInLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY29uc3Qgb25EZXN0cm95ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25EZXN0cm95JywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob25DcmVhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdjcmVhdGUnLCBvbkNyZWF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9uVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvblNlbGVjdGlvblVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob25UcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9uRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkJsdXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgb25CbHVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZXNxdWVlYi9pcy13aGF0L2Jsb2IvODhkNmU0Y2E5MmZiMmJhYWI2MDAzYzU0ZTAyZWVkZjRlNzI5ZTVhYi9zcmMvaW5kZXgudHNcclxuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xyXG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0geyAuLi50YXJnZXQgfTtcclxuICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgRXh0ZW5zaW9uIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZXh0ZW5zaW9ucy5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMjY3JlYXRlLWEtbmV3LWV4dGVuc2lvblxyXG4gKi9cclxuY2xhc3MgRXh0ZW5zaW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4dGVuc2lvbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ2V4dGVuc2lvbic7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcclxuICAgICAgICAgICAgLi4uY29uZmlnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcclxuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkU3RvcmFnZScsIHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgfSkpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXh0ZW5zaW9uKGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBjb25maWd1cmUob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXHJcbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcclxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgIH1cclxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IEV4dGVuc2lvbih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KTtcclxuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcclxuICAgICAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uO1xyXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XHJcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogR2V0cyB0aGUgdGV4dCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMgaW4gYSBQcm9zZW1pcnJvciBub2RlXHJcbiAqIGFuZCBzZXJpYWxpemVzIGl0IHVzaW5nIHRoZSBnaXZlbiB0ZXh0IHNlcmlhbGl6ZXJzIGFuZCBibG9jayBzZXBhcmF0b3IgKHNlZSBnZXRUZXh0KVxyXG4gKiBAcGFyYW0gc3RhcnROb2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHN0YXJ0IGZyb21cclxuICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgdGV4dCB0byBnZXRcclxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgc2VyaWFsaXplciAmIGJsb2NrIHNlcGFyYXRvclxyXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBiZXR3ZWVuIHRoZSB0d28gcG9zaXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUZXh0QmV0d2VlbihzdGFydE5vZGUsIHJhbmdlLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcclxuICAgIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XHJcbiAgICBsZXQgdGV4dCA9ICcnO1xyXG4gICAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIHBvcyA+IGZyb20pIHtcclxuICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGV4dFNlcmlhbGl6ZXIgPSB0ZXh0U2VyaWFsaXplcnMgPT09IG51bGwgfHwgdGV4dFNlcmlhbGl6ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0U2VyaWFsaXplcnNbbm9kZS50eXBlLm5hbWVdO1xyXG4gICAgICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRleHRTZXJpYWxpemVyKHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvcyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBkbyBub3QgZGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIHdoZW4gdGhlcmUgZXhpc3RzIGEgc2VyaWFsaXplclxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xyXG4gICAgICAgICAgICB0ZXh0ICs9IChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxuXG4vKipcclxuICogRmluZCB0ZXh0IHNlcmlhbGl6ZXJzIGB0b1RleHRgIGluIGEgUHJvc2VtaXJyb3Igc2NoZW1hXHJcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cclxuICogQHJldHVybnMgQSByZWNvcmQgb2YgdGV4dCBzZXJpYWxpemVycyBieSBub2RlIG5hbWVcclxuICovXHJcbmZ1bmN0aW9uIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcclxuICAgICAgICAuZmlsdGVyKChbLCBub2RlXSkgPT4gbm9kZS5zcGVjLnRvVGV4dClcclxuICAgICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSkpO1xyXG59XG5cbmNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBibG9ja1NlcGFyYXRvcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicpLFxyXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgc2NoZW1hIH0gPSBlZGl0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFNlcmlhbGl6ZXJzID0gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLm9wdGlvbnMuYmxvY2tTZXBhcmF0b3IgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBibG9ja1NlcGFyYXRvcjogdGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTZXJpYWxpemVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgYmx1ciA9ICgpID0+ICh7IGVkaXRvciwgdmlldyB9KSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XHJcbiAgICAgICAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCByZW1vdmUgdGhlIGNhcmV0IG9uIGJsdXIgYnV0IHNhZmFyaSBkb2VzIG5vdC5cclxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcclxuICAgICAgICAgICAgKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmdldFNlbGVjdGlvbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3QgY2xlYXJDb250ZW50ID0gKGVtaXRVcGRhdGUgPSBmYWxzZSkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoJycsIGVtaXRVcGRhdGUpO1xyXG59O1xuXG5jb25zdCBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XHJcbiAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgaWYgKCFkaXNwYXRjaCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XHJcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHI7XHJcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSk7XHJcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRUbyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpKTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpZnREZXB0aCA9IGxpZnRUYXJnZXQobm9kZVJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpO1xyXG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdHIubGlmdChub2RlUmFuZ2UsIHRhcmdldExpZnREZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGNvbW1hbmQgPSBmbiA9PiBwcm9wcyA9PiB7XHJcbiAgICByZXR1cm4gZm4ocHJvcHMpO1xyXG59O1xuXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3QgY3V0ID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xyXG4gICAgY29uc3QgY29udGVudFNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcclxuICAgIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcyk7XHJcbiAgICB0ci5pbnNlcnQobmV3UG9zLCBjb250ZW50U2xpY2UuY29udGVudCk7XHJcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobmV3UG9zIC0gMSkpKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBkZWxldGVDdXJyZW50Tm9kZSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XHJcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKTtcclxuICAgIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcclxuICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xyXG4gICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xuXG5jb25zdCBkZWxldGVOb2RlID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xyXG4gICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xuXG5jb25zdCBkZWxldGVSYW5nZSA9IHJhbmdlID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBkZWxldGVTZWxlY3Rpb24kMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5jb25zdCBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgIHJldHVybiBjb21tYW5kcy5rZXlib2FyZFNob3J0Y3V0KCdFbnRlcicpO1xyXG59O1xuXG5jb25zdCBleGl0Q29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gZXhpdENvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG4vKipcclxuICogQ2hlY2sgaWYgb2JqZWN0MSBpbmNsdWRlcyBvYmplY3QyXHJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxyXG4gKiBAcGFyYW0gb2JqZWN0MiBPYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKG9iamVjdDEsIG9iamVjdDIsIG9wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9KSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XHJcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5cy5ldmVyeShrZXkgPT4ge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcclxuICAgIHJldHVybiBtYXJrcy5maW5kKGl0ZW0gPT4ge1xyXG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgb2JqZWN0SW5jbHVkZXMoaXRlbS5hdHRycywgYXR0cmlidXRlcyk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpc01hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxufVxyXG5mdW5jdGlvbiBnZXRNYXJrUmFuZ2UoJHBvcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICBpZiAoISRwb3MgfHwgIXR5cGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KTtcclxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PT0gc3RhcnQub2Zmc2V0ICYmIHN0YXJ0Lm9mZnNldCAhPT0gMCkge1xyXG4gICAgICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzdGFydC5ub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxuICAgIGlmICghbWFyaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXg7XHJcbiAgICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXQ7XHJcbiAgICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgMTtcclxuICAgIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemU7XHJcbiAgICBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgbWFyay5pc0luU2V0KCRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrcykpIHtcclxuICAgICAgICBzdGFydEluZGV4IC09IDE7XHJcbiAgICAgICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemU7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50XHJcbiAgICAgICAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpKSB7XHJcbiAgICAgICAgZW5kUG9zICs9ICRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5ub2RlU2l6ZTtcclxuICAgICAgICBlbmRJbmRleCArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmcm9tOiBzdGFydFBvcyxcclxuICAgICAgICB0bzogZW5kUG9zLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lT3JUeXBlO1xyXG59XG5cbmNvbnN0IGV4dGVuZE1hcmtSYW5nZSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0cjtcclxuICAgIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0bykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcclxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGZpcnN0ID0gY29tbWFuZHMgPT4gcHJvcHMgPT4ge1xyXG4gICAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IGNvbW1hbmRzKHByb3BzKVxyXG4gICAgICAgIDogY29tbWFuZHM7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjtcclxufVxuXG5mdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XHJcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCBwb3NpdGlvbiA9IG51bGwpIHtcclxuICAgIGlmICghcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpO1xyXG4gICAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKTtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0JyB8fCBwb3NpdGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25BdFN0YXJ0O1xyXG4gICAgfVxyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnZW5kJykge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZDtcclxuICAgIH1cclxuICAgIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbTtcclxuICAgIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xyXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChkb2MuY29udGVudC5zaXplLCBtaW5Qb3MsIG1heFBvcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKTtcclxufVxuXG5mdW5jdGlvbiBpc2lPUygpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgJ2lQYWQgU2ltdWxhdG9yJyxcclxuICAgICAgICAnaVBob25lIFNpbXVsYXRvcicsXHJcbiAgICAgICAgJ2lQb2QgU2ltdWxhdG9yJyxcclxuICAgICAgICAnaVBhZCcsXHJcbiAgICAgICAgJ2lQaG9uZScsXHJcbiAgICAgICAgJ2lQb2QnLFxyXG4gICAgXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pXHJcbiAgICAgICAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXHJcbiAgICAgICAgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ01hYycpICYmICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCk7XHJcbn1cblxuY29uc3QgZm9jdXMgPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoLCB9KSA9PiB7XHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZGVsYXllZEZvY3VzID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIGZvY3VzIHdpdGhpbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBicmVha3MgZm9jdXMgb24gaU9TXHJcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBjYWxsIHRoaXNcclxuICAgICAgICBpZiAoaXNpT1MoKSkge1xyXG4gICAgICAgICAgICB2aWV3LmRvbS5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTUyMFxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcm9sbEludG9WaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBpZiAoKHZpZXcuaGFzRm9jdXMoKSAmJiBwb3NpdGlvbiA9PT0gbnVsbCkgfHwgcG9zaXRpb24gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXHJcbiAgICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xyXG4gICAgICAgIGRlbGF5ZWRGb2N1cygpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcclxuICAgIC8vIHNpbmNlIHRyYW5zYWN0aW9ucyBjb3VsZCBjaGFuZ2UgdGhlIGVkaXRvcnMgc3RhdGUgYmVmb3JlIHRoaXMgY29tbWFuZCBoYXMgYmVlbiBydW5cclxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKHRyLmRvYywgcG9zaXRpb24pIHx8IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCBpc1NhbWVTZWxlY3Rpb24gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbik7XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYHRyLnNldFNlbGVjdGlvbmAgcmVzZXRzIHRoZSBzdG9yZWQgbWFya3NcclxuICAgICAgICAvLyBzbyB3ZeKAmWxsIHJlc3RvcmUgdGhlbSBpZiB0aGUgc2VsZWN0aW9uIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxyXG4gICAgICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcclxuICAgICAgICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxheWVkRm9jdXMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBmb3JFYWNoID0gKGl0ZW1zLCBmbikgPT4gcHJvcHMgPT4ge1xyXG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpO1xyXG59O1xuXG5jb25zdCBpbnNlcnRDb250ZW50ID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sIHZhbHVlLCBvcHRpb25zKTtcclxufTtcblxuY29uc3QgcmVtb3ZlV2hpdGVzcGFjZXMgPSAobm9kZSkgPT4ge1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XHJcbiAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5ub2RlVmFsdWUgJiYgL14oXFxuXFxzXFxzfFxcbikkLy50ZXN0KGNoaWxkLm5vZGVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVdoaXRlc3BhY2VzKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufTtcclxuZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWUpIHtcclxuICAgIC8vIGFkZCBhIHdyYXBwZXIgdG8gcHJlc2VydmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmA7XHJcbiAgICBjb25zdCBodG1sID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcod3JhcHBlZFZhbHVlLCAndGV4dC9odG1sJykuYm9keTtcclxuICAgIHJldHVybiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sKTtcclxufVxuXG4vKipcclxuICogVGFrZXMgYSBKU09OIG9yIEhUTUwgY29udGVudCBhbmQgY3JlYXRlcyBhIFByb3NlbWlycm9yIG5vZGUgb3IgZnJhZ21lbnQgZnJvbSBpdC5cclxuICogQHBhcmFtIGNvbnRlbnQgVGhlIEpTT04gb3IgSFRNTCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbm9kZSBmcm9tXHJcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byB1c2UgZm9yIHRoZSBub2RlXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBwYXJzZXJcclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgUHJvc2VtaXJyb3Igbm9kZSBvciBmcmFnbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IHtcclxuICAgICAgICBzbGljZTogdHJ1ZSxcclxuICAgICAgICBwYXJzZU9wdGlvbnM6IHt9LFxyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaXNKU09OQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiBjb250ZW50ICE9PSBudWxsO1xyXG4gICAgY29uc3QgaXNUZXh0Q29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJztcclxuICAgIGlmIChpc0pTT05Db250ZW50KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgaXNBcnJheUNvbnRlbnQgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmIGNvbnRlbnQubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIEpTT04gQ29udGVudCBpcyBhbiBhcnJheSBvZiBub2RlcywgY3JlYXRlIGEgZnJhZ21lbnQgZm9yIGVhY2ggbm9kZVxyXG4gICAgICAgICAgICBpZiAoaXNBcnJheUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoaXRlbSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzVGV4dENvbnRlbnQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLnNsaWNlXHJcbiAgICAgICAgICAgID8gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50XHJcbiAgICAgICAgICAgIDogcGFyc2VyLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpO1xyXG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yLXN0YXRlL2Jsb2IvbWFzdGVyL3NyYy9zZWxlY3Rpb24uanMjTDQ2NlxyXG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgc3RhcnRMZW4sIGJpYXMpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xyXG4gICAgaWYgKGxhc3QgPCBzdGFydExlbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcclxuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdO1xyXG4gICAgbGV0IGVuZCA9IDA7XHJcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gMCkge1xyXG4gICAgICAgICAgICBlbmQgPSBuZXdUbztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XHJcbn1cblxuY29uc3QgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudCkgPT4ge1xyXG4gICAgcmV0dXJuIG5vZGVPckZyYWdtZW50LnRvU3RyaW5nKCkuc3RhcnRzV2l0aCgnPCcpO1xyXG59O1xyXG5jb25zdCBpbnNlcnRDb250ZW50QXQgPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwYXJzZU9wdGlvbnM6IHt9LFxyXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb246IHRydWUsXHJcbiAgICAgICAgICAgIGFwcGx5SW5wdXRSdWxlczogZmFsc2UsXHJcbiAgICAgICAgICAgIGFwcGx5UGFzdGVSdWxlczogZmFsc2UsXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XHJcbiAgICAgICAgICAgIHBhcnNlT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXHJcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9ucyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBkb27igJl0IGRpc3BhdGNoIGFuIGVtcHR5IGZyYWdtZW50IGJlY2F1c2UgdGhpcyBjYW4gbGVhZCB0byBzdHJhbmdlIGVycm9yc1xyXG4gICAgICAgIGlmIChjb250ZW50LnRvU3RyaW5nKCkgPT09ICc8PicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9O1xyXG4gICAgICAgIGxldCBpc09ubHlUZXh0Q29udGVudCA9IHRydWU7XHJcbiAgICAgICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBpc0ZyYWdtZW50KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhZGRlZCBub2RlIGlzIHZhbGlkXHJcbiAgICAgICAgICAgIG5vZGUuY2hlY2soKTtcclxuICAgICAgICAgICAgaXNPbmx5VGV4dENvbnRlbnQgPSBpc09ubHlUZXh0Q29udGVudCA/IG5vZGUuaXNUZXh0ICYmIG5vZGUubWFya3MubGVuZ3RoID09PSAwIDogZmFsc2U7XHJcbiAgICAgICAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZXBsYWNlIHRoZSB3cmFwcGluZyBub2RlIGJ5XHJcbiAgICAgICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcclxuICAgICAgICAvLyBleGFtcGxlOlxyXG4gICAgICAgIC8vIHJlcGxhY2UgYW4gZW1wdHkgcGFyYWdyYXBoIGJ5IGFuIGluc2VydGVkIGltYWdlXHJcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50IH0gPSB0ci5kb2MucmVzb2x2ZShmcm9tKTtcclxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudDtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcclxuICAgICAgICAgICAgICAgIGZyb20gLT0gMTtcclxuICAgICAgICAgICAgICAgIHRvICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBwbGFpbiB0ZXh0IHdlIGhhdmUgdG8gdXNlIGBpbnNlcnRUZXh0YFxyXG4gICAgICAgIC8vIGJlY2F1c2UgdGhpcyB3aWxsIGtlZXAgdGhlIGN1cnJlbnQgbWFya3NcclxuICAgICAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcclxuICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgc3RyaW5nLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpZiBpdCBpcyBhbiBhcnJheSwgd2UgaGF2ZSB0byBqb2luIGl0XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlLm1hcCh2ID0+IHYudGV4dCB8fCAnJykuam9pbignJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICEhdmFsdWUudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlLnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dChuZXdDb250ZW50LCBmcm9tLCB0byk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudDtcclxuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIG5ld0NvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgY3Vyc29yIGF0IGVuZCBvZiBpbnNlcnRlZCBjb250ZW50XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmFwcGx5SW5wdXRSdWxlcykge1xyXG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseUlucHV0UnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmFwcGx5UGFzdGVSdWxlcykge1xyXG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseVBhc3RlUnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGpvaW5VcCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gam9pblVwJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcclxuY29uc3Qgam9pbkRvd24gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIGpvaW5Eb3duJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcclxuY29uc3Qgam9pbkJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBqb2luQmFja3dhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xyXG5jb25zdCBqb2luRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gam9pbkZvcndhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5jb25zdCBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgfSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKTtcclxuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xyXG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2gge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcblxuY29uc3Qgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsICsxKTtcclxuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xyXG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gam9pblRleHRibG9ja0JhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIGpvaW5UZXh0YmxvY2tGb3J3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuZnVuY3Rpb24gaXNNYWNPUygpIHtcclxuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXHJcbiAgICAgICAgOiBmYWxzZTtcclxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XHJcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAocmVzdWx0ID09PSAnU3BhY2UnKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJyAnO1xyXG4gICAgfVxyXG4gICAgbGV0IGFsdDtcclxuICAgIGxldCBjdHJsO1xyXG4gICAgbGV0IHNoaWZ0O1xyXG4gICAgbGV0IG1ldGE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xyXG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xyXG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHtcclxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkge1xyXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XHJcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkge1xyXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcclxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6ICR7bW9kfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhbHQpIHtcclxuICAgICAgICByZXN1bHQgPSBgQWx0LSR7cmVzdWx0fWA7XHJcbiAgICB9XHJcbiAgICBpZiAoY3RybCkge1xyXG4gICAgICAgIHJlc3VsdCA9IGBDdHJsLSR7cmVzdWx0fWA7XHJcbiAgICB9XHJcbiAgICBpZiAobWV0YSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGBNZXRhLSR7cmVzdWx0fWA7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hpZnQpIHtcclxuICAgICAgICByZXN1bHQgPSBgU2hpZnQtJHtyZXN1bHR9YDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3Qga2V5Ym9hcmRTaG9ydGN1dCA9IG5hbWUgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2gsIH0pID0+IHtcclxuICAgIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlOYW1lKG5hbWUpLnNwbGl0KC8tKD8hJCkvKTtcclxuICAgIGNvbnN0IGtleSA9IGtleXMuZmluZChpdGVtID0+ICFbJ0FsdCcsICdDdHJsJywgJ01ldGEnLCAnU2hpZnQnXS5pbmNsdWRlcyhpdGVtKSk7XHJcbiAgICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xyXG4gICAgICAgIGtleToga2V5ID09PSAnU3BhY2UnXHJcbiAgICAgICAgICAgID8gJyAnXHJcbiAgICAgICAgICAgIDoga2V5LFxyXG4gICAgICAgIGFsdEtleToga2V5cy5pbmNsdWRlcygnQWx0JyksXHJcbiAgICAgICAgY3RybEtleToga2V5cy5pbmNsdWRlcygnQ3RybCcpLFxyXG4gICAgICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoJ01ldGEnKSxcclxuICAgICAgICBzaGlmdEtleToga2V5cy5pbmNsdWRlcygnU2hpZnQnKSxcclxuICAgICAgICBidWJibGVzOiB0cnVlLFxyXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNhcHR1cmVkVHJhbnNhY3Rpb24gPSBlZGl0b3IuY2FwdHVyZVRyYW5zYWN0aW9uKCgpID0+IHtcclxuICAgICAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSk7XHJcbiAgICB9KTtcclxuICAgIGNhcHR1cmVkVHJhbnNhY3Rpb24gPT09IG51bGwgfHwgY2FwdHVyZWRUcmFuc2FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwdHVyZWRUcmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKTtcclxuICAgICAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICB0ci5tYXliZVN0ZXAobmV3U3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuZnVuY3Rpb24gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcclxuICAgIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xyXG4gICAgY29uc3Qgbm9kZVJhbmdlcyA9IFtdO1xyXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xyXG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcclxuICAgICAgICBub2RlUmFuZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXHJcbiAgICAgICAgICAgIHRvOiByZWxhdGl2ZVRvLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHRvIC0gZnJvbTtcclxuICAgIGNvbnN0IG1hdGNoZWROb2RlUmFuZ2VzID0gbm9kZVJhbmdlc1xyXG4gICAgICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG5vZGVSYW5nZS5ub2RlLnR5cGUubmFtZTtcclxuICAgIH0pXHJcbiAgICAgICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSk7XHJcbiAgICBpZiAoZW1wdHkpIHtcclxuICAgICAgICByZXR1cm4gISFtYXRjaGVkTm9kZVJhbmdlcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYW5nZSA9IG1hdGNoZWROb2RlUmFuZ2VzLnJlZHVjZSgoc3VtLCBub2RlUmFuZ2UpID0+IHN1bSArIG5vZGVSYW5nZS50byAtIG5vZGVSYW5nZS5mcm9tLCAwKTtcclxuICAgIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZTtcclxufVxuXG5jb25zdCBsaWZ0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaWZ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIGxpZnRFbXB0eUJsb2NrJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3QgbGlmdExpc3RJdGVtID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICByZXR1cm4gbGlmdExpc3RJdGVtJDEodHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3QgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gbmV3bGluZUluQ29kZSQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIHR5cGUgb2YgYSBzY2hlbWEgaXRlbSBieSBpdHMgbmFtZS5cclxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYSBpdGVtXHJcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlyb3Igc2NoZW1hIHRvIHNlYXJjaCBpblxyXG4gKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgc2NoZW1hIGl0ZW0gKGBub2RlYCBvciBgbWFya2ApLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHNjaGVtYSkge1xyXG4gICAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xyXG4gICAgICAgIHJldHVybiAnbm9kZSc7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XHJcbiAgICAgICAgcmV0dXJuICdtYXJrJztcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0XHJcbiAqIEBwYXJhbSBvYmogT2JqZWN0XHJcbiAqIEBwYXJhbSBrZXkgS2V5IHRvIHJlbW92ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqLCBwcm9wT3JQcm9wcykge1xyXG4gICAgY29uc3QgcHJvcHMgPSB0eXBlb2YgcHJvcE9yUHJvcHMgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgPyBbcHJvcE9yUHJvcHNdXHJcbiAgICAgICAgOiBwcm9wT3JQcm9wcztcclxuICAgIHJldHVybiBPYmplY3RcclxuICAgICAgICAua2V5cyhvYmopXHJcbiAgICAgICAgLnJlZHVjZSgobmV3T2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgaWYgKCFwcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xyXG4gICAgICAgICAgICBuZXdPYmpbcHJvcF0gPSBvYmpbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICB9LCB7fSk7XHJcbn1cblxuY29uc3QgcmVzZXRBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgbGV0IG5vZGVUeXBlID0gbnVsbDtcclxuICAgIGxldCBtYXJrVHlwZSA9IG51bGw7XHJcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGlmICghc2NoZW1hVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcclxuICAgICAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XHJcbiAgICAgICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcclxuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwgZGVsZXRlUHJvcHMobm9kZS5hdHRycywgYXR0cmlidXRlcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3Qgc2VsZWN0QWxsID0gKCkgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcclxuICAgIHJldHVybiBjb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKHtcclxuICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgIHRvOiB0ci5kb2MuY29udGVudC5zaXplLFxyXG4gICAgfSk7XHJcbn07XG5cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gc2VsZWN0Tm9kZUJhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIHNlbGVjdE5vZGVGb3J3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gc2VsZWN0UGFyZW50Tm9kZSQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbi8vIEB0cy1pZ25vcmVcclxuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBzZWxlY3RUZXh0YmxvY2tFbmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBzZWxlY3RUZXh0YmxvY2tTdGFydCQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgUHJvc2VtaXJyb3IgZG9jdW1lbnQgbm9kZSBmcm9tIGNvbnRlbnQuXHJcbiAqIEBwYXJhbSBjb250ZW50IFRoZSBKU09OIG9yIEhUTUwgY29udGVudCB0byBjcmVhdGUgdGhlIGRvY3VtZW50IGZyb21cclxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHVzZSBmb3IgdGhlIGRvY3VtZW50XHJcbiAqIEBwYXJhbSBwYXJzZU9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHBhcnNlclxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBQcm9zZW1pcnJvciBkb2N1bWVudCBub2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudChjb250ZW50LCBzY2hlbWEsIHBhcnNlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgeyBzbGljZTogZmFsc2UsIHBhcnNlT3B0aW9ucyB9KTtcclxufVxuXG5jb25zdCBzZXRDb250ZW50ID0gKGNvbnRlbnQsIGVtaXRVcGRhdGUgPSBmYWxzZSwgcGFyc2VPcHRpb25zID0ge30pID0+ICh7IHRyLCBlZGl0b3IsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcclxuICAgIGNvbnN0IGRvY3VtZW50ID0gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgZWRpdG9yLnNjaGVtYSwgcGFyc2VPcHRpb25zKTtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIGRvY3VtZW50KS5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCBtYXJrcyA9IFtdO1xyXG4gICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XHJcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xyXG4gICAgaWYgKCFtYXJrKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9O1xyXG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cclxuICogQHBhcmFtIG9sZERvYyBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzdGFydCBmcm9tXHJcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVGhlIHRyYW5zYWN0aW9ucyB0byBjb21iaW5lXHJcbiAqIEByZXR1cm5zIEEgbmV3IGBUcmFuc2Zvcm1gIHdpdGggYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhvbGREb2MsIHRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpO1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2godHJhbnNhY3Rpb24gPT4ge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xyXG59XG5cbi8qKlxyXG4gKiBHZXRzIHRoZSBkZWZhdWx0IGJsb2NrIHR5cGUgYXQgYSBnaXZlbiBtYXRjaFxyXG4gKiBAcGFyYW0gbWF0Y2ggVGhlIGNvbnRlbnQgbWF0Y2ggdG8gZ2V0IHRoZSBkZWZhdWx0IGJsb2NrIHR5cGUgZnJvbVxyXG4gKiBAcmV0dXJucyBUaGUgZGVmYXVsdCBibG9jayB0eXBlIG9yIG51bGxcclxuICovXHJcbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSArPSAxKSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xyXG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogRmluZCBjaGlsZHJlbiBpbnNpZGUgYSBQcm9zZW1pcnJvciBub2RlIHRoYXQgbWF0Y2ggYSBwcmVkaWNhdGUuXHJcbiAqIEBwYXJhbSBub2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHNlYXJjaCBpblxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbWF0Y2hcclxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgd2l0aCB0aGVpciBwb3NpdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUpIHtcclxuICAgIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xyXG4gICAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQsIHBvcykgPT4ge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgcG9zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XHJcbn1cblxuLyoqXHJcbiAqIFNhbWUgYXMgYGZpbmRDaGlsZHJlbmAgYnV0IHNlYXJjaGVzIG9ubHkgd2l0aGluIGEgYHJhbmdlYC5cclxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXHJcbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gc2VhcmNoIGluXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxyXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShub2RlLCByYW5nZSwgcHJlZGljYXRlKSB7XHJcbiAgICBjb25zdCBub2Rlc1dpdGhQb3MgPSBbXTtcclxuICAgIC8vIGlmIChyYW5nZS5mcm9tID09PSByYW5nZS50bykge1xyXG4gICAgLy8gICBjb25zdCBub2RlQXQgPSBub2RlLm5vZGVBdChyYW5nZS5mcm9tKVxyXG4gICAgLy8gICBpZiAobm9kZUF0KSB7XHJcbiAgICAvLyAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xyXG4gICAgLy8gICAgICAgbm9kZTogbm9kZUF0LFxyXG4gICAgLy8gICAgICAgcG9zOiByYW5nZS5mcm9tLFxyXG4gICAgLy8gICAgIH0pXHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH1cclxuICAgIG5vZGUubm9kZXNCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCAoY2hpbGQsIHBvcykgPT4ge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgcG9zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XHJcbn1cblxuLyoqXHJcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIGEgcmVzb2x2ZWQgcG9zaXRpb24gdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlLlxyXG4gKiBAcGFyYW0gJHBvcyBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gc2VhcmNoIGZyb21cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXHJcbiAqIEByZXR1cm5zIFRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIHRoZSByZXNvbHZlZCBwb3NpdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZVxyXG4gKiBAZXhhbXBsZSBgYGBqc1xyXG4gKiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcygkZnJvbSwgbm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJHBvcywgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aDsgaSA+IDA7IGkgLT0gMSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoaSk7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiAkcG9zLnN0YXJ0KGkpLFxyXG4gICAgICAgICAgICAgICAgZGVwdGg6IGksXHJcbiAgICAgICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRoYXQgbWF0Y2hlcyBhIHByZWRpY2F0ZS5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXHJcbiAqIEByZXR1cm5zIEEgY29tbWFuZCB0aGF0IGZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZVxyXG4gKiBAZXhhbXBsZSBgYGBqc1xyXG4gKiBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJylcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiAoc2VsZWN0aW9uKSA9PiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhzZWxlY3Rpb24uJGZyb20sIHByZWRpY2F0ZSk7XHJcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudCwgc2NoZW1hKSB7XHJcbiAgICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSkuc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpO1xyXG4gICAgY29uc3QgdGVtcG9yYXJ5RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XHJcbn1cblxuZnVuY3Rpb24gZ2V0U2NoZW1hKGV4dGVuc2lvbnMsIGVkaXRvcikge1xyXG4gICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xyXG4gICAgcmV0dXJuIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHJlc29sdmVkRXh0ZW5zaW9ucywgZWRpdG9yKTtcclxufVxuXG4vKipcclxuICogR2VuZXJhdGUgSFRNTCBmcm9tIGEgSlNPTkNvbnRlbnRcclxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgSFRNTCBmcm9tXHJcbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxyXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhUTUxcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2MsIGV4dGVuc2lvbnMpIHtcclxuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcclxuICAgIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZSQxLmZyb21KU09OKHNjaGVtYSwgZG9jKTtcclxuICAgIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KGNvbnRlbnROb2RlLmNvbnRlbnQsIHNjaGVtYSk7XHJcbn1cblxuLyoqXHJcbiAqIEdlbmVyYXRlIEpTT05Db250ZW50IGZyb20gSFRNTFxyXG4gKiBAcGFyYW0gaHRtbCBUaGUgSFRNTCB0byBnZW5lcmF0ZSBKU09OQ29udGVudCBmcm9tXHJcbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxyXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEpTT05Db250ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbCwgZXh0ZW5zaW9ucykge1xyXG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbCk7XHJcbiAgICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xyXG59XG5cbi8qKlxyXG4gKiBHZXRzIHRoZSB0ZXh0IG9mIGEgUHJvc2VtaXJyb3Igbm9kZVxyXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBzZXJpYWxpemVyICYgYmxvY2sgc2VwYXJhdG9yXHJcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IG9mIHRoZSBub2RlXHJcbiAqIEBleGFtcGxlIGBgYGpzXHJcbiAqIGNvbnN0IHRleHQgPSBnZXRUZXh0KG5vZGUsIHsgYmxvY2tTZXBhcmF0b3I6ICdcXG4nIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGV4dChub2RlLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCByYW5nZSA9IHtcclxuICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgIHRvOiBub2RlLmNvbnRlbnQuc2l6ZSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpO1xyXG59XG5cbi8qKlxyXG4gKiBHZW5lcmF0ZSByYXcgdGV4dCBmcm9tIGEgSlNPTkNvbnRlbnRcclxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgdGV4dCBmcm9tXHJcbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBnZW5lcmF0aW9uIGYuZS4gYmxvY2tTZXBhcmF0b3Igb3IgdGV4dFNlcmlhbGl6ZXJzXHJcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KGRvYywgZXh0ZW5zaW9ucywgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcclxuICAgIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZSQxLmZyb21KU09OKHNjaGVtYSwgZG9jKTtcclxuICAgIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XHJcbiAgICAgICAgYmxvY2tTZXBhcmF0b3IsXHJcbiAgICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XHJcbiAgICAgICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcclxuICAgICAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCBub2RlcyA9IFtdO1xyXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XHJcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzLnJldmVyc2UoKS5maW5kKG5vZGVJdGVtID0+IG5vZGVJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKTtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfTtcclxufVxuXG4vKipcclxuICogR2V0IG5vZGUgb3IgbWFyayBhdHRyaWJ1dGVzIGJ5IHR5cGUgb3IgbmFtZSBvbiB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGVcclxuICogQHBhcmFtIHN0YXRlIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxyXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSBvciBtYXJrIHR5cGUgb3IgbmFtZVxyXG4gKiBAcmV0dXJucyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZSBvciBtYXJrIG9yIGFuIGVtcHR5IG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xyXG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcclxuICAgIH1cclxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59XG5cbi8qKlxyXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgdmFsdWVzIHdpdGhpbiBhbiBhcnJheS5cclxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoYXJyYXksIGJ5ID0gSlNPTi5zdHJpbmdpZnkpIHtcclxuICAgIGNvbnN0IHNlZW4gPSB7fTtcclxuICAgIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYnkoaXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpXHJcbiAgICAgICAgICAgID8gZmFsc2VcclxuICAgICAgICAgICAgOiAoc2VlbltrZXldID0gdHJ1ZSk7XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHJhbmdlcyBhbmQgcmFuZ2VzIHRoYXQgYXJlXHJcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cclxuICovXHJcbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKSB7XHJcbiAgICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKTtcclxuICAgIHJldHVybiB1bmlxdWVDaGFuZ2VzLmxlbmd0aCA9PT0gMVxyXG4gICAgICAgID8gdW5pcXVlQ2hhbmdlc1xyXG4gICAgICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiAhcmVzdC5zb21lKG90aGVyQ2hhbmdlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlLm9sZFJhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm9sZFJhbmdlLnRvXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UuZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5nZWQgcmFuZ2VzXHJcbiAqIGJhc2VkIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZSBvZiBhbGwgc3RlcHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSkge1xyXG4gICAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtO1xyXG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xyXG4gICAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gW107XHJcbiAgICAgICAgLy8gVGhpcyBhY2NvdW50cyBmb3Igc3RlcCBjaGFuZ2VzIHdoZXJlIG5vIHJhbmdlIHdhcyBhY3R1YWxseSBhbHRlcmVkXHJcbiAgICAgICAgLy8gZS5nLiB3aGVuIHNldHRpbmcgYSBtYXJrLCBub2RlIGF0dHJpYnV0ZSwgZXRjLlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBpZiAoIXN0ZXBNYXAucmFuZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGVwc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTdGFydCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChmcm9tLCAtMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcCh0byk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkRW5kID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3RW5kKTtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9sZFJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogb2xkU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdG86IG9sZEVuZCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdSYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiBuZXdFbmQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcclxufVxuXG5mdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZSwgc3RhcnRPZmZzZXQgPSAwKSB7XHJcbiAgICBjb25zdCBpc1RvcE5vZGUgPSBub2RlLnR5cGUgPT09IG5vZGUudHlwZS5zY2hlbWEudG9wTm9kZVR5cGU7XHJcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMTtcclxuICAgIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldDtcclxuICAgIGNvbnN0IHRvID0gZnJvbSArIG5vZGUubm9kZVNpemU7XHJcbiAgICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcclxuICAgICAgICAgICAgdHlwZTogbWFyay50eXBlLm5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWFyay5hdHRycykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hdHRycyA9IHsgLi4ubWFyay5hdHRycyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9O1xyXG4gICAgY29uc3Qgb3V0cHV0ID0ge1xyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZS5uYW1lLFxyXG4gICAgICAgIGZyb20sXHJcbiAgICAgICAgdG8sXHJcbiAgICB9O1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcclxuICAgICAgICBvdXRwdXQuYXR0cnMgPSBhdHRycztcclxuICAgIH1cclxuICAgIGlmIChtYXJrcy5sZW5ndGgpIHtcclxuICAgICAgICBvdXRwdXQubWFya3MgPSBtYXJrcztcclxuICAgIH1cclxuICAgIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xyXG4gICAgICAgIG91dHB1dC5jb250ZW50ID0gW107XHJcbiAgICAgICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgKF9hID0gb3V0cHV0LmNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKGdldERlYnVnSlNPTihjaGlsZCwgc3RhcnRPZmZzZXQgKyBvZmZzZXQgKyBpbmNyZW1lbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnRleHQpIHtcclxuICAgICAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dDtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cblxuZnVuY3Rpb24gZ2V0TWFya3NCZXR3ZWVuKGZyb20sIHRvLCBkb2MpIHtcclxuICAgIGNvbnN0IG1hcmtzID0gW107XHJcbiAgICAvLyBnZXQgYWxsIGluY2x1c2l2ZSBtYXJrcyBvbiBlbXB0eSBzZWxlY3Rpb25cclxuICAgIGlmIChmcm9tID09PSB0bykge1xyXG4gICAgICAgIGRvY1xyXG4gICAgICAgICAgICAucmVzb2x2ZShmcm9tKVxyXG4gICAgICAgICAgICAubWFya3MoKVxyXG4gICAgICAgICAgICAuZm9yRWFjaChtYXJrID0+IHtcclxuICAgICAgICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20gLSAxKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKTtcclxuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbWFyayxcclxuICAgICAgICAgICAgICAgIC4uLnJhbmdlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFub2RlIHx8IChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubm9kZVNpemUpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcclxuICAgICAgICAgICAgICAgIGZyb206IHBvcyxcclxuICAgICAgICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxyXG4gICAgICAgICAgICAgICAgbWFyayxcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXJrcztcclxufVxuXG4vKipcclxuICogRmluZHMgdGhlIGZpcnN0IG5vZGUgb2YgYSBnaXZlbiB0eXBlIG9yIG5hbWUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gKiBAcGFyYW0gc3RhdGUgVGhlIGVkaXRvciBzdGF0ZS5cclxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxyXG4gKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cclxuICogQHBhcmFtIG1heERlcHRoIFRoZSBtYXhpbXVtIGRlcHRoIHRvIHNlYXJjaC5cclxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cclxuICovXHJcbmNvbnN0IGdldE5vZGVBdFBvc2l0aW9uID0gKHN0YXRlLCB0eXBlT3JOYW1lLCBwb3MsIG1heERlcHRoID0gMjApID0+IHtcclxuICAgIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xyXG4gICAgbGV0IGN1cnJlbnREZXB0aCA9IG1heERlcHRoO1xyXG4gICAgbGV0IG5vZGUgPSBudWxsO1xyXG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aCk7XHJcbiAgICAgICAgaWYgKChjdXJyZW50Tm9kZSA9PT0gbnVsbCB8fCBjdXJyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudE5vZGUudHlwZS5uYW1lKSA9PT0gdHlwZU9yTmFtZSkge1xyXG4gICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50RGVwdGggLT0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF07XHJcbn07XG5cbi8qKlxyXG4gKiBSZXR1cm4gYXR0cmlidXRlcyBvZiBhbiBleHRlbnNpb24gdGhhdCBzaG91bGQgYmUgc3BsaXR0ZWQgYnkga2VlcE9uU3BsaXQgZmxhZ1xyXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBBcnJheSBvZiBleHRlbnNpb24gYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0gdHlwZU5hbWUgVGhlIHR5cGUgb2YgdGhlIGV4dGVuc2lvblxyXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgZXh0ZW5zaW9uXHJcbiAqIEByZXR1cm5zIFRoZSBzcGxpdHRlZCBhdHRyaWJ1dGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgdHlwZU5hbWUsIGF0dHJpYnV0ZXMpIHtcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0XHJcbiAgICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcclxuICAgICAgICAuZmlsdGVyKChbbmFtZV0pID0+IHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0O1xyXG4gICAgfSkpO1xyXG59XG5cbmZ1bmN0aW9uIGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcclxuICAgIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XHJcbiAgICBpZiAoZW1wdHkpIHtcclxuICAgICAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIobWFyayA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbmQobWFyayA9PiBvYmplY3RJbmNsdWRlcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gMDtcclxuICAgIGNvbnN0IG1hcmtSYW5nZXMgPSBbXTtcclxuICAgIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XHJcbiAgICAgICAgY29uc3QgdG8gPSAkdG8ucG9zO1xyXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHJlbGF0aXZlVG8gLSByZWxhdGl2ZUZyb207XHJcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlO1xyXG4gICAgICAgICAgICBtYXJrUmFuZ2VzLnB1c2goLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbWFyayxcclxuICAgICAgICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcclxuICAgICAgICAgICAgICAgIHRvOiByZWxhdGl2ZVRvLFxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoc2VsZWN0aW9uUmFuZ2UgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWF0Y2hlZCBtYXJrXHJcbiAgICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXHJcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFya1JhbmdlLm1hcmsudHlwZS5uYW1lO1xyXG4gICAgfSlcclxuICAgICAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxyXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMCk7XHJcbiAgICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWFya3MgdGhhdCBleGNsdWRlcyB0aGUgc2VhcmNoZWQgbWFya1xyXG4gICAgLy8gZm9yIGV4YW1wbGUgYGNvZGVgIGRvZXNu4oCZdCBhbGxvdyBhbnkgb3RoZXIgbWFya3NcclxuICAgIGNvbnN0IGV4Y2x1ZGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXHJcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKTtcclxuICAgIH0pXHJcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcclxuICAgIC8vIHdlIG9ubHkgaW5jbHVkZSB0aGUgcmVzdWx0IG9mIGBleGNsdWRlZFJhbmdlYFxyXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBtYXRjaCBhdCBhbGxcclxuICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2U7XHJcbiAgICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XHJcbn1cblxuZnVuY3Rpb24gaXNBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcykgfHwgaXNNYXJrQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xyXG4gICAgICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xyXG4gICAgICAgIHJldHVybiBpc01hcmtBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbmNvbnN0IGlzQXRFbmRPZk5vZGUgPSAoc3RhdGUsIG5vZGVUeXBlKSA9PiB7XHJcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8sICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcclxuICAgIGlmIChub2RlVHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSBub2RlVHlwZSkoc3RhdGUuc2VsZWN0aW9uKTtcclxuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gc3RhdGUuZG9jLnJlc29sdmUocGFyZW50Tm9kZS5wb3MgKyAxKTtcclxuICAgICAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBpc0F0U3RhcnRPZk5vZGUgPSAoc3RhdGUpID0+IHtcclxuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmZ1bmN0aW9uIGlzTGlzdChuYW1lLCBleHRlbnNpb25zKSB7XHJcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XHJcbiAgICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcclxuICAgIGlmICghZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcclxuICAgIH07XHJcbiAgICBjb25zdCBncm91cCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKTtcclxuICAgIGlmICh0eXBlb2YgZ3JvdXAgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdyb3VwLnNwbGl0KCcgJykuaW5jbHVkZXMoJ2xpc3QnKTtcclxufVxuXG5mdW5jdGlvbiBpc05vZGVFbXB0eShub2RlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBkZWZhdWx0Q29udGVudCA9IChfYSA9IG5vZGUudHlwZS5jcmVhdGVBbmRGaWxsKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBub2RlLnRvSlNPTigpO1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlZmF1bHRDb250ZW50KSA9PT0gSlNPTi5zdHJpbmdpZnkoY29udGVudCk7XHJcbn1cblxuZnVuY3Rpb24gaXNOb2RlU2VsZWN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uO1xyXG59XG5cbmZ1bmN0aW9uIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bykge1xyXG4gICAgY29uc3QgbWluUG9zID0gMDtcclxuICAgIGNvbnN0IG1heFBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcclxuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XHJcbiAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRnJvbSk7XHJcbiAgICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSk7XHJcbiAgICBjb25zdCB0b3AgPSBNYXRoLm1pbihzdGFydC50b3AsIGVuZC50b3ApO1xyXG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoc3RhcnQuYm90dG9tLCBlbmQuYm90dG9tKTtcclxuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdCk7XHJcbiAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0LnJpZ2h0LCBlbmQucmlnaHQpO1xyXG4gICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XHJcbiAgICBjb25zdCB4ID0gbGVmdDtcclxuICAgIGNvbnN0IHkgPSB0b3A7XHJcbiAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgIHRvcCxcclxuICAgICAgICBib3R0b20sXHJcbiAgICAgICAgbGVmdCxcclxuICAgICAgICByaWdodCxcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgeCxcclxuICAgICAgICB5LFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uZGF0YSxcclxuICAgICAgICB0b0pTT046ICgpID0+IGRhdGEsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGUsIHRyLCBuZXdNYXJrVHlwZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xyXG4gICAgbGV0IGN1cnNvciA9IG51bGw7XHJcbiAgICBpZiAoaXNUZXh0U2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcclxuICAgICAgICBjdXJzb3IgPSBzZWxlY3Rpb24uJGN1cnNvcjtcclxuICAgIH1cclxuICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWFya3MgPSAoX2EgPSBzdGF0ZS5zdG9yZWRNYXJrcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3Vyc29yLm1hcmtzKCk7XHJcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xyXG4gICAgICAgIHJldHVybiAoISFuZXdNYXJrVHlwZS5pc0luU2V0KGN1cnJlbnRNYXJrcylcclxuICAgICAgICAgICAgfHwgIWN1cnJlbnRNYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcclxuICAgIHJldHVybiByYW5nZXMuc29tZSgoeyAkZnJvbSwgJHRvIH0pID0+IHtcclxuICAgICAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxyXG4gICAgICAgICAgICA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxyXG4gICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBtYXJrIHRoYXQgd2UgY2FuIGVuYWJsZSwgcmV0dXJuIGZhbHNlIHRvIGJ5cGFzcyB0aGUgcmVtYWluaW5nIHNlYXJjaFxyXG4gICAgICAgICAgICBpZiAoc29tZU5vZGVTdXBwb3J0c01hcmspIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0lubGluZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUgPSAhIW5ld01hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcylcclxuICAgICAgICAgICAgICAgICAgICB8fCAhbm9kZS5tYXJrcy5zb21lKG90aGVyTWFyayA9PiBvdGhlck1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpO1xyXG4gICAgICAgICAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAhc29tZU5vZGVTdXBwb3J0c01hcms7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNvbWVOb2RlU3VwcG9ydHNNYXJrO1xyXG4gICAgfSk7XHJcbn1cclxuY29uc3Qgc2V0TWFyayA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xyXG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIGlmIChlbXB0eSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGUpO1xyXG4gICAgICAgICAgICB0ci5hZGRTdG9yZWRNYXJrKHR5cGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIC4uLm9sZEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29tZUhhc01hcmsgPSBub2RlLm1hcmtzLmZpbmQobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBoYXZlIHRvIG1lcmdlIGl0cyBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBhIGZyZXNoIG5ldyBtYXJrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXJrLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCB0eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSk7XHJcbn07XG5cbmNvbnN0IHNldE1ldGEgPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xyXG4gICAgdHIuc2V0TWV0YShrZXksIHZhbHVlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBzZXROb2RlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiB9KSA9PiB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cclxuICAgIGlmICghdHlwZS5pc1RleHRibG9jaykge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogQ3VycmVudGx5IFwic2V0Tm9kZSgpXCIgb25seSBzdXBwb3J0cyB0ZXh0IGJsb2NrIG5vZGVzLicpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY2hhaW4oKVxyXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxyXG4gICAgICAgIC5jb21tYW5kKCh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICBjb25zdCBjYW5TZXRCbG9jayA9IHNldEJsb2NrVHlwZSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSk7XHJcbiAgICAgICAgaWYgKGNhblNldEJsb2NrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xyXG4gICAgfSlcclxuICAgICAgICAuY29tbWFuZCgoeyBzdGF0ZTogdXBkYXRlZFN0YXRlIH0pID0+IHtcclxuICAgICAgICByZXR1cm4gc2V0QmxvY2tUeXBlKHR5cGUsIGF0dHJpYnV0ZXMpKHVwZGF0ZWRTdGF0ZSwgZGlzcGF0Y2gpO1xyXG4gICAgfSlcclxuICAgICAgICAucnVuKCkpO1xyXG59O1xuXG5jb25zdCBzZXROb2RlU2VsZWN0aW9uID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcclxuICAgICAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKTtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pO1xyXG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IHNldFRleHRTZWxlY3Rpb24gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgeyBkb2MgfSA9IHRyO1xyXG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IG1pblBvcyA9IFRleHRTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb207XHJcbiAgICAgICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpO1xyXG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IHNpbmtMaXN0SXRlbSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgcmV0dXJuIHNpbmtMaXN0SXRlbSQxKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmZ1bmN0aW9uIGVuc3VyZU1hcmtzKHN0YXRlLCBzcGxpdHRhYmxlTWFya3MpIHtcclxuICAgIGNvbnN0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcclxuICAgIGlmIChtYXJrcykge1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MgPT09IG51bGwgfHwgc3BsaXR0YWJsZU1hcmtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcclxuICAgICAgICBzdGF0ZS50ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBzcGxpdEJsb2NrID0gKHsga2VlcE1hcmtzID0gdHJ1ZSB9ID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciwgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XHJcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvbjtcclxuICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzO1xyXG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xyXG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xyXG4gICAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChkb2MsICRmcm9tLnBvcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgaWYgKGtlZXBNYXJrcykge1xyXG4gICAgICAgICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xyXG4gICAgICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwXHJcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcclxuICAgICAgICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdFxyXG4gICAgICAgICAgICA/IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkZWZsdCxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xyXG4gICAgICAgIGlmICghdHlwZXNcclxuICAgICAgICAgICAgJiYgIWNhblxyXG4gICAgICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgIGNhbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHR5cGVzID0gZGVmbHRcclxuICAgICAgICAgICAgICAgID8gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVmbHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbikge1xyXG4gICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XHJcbiAgICAgICAgICAgIGlmIChkZWZsdCAmJiAhYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPT0gZGVmbHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtlZXBNYXJrcykge1xyXG4gICAgICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBzcGxpdExpc3RJdGVtID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsIH0pID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZTtcclxuICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcclxuICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9PSB0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XHJcbiAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xyXG4gICAgICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xyXG4gICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XHJcbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cclxuICAgICAgICBpZiAoJGZyb20uZGVwdGggPT09IDJcclxuICAgICAgICAgICAgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZVxyXG4gICAgICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcclxuICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXHJcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICBjb25zdCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xyXG4gICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0VHlwZSA9ICgoX2EgPSB0eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZUFuZEZpbGwobmV3TmV4dFR5cGVBdHRyaWJ1dGVzKSkgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcclxuICAgICAgICAgICAgdHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XHJcbiAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcclxuICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG4sIHBvcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG4uaXNUZXh0YmxvY2sgJiYgbi5jb250ZW50LnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHNlbCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XHJcbiAgICBjb25zdCBuZXdUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCBncmFuZFBhcmVudC50eXBlLm5hbWUsIGdyYW5kUGFyZW50LmF0dHJzKTtcclxuICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xyXG4gICAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XHJcbiAgICBjb25zdCB0eXBlcyA9IG5leHRUeXBlXHJcbiAgICAgICAgPyBbXHJcbiAgICAgICAgICAgIHsgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH0sXHJcbiAgICAgICAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcclxuICAgICAgICBdXHJcbiAgICAgICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV07XHJcbiAgICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XHJcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xyXG4gICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcclxuICAgICAgICB0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgIGlmICghbWFya3MgfHwgIWRpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XHJcbiAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3Qgam9pbkxpc3RCYWNrd2FyZHMgPSAodHIsIGxpc3RUeXBlKSA9PiB7XHJcbiAgICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xyXG4gICAgaWYgKCFsaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aCk7XHJcbiAgICBpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vZGVCZWZvcmUgPSB0ci5kb2Mubm9kZUF0KGJlZm9yZSk7XHJcbiAgICBjb25zdCBjYW5Kb2luQmFja3dhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQmVmb3JlID09PSBudWxsIHx8IG5vZGVCZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVCZWZvcmUudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKTtcclxuICAgIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdHIuam9pbihsaXN0LnBvcyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcclxuICAgIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XHJcbiAgICBpZiAoIWxpc3QpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFmdGVyID0gdHIuZG9jLnJlc29sdmUobGlzdC5zdGFydCkuYWZ0ZXIobGlzdC5kZXB0aCk7XHJcbiAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcik7XHJcbiAgICBjb25zdCBjYW5Kb2luRm9yd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVBZnRlciA9PT0gbnVsbCB8fCBub2RlQWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVBZnRlci50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpO1xyXG4gICAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRyLmpvaW4oYWZ0ZXIpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbmNvbnN0IHRvZ2dsZUxpc3QgPSAobGlzdFR5cGVPck5hbWUsIGl0ZW1UeXBlT3JOYW1lLCBrZWVwTWFya3MsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgZWRpdG9yLCB0ciwgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiwgY29tbWFuZHMsIGNhbiwgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xyXG4gICAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IGl0ZW1UeXBlID0gZ2V0Tm9kZVR5cGUoaXRlbVR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xyXG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XHJcbiAgICBjb25zdCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcclxuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcclxuICAgIGlmICghcmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnRMaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBpc0xpc3Qobm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpKShzZWxlY3Rpb24pO1xyXG4gICAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xyXG4gICAgICAgIC8vIHJlbW92ZSBsaXN0XHJcbiAgICAgICAgaWYgKHBhcmVudExpc3Qubm9kZS50eXBlID09PSBsaXN0VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZHMubGlmdExpc3RJdGVtKGl0ZW1UeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hhbmdlIGxpc3QgdHlwZVxyXG4gICAgICAgIGlmIChpc0xpc3QocGFyZW50TGlzdC5ub2RlLnR5cGUubmFtZSwgZXh0ZW5zaW9ucylcclxuICAgICAgICAgICAgJiYgbGlzdFR5cGUudmFsaWRDb250ZW50KHBhcmVudExpc3Qubm9kZS5jb250ZW50KVxyXG4gICAgICAgICAgICAmJiBkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxyXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxyXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKVxyXG4gICAgICAgICAgICAgICAgLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gY2hhaW4oKVxyXG4gICAgICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxyXG4gICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxyXG4gICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXHJcbiAgICAgICAgICAgIC5ydW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY2hhaW4oKVxyXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxyXG4gICAgICAgIC5jb21tYW5kKCgpID0+IHtcclxuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xyXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xyXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xyXG4gICAgfSlcclxuICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcclxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxyXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcclxuICAgICAgICAucnVuKCkpO1xyXG59O1xuXG5jb25zdCB0b2dnbGVNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICBpZiAoaXNBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHR5cGUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKTtcclxufTtcblxuY29uc3QgdG9nZ2xlTm9kZSA9ICh0eXBlT3JOYW1lLCB0b2dnbGVUeXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgaWYgKGlzQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodG9nZ2xlVHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0eXBlLCBhdHRyaWJ1dGVzKTtcclxufTtcblxuY29uc3QgdG9nZ2xlV3JhcCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxuICAgIGlmIChpc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKTtcclxufTtcblxuY29uc3QgdW5kb0lucHV0UnVsZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XHJcbiAgICAgICAgbGV0IHVuZG9hYmxlO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XG5cbmNvbnN0IHVuc2V0QWxsTWFya3MgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xyXG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XHJcbiAgICBpZiAoZW1wdHkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcclxuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IHVuc2V0TWFyayA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XHJcbiAgICBpZiAoIWRpc3BhdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoZW1wdHkgJiYgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UpIHtcclxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGF0dHJzID0gKF9hID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRycyk7XHJcbiAgICAgICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIGZyb20gPSByYW5nZS5mcm9tO1xyXG4gICAgICAgICAgICB0byA9IHJhbmdlLnRvO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcclxuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIHR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCB1cGRhdGVBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBsZXQgbm9kZVR5cGUgPSBudWxsO1xyXG4gICAgbGV0IG1hcmtUeXBlID0gbnVsbDtcclxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgaWYgKCFzY2hlbWFUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xyXG4gICAgICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIH1cclxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcclxuICAgICAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xyXG4gICAgICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XHJcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCBtYXJrVHlwZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCB3cmFwSW4gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICByZXR1cm4gd3JhcEluJDEodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3Qgd3JhcEluTGlzdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIHJldHVybiB3cmFwSW5MaXN0JDEodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxudmFyIGNvbW1hbmRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJsdXI6IGJsdXIsXG4gIGNsZWFyQ29udGVudDogY2xlYXJDb250ZW50LFxuICBjbGVhck5vZGVzOiBjbGVhck5vZGVzLFxuICBjb21tYW5kOiBjb21tYW5kLFxuICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiBjcmVhdGVQYXJhZ3JhcGhOZWFyLFxuICBjdXQ6IGN1dCxcbiAgZGVsZXRlQ3VycmVudE5vZGU6IGRlbGV0ZUN1cnJlbnROb2RlLFxuICBkZWxldGVOb2RlOiBkZWxldGVOb2RlLFxuICBkZWxldGVSYW5nZTogZGVsZXRlUmFuZ2UsXG4gIGRlbGV0ZVNlbGVjdGlvbjogZGVsZXRlU2VsZWN0aW9uLFxuICBlbnRlcjogZW50ZXIsXG4gIGV4aXRDb2RlOiBleGl0Q29kZSxcbiAgZXh0ZW5kTWFya1JhbmdlOiBleHRlbmRNYXJrUmFuZ2UsXG4gIGZpcnN0OiBmaXJzdCxcbiAgZm9jdXM6IGZvY3VzLFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxuICBpbnNlcnRDb250ZW50QXQ6IGluc2VydENvbnRlbnRBdCxcbiAgam9pblVwOiBqb2luVXAsXG4gIGpvaW5Eb3duOiBqb2luRG93bixcbiAgam9pbkJhY2t3YXJkOiBqb2luQmFja3dhcmQsXG4gIGpvaW5Gb3J3YXJkOiBqb2luRm9yd2FyZCxcbiAgam9pbkl0ZW1CYWNrd2FyZDogam9pbkl0ZW1CYWNrd2FyZCxcbiAgam9pbkl0ZW1Gb3J3YXJkOiBqb2luSXRlbUZvcndhcmQsXG4gIGpvaW5UZXh0YmxvY2tCYWNrd2FyZDogam9pblRleHRibG9ja0JhY2t3YXJkLFxuICBqb2luVGV4dGJsb2NrRm9yd2FyZDogam9pblRleHRibG9ja0ZvcndhcmQsXG4gIGtleWJvYXJkU2hvcnRjdXQ6IGtleWJvYXJkU2hvcnRjdXQsXG4gIGxpZnQ6IGxpZnQsXG4gIGxpZnRFbXB0eUJsb2NrOiBsaWZ0RW1wdHlCbG9jayxcbiAgbGlmdExpc3RJdGVtOiBsaWZ0TGlzdEl0ZW0sXG4gIG5ld2xpbmVJbkNvZGU6IG5ld2xpbmVJbkNvZGUsXG4gIHJlc2V0QXR0cmlidXRlczogcmVzZXRBdHRyaWJ1dGVzLFxuICBzY3JvbGxJbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICBzZWxlY3ROb2RlQmFja3dhcmQ6IHNlbGVjdE5vZGVCYWNrd2FyZCxcbiAgc2VsZWN0Tm9kZUZvcndhcmQ6IHNlbGVjdE5vZGVGb3J3YXJkLFxuICBzZWxlY3RQYXJlbnROb2RlOiBzZWxlY3RQYXJlbnROb2RlLFxuICBzZWxlY3RUZXh0YmxvY2tFbmQ6IHNlbGVjdFRleHRibG9ja0VuZCxcbiAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICBzZXRNYXJrOiBzZXRNYXJrLFxuICBzZXRNZXRhOiBzZXRNZXRhLFxuICBzZXROb2RlOiBzZXROb2RlLFxuICBzZXROb2RlU2VsZWN0aW9uOiBzZXROb2RlU2VsZWN0aW9uLFxuICBzZXRUZXh0U2VsZWN0aW9uOiBzZXRUZXh0U2VsZWN0aW9uLFxuICBzaW5rTGlzdEl0ZW06IHNpbmtMaXN0SXRlbSxcbiAgc3BsaXRCbG9jazogc3BsaXRCbG9jayxcbiAgc3BsaXRMaXN0SXRlbTogc3BsaXRMaXN0SXRlbSxcbiAgdG9nZ2xlTGlzdDogdG9nZ2xlTGlzdCxcbiAgdG9nZ2xlTWFyazogdG9nZ2xlTWFyayxcbiAgdG9nZ2xlTm9kZTogdG9nZ2xlTm9kZSxcbiAgdG9nZ2xlV3JhcDogdG9nZ2xlV3JhcCxcbiAgdW5kb0lucHV0UnVsZTogdW5kb0lucHV0UnVsZSxcbiAgdW5zZXRBbGxNYXJrczogdW5zZXRBbGxNYXJrcyxcbiAgdW5zZXRNYXJrOiB1bnNldE1hcmssXG4gIHVwZGF0ZUF0dHJpYnV0ZXM6IHVwZGF0ZUF0dHJpYnV0ZXMsXG4gIHdyYXBJbjogd3JhcEluLFxuICB3cmFwSW5MaXN0OiB3cmFwSW5MaXN0XG59KTtcblxuY29uc3QgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdjb21tYW5kcycsXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5jb21tYW5kcyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbmNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnZWRpdGFibGUnLFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdlZGl0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdmb2N1c0V2ZW50cycsXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XHJcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZvY3VzRXZlbnRzJyksXHJcbiAgICAgICAgICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ2ZvY3VzJywgeyBldmVudCB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50clxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG5jb25zdCBLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdrZXltYXAnLFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlQmFja3NwYWNlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy51bmRvSW5wdXRSdWxlKCksXHJcbiAgICAgICAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwb3MsIHBhcmVudCB9ID0gJGFuY2hvcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayAmJiBwb3MgPiAwID8gdHIuZG9jLnJlc29sdmUocG9zIC0gMSkgOiAkYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SXNJc29sYXRpbmcgPSAkcGFyZW50UG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRTdGFydCA9IChwYXJlbnRJc0lzb2xhdGluZyAmJiAkcGFyZW50UG9zLnBhcmVudC5jaGlsZENvdW50ID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50UG9zID09PSAkYW5jaG9yLnBvc1xyXG4gICAgICAgICAgICAgICAgICAgIDogU2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tID09PSBwb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5XHJcbiAgICAgICAgICAgICAgICAgICAgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpc0F0U3RhcnRcclxuICAgICAgICAgICAgICAgICAgICB8fCAoaXNBdFN0YXJ0ICYmICRhbmNob3IucGFyZW50LnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpIC8vIHByZXZlbnQgY2xlYXJOb2RlcyB3aGVuIG5vIG5vZGVzIHRvIGNsZWFyLCBvdGhlcndpc2UgaGlzdG9yeSBzdGFjayBpcyBhcHBlbmRlZFxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5qb2luQmFja3dhcmQoKSxcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuc2VsZWN0Tm9kZUJhY2t3YXJkKCksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkZvcndhcmQoKSxcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuc2VsZWN0Tm9kZUZvcndhcmQoKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBjb25zdCBoYW5kbGVFbnRlciA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMubmV3bGluZUluQ29kZSgpLFxyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmxpZnRFbXB0eUJsb2NrKCksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnNwbGl0QmxvY2soKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xyXG4gICAgICAgICAgICBFbnRlcjogaGFuZGxlRW50ZXIsXHJcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxyXG4gICAgICAgICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcclxuICAgICAgICAgICAgJ01vZC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXHJcbiAgICAgICAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXHJcbiAgICAgICAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxyXG4gICAgICAgICAgICAnTW9kLURlbGV0ZSc6IGhhbmRsZURlbGV0ZSxcclxuICAgICAgICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwY0tleW1hcCA9IHtcclxuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcclxuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcclxuICAgICAgICAgICAgJ0N0cmwtaCc6IGhhbmRsZUJhY2tzcGFjZSxcclxuICAgICAgICAgICAgJ0FsdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXHJcbiAgICAgICAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXHJcbiAgICAgICAgICAgICdDdHJsLUFsdC1CYWNrc3BhY2UnOiBoYW5kbGVEZWxldGUsXHJcbiAgICAgICAgICAgICdBbHQtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxyXG4gICAgICAgICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXHJcbiAgICAgICAgICAgICdDdHJsLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tTdGFydCgpLFxyXG4gICAgICAgICAgICAnQ3RybC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrRW5kKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hY0tleW1hcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBjS2V5bWFwO1xyXG4gICAgfSxcclxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXHJcbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcclxuICAgICAgICAgICAgLy8gdG8gYSBwYXJhZ3JhcGggaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcclxuICAgICAgICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxyXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcclxuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xlYXJEb2N1bWVudCcpLFxyXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxGcm9tID0gU2VsZWN0aW9uLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEVuZCA9IFNlbGVjdGlvbi5hdEVuZChvbGRTdGF0ZS5kb2MpLnRvO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eSB8fCAhYWxsV2FzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKDAsIG5ld1N0YXRlLmRvYy5jb250ZW50LnNpemUsICcgJywgJyAnKS5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHIgPSBuZXdTdGF0ZS50cjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG5jb25zdCBUYWJpbmRleCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ3RhYmluZGV4JyxcclxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcclxuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGFiaW5kZXgnKSxcclxuICAgICAgICAgICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSA/IHsgdGFiaW5kZXg6ICcwJyB9IDoge30sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIsXG4gIENvbW1hbmRzOiBDb21tYW5kcyxcbiAgRWRpdGFibGU6IEVkaXRhYmxlLFxuICBGb2N1c0V2ZW50czogRm9jdXNFdmVudHMsXG4gIEtleW1hcDogS2V5bWFwLFxuICBUYWJpbmRleDogVGFiaW5kZXhcbn0pO1xuXG5jbGFzcyBOb2RlUG9zIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvcywgZWRpdG9yLCBpc0Jsb2NrID0gZmFsc2UsIG5vZGUgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hY3R1YWxEZXB0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gaXNCbG9jaztcclxuICAgICAgICB0aGlzLnJlc29sdmVkUG9zID0gcG9zO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLnJlc29sdmVkUG9zLm5vZGUoKTtcclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbUF0UG9zKHRoaXMucG9zKS5ub2RlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRlcHRoKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5hY3R1YWxEZXB0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yZXNvbHZlZFBvcy5kZXB0aDtcclxuICAgIH1cclxuICAgIGdldCBwb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MucG9zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5jb250ZW50O1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbnRlbnQoY29udGVudCkge1xyXG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgICAgIGxldCB0byA9IHRoaXMudG87XHJcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFlvdSBjYW7igJl0IHNldCBjb250ZW50IG9uIGEgYmxvY2sgbm9kZS4gVHJpZWQgdG8gc2V0IGNvbnRlbnQgb24gJHt0aGlzLm5hbWV9IGF0ICR7dGhpcy5wb3N9YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJvbSA9IHRoaXMuZnJvbSArIDE7XHJcbiAgICAgICAgICAgIHRvID0gdGhpcy50byAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb20sIHRvIH0sIGNvbnRlbnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5hdHRycztcclxuICAgIH1cclxuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTtcclxuICAgIH1cclxuICAgIGdldCBmcm9tKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKTtcclxuICAgIH1cclxuICAgIGdldCByYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXHJcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXQgdG8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLmVuZCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKSArICh0aGlzLm5vZGUuaXNUZXh0ID8gMCA6IDEpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5kZXB0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50UG9zID0gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoIC0gMSk7XHJcbiAgICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUocGFyZW50UG9zKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJlZm9yZSgpIHtcclxuICAgICAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gKHRoaXMuaXNCbG9jayA/IDEgOiAyKSk7XHJcbiAgICAgICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcclxuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXQgYWZ0ZXIoKSB7XHJcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAodGhpcy5pc0Jsb2NrID8gMiA6IDEpKTtcclxuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xyXG4gICAgICAgICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXQgY2hpbGRyZW4oKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLm5vZGUuY29udGVudC5mb3JFYWNoKChub2RlLCBvZmZzZXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXNCbG9jayA9IG5vZGUuaXNCbG9jayAmJiAhbm9kZS5pc1RleHRibG9jaztcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGhpcy5wb3MgKyBvZmZzZXQgKyAxO1xyXG4gICAgICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpO1xyXG4gICAgICAgICAgICBpZiAoIWlzQmxvY2sgJiYgJHBvcy5kZXB0aCA8PSB0aGlzLmRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlUG9zID0gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCk7XHJcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBnZXQgZmlyc3RDaGlsZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBjbG9zZXN0KHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30pIHtcclxuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmICFub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5ub2RlLmF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhdHRyS2V5c1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlQXR0cmlidXRlc1trZXldICE9PSBhdHRyaWJ1dGVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHRydWUpWzBdIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZHMgYWxsIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yIGFuZCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICogSWYgZmlyc3RJdGVtT25seSBpcyB0cnVlLCBpdCB3aWxsIHJldHVybiB0aGUgZmlyc3QgaXRlbSBmb3VuZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZFBvcyA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBub2RlIGFuZCB3ZSBvbmx5IHdhbnQgdGhlIGZpcnN0IGl0ZW0sIHdlIGRvbnQgbmVlZCB0byBrZWVwIGdvaW5nXHJcbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hpbGRQb3Mubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2VzQWxsQXR0cmlidXRlc01hdGNoID0gYXR0cktleXMuZXZlcnkoa2V5ID0+IGF0dHJpYnV0ZXNba2V5XSA9PT0gY2hpbGRQb3Mubm9kZS5hdHRyc1trZXldKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2VzQWxsQXR0cmlidXRlc01hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZFBvcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgY2FuIHN0b3AgaGVyZSBhbmQgc2tpcCB0aGUgcmVjdXJzaW9uXHJcbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZFBvcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBmaXJzdEl0ZW1Pbmx5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG4gICAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBjb25zdCBvbGRTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICAgICAgdGhpcy5lZGl0b3IuY2hhaW4oKS5zZXRUZXh0U2VsZWN0aW9uKHRoaXMuZnJvbSkudXBkYXRlQXR0cmlidXRlcyh0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRUZXh0U2VsZWN0aW9uKG9sZFNlbGVjdGlvbi5mcm9tKVxyXG4gICAgICAgICAgICAucnVuKCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDFweCAhaW1wb3J0YW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMnB4O1xuICB3aWR0aDogMjBweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuICBhbmltYXRpb246IFByb3NlTWlycm9yLWN1cnNvci1ibGluayAxLjFzIHN0ZXBzKDIsIHN0YXJ0KSBpbmZpbml0ZTtcbn1cblxuQGtleWZyYW1lcyBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsge1xuICB0byB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqIHtcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZm9jdXNlZCAuUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi50aXBweS1ib3hbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5dIHtcbiAgb3BhY2l0eTogMFxufWA7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCBub25jZSwgc3VmZml4KSB7XHJcbiAgICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31dYCk7XHJcbiAgICBpZiAodGlwdGFwU3R5bGVUYWcgIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGlwdGFwU3R5bGVUYWc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgaWYgKG5vbmNlKSB7XHJcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XHJcbiAgICB9XHJcbiAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9YCwgJycpO1xyXG4gICAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xyXG4gICAgcmV0dXJuIHN0eWxlTm9kZTtcclxufVxuXG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxyXG4gICAgICAgICAgICBpbmplY3RDU1M6IHRydWUsXHJcbiAgICAgICAgICAgIGluamVjdE5vbmNlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtdLFxyXG4gICAgICAgICAgICBhdXRvZm9jdXM6IGZhbHNlLFxyXG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZWRpdG9yUHJvcHM6IHt9LFxyXG4gICAgICAgICAgICBwYXJzZU9wdGlvbnM6IHt9LFxyXG4gICAgICAgICAgICBjb3JlRXh0ZW5zaW9uT3B0aW9uczoge30sXHJcbiAgICAgICAgICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxyXG4gICAgICAgICAgICBvbkJlZm9yZUNyZWF0ZTogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25DcmVhdGU6ICgpID0+IG51bGwsXHJcbiAgICAgICAgICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxyXG4gICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZTogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25Gb2N1czogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25CbHVyOiAoKSA9PiBudWxsLFxyXG4gICAgICAgICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTY2hlbWEoKTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmVDcmVhdGUnLCB0aGlzLm9wdGlvbnMub25CZWZvcmVDcmVhdGUpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5pbmplY3RDU1MoKTtcclxuICAgICAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpO1xyXG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSk7XHJcbiAgICAgICAgdGhpcy5vbignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5vcHRpb25zLm9uU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKTtcclxuICAgICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKTtcclxuICAgICAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5vcHRpb25zLm9uQmx1cik7XHJcbiAgICAgICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpO1xyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmZvY3VzKHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0b3JhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxyXG4gICAgICovXHJcbiAgICBnZXQgY29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxyXG4gICAgICovXHJcbiAgICBjaGFpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXHJcbiAgICAgKi9cclxuICAgIGNhbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0IENTUyBzdHlsZXMuXHJcbiAgICAgKi9cclxuICAgIGluamVjdENTUygpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGVkaXRvciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHNldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIXRoaXMudmlldyB8fCAhdGhpcy5zdGF0ZSB8fCB0aGlzLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICAgICAqL1xyXG4gICAgc2V0RWRpdGFibGUoZWRpdGFibGUsIGVtaXRVcGRhdGUgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSk7XHJcbiAgICAgICAgaWYgKGVtaXRVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGVkaXRvcjogdGhpcywgdHJhbnNhY3Rpb246IHRoaXMuc3RhdGUudHIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7XHJcbiAgICAgICAgLy8gc2luY2UgcGx1Z2lucyBhcmUgYXBwbGllZCBhZnRlciBjcmVhdGluZyB0aGUgdmlld1xyXG4gICAgICAgIC8vIGBlZGl0YWJsZWAgaXMgYWx3YXlzIGB0cnVlYCBmb3Igb25lIHRpY2suXHJcbiAgICAgICAgLy8gdGhhdOKAmXMgd2h5IHdlIGFsc28gaGF2ZSB0byBjaGVjayBmb3IgYG9wdGlvbnMuZWRpdGFibGVgXHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0YWJsZSAmJiB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmVkaXRhYmxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgaGFuZGxlUGx1Z2lucykge1xyXG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBpc0Z1bmN0aW9uKGhhbmRsZVBsdWdpbnMpXHJcbiAgICAgICAgICAgID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKVxyXG4gICAgICAgICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl07XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHsgcGx1Z2lucyB9KTtcclxuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXkgVGhlIHBsdWdpbnMgbmFtZVxyXG4gICAgICovXHJcbiAgICB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IGAke25hbWVPclBsdWdpbktleX0kYCA6IG5hbWVPclBsdWdpbktleS5rZXk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLnN0YXRlLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2luLmtleS5zdGFydHNXaXRoKG5hbWUpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY29yZUV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPyBbXHJcbiAgICAgICAgICAgIEVkaXRhYmxlLFxyXG4gICAgICAgICAgICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplci5jb25maWd1cmUoe1xyXG4gICAgICAgICAgICAgICAgYmxvY2tTZXBhcmF0b3I6IChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jb3JlRXh0ZW5zaW9uT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaXBib2FyZFRleHRTZXJpYWxpemVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmxvY2tTZXBhcmF0b3IsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBDb21tYW5kcyxcclxuICAgICAgICAgICAgRm9jdXNFdmVudHMsXHJcbiAgICAgICAgICAgIEtleW1hcCxcclxuICAgICAgICAgICAgVGFiaW5kZXgsXHJcbiAgICAgICAgXSA6IFtdO1xyXG4gICAgICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnZXh0ZW5zaW9uJywgJ25vZGUnLCAnbWFyayddLmluY2x1ZGVzKGV4dGVuc2lvbiA9PT0gbnVsbCB8fCBleHRlbnNpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbi50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xyXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciBzY2hlbWEuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNjaGVtYSgpIHtcclxuICAgICAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciB2aWV3LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVWaWV3KCkge1xyXG4gICAgICAgIGNvbnN0IGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCB0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRWRpdG9yVmlldyh0aGlzLm9wdGlvbnMuZWxlbWVudCwge1xyXG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXHJcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYGVkaXRvci52aWV3YCBpcyBub3QgeWV0IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWUuXHJcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIHdpbGwgYWRkIGFsbCBwbHVnaW5zIGFuZCBub2RlIHZpZXdzIGRpcmVjdGx5IGFmdGVyd2FyZHMuXHJcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcclxuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vZGVWaWV3cygpO1xyXG4gICAgICAgIHRoaXMucHJlcGVuZENsYXNzKCk7XHJcbiAgICAgICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cclxuICAgICAgICAvLyBTbyB3ZeKAmWxsIGhhdmUgYWNjZXNzIHRvIGl0IGZvciB0ZXN0cy5cclxuICAgICAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tO1xyXG4gICAgICAgIGRvbS5lZGl0b3IgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFsbCBub2RlIHZpZXdzLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVOb2RlVmlld3MoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3LnNldFByb3BzKHtcclxuICAgICAgICAgICAgbm9kZVZpZXdzOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIubm9kZVZpZXdzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJlcGVuZENsYXNzKCkge1xyXG4gICAgICAgIHRoaXMudmlldy5kb20uY2xhc3NOYW1lID0gYHRpcHRhcCAke3RoaXMudmlldy5kb20uY2xhc3NOYW1lfWA7XHJcbiAgICB9XHJcbiAgICBjYXB0dXJlVHJhbnNhY3Rpb24oZm4pIHtcclxuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICAgICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdHI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIC8gdGhlIHZpZXcgb2YgdGhlIGVkaXRvciB3YXMgZGVzdHJveWVkXHJcbiAgICAgICAgLy8gdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBub3QgYmUgZGlzcGF0Y2hlZCBhcyB0aGVyZSBpcyBubyB2aWV3IGFueW1vcmUuXHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0ZXAoc3RlcCk7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pO1xyXG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbicsIHtcclxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3NlbGVjdGlvblVwZGF0ZScsIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpO1xyXG4gICAgICAgIGNvbnN0IGJsdXIgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdibHVyJyk7XHJcbiAgICAgICAgaWYgKGZvY3VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB7XHJcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibHVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYmx1cicsIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudFVwZGF0ZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7XHJcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxyXG4gICAgICovXHJcbiAgICBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlcyh0aGlzLnN0YXRlLCBuYW1lT3JUeXBlKTtcclxuICAgIH1cclxuICAgIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbDtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlcztcclxuICAgICAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cclxuICAgICAqL1xyXG4gICAgZ2V0SlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cclxuICAgICAqL1xyXG4gICAgZ2V0SFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cclxuICAgICAqL1xyXG4gICAgZ2V0VGV4dChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xyXG4gICAgICAgICAgICBibG9ja1NlcGFyYXRvcixcclxuICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHRoaXMuc2NoZW1hKSxcclxuICAgICAgICAgICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTm9kZUVtcHR5KHRoaXMuc3RhdGUuZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhcmFjdGVyQ291bnQoKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIGVkaXRvci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiAhKChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvY1ZpZXcpO1xyXG4gICAgfVxyXG4gICAgJG5vZGUoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLiRkb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSkgfHwgbnVsbDtcclxuICAgIH1cclxuICAgICRub2RlcyhzZWxlY3RvciwgYXR0cmlidXRlcykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuJGRvYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgJHBvcyhwb3MpIHtcclxuICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCAkZG9jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRwb3MoMCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI2lucHV0LXJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKTtcclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xyXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI2lucHV0LXJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlSW5wdXRSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcclxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcclxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICAgIGxldCBtYXRjaFN0YXJ0ID0gc3RhcnQgKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hTdGFydCA+IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGxhc3QgdHlwZWQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dChsYXN0Q2hhciwgc3RhcnQgKyBtYXRjaFswXS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIC8vIGluc2VydCBub2RlIGZyb20gaW5wdXQgcnVsZVxyXG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaFswXSkge1xyXG4gICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHN0YXJ0IC0gMSwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUodHIubWFwcGluZy5tYXAoc3RhcnQpLCB0ci5tYXBwaW5nLm1hcChlbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcclxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxyXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXHJcbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucy8jaW5wdXQtcnVsZXNcclxuICovXHJcbmZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XHJcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXHJcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBjb25maWcudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXRlLnRyXHJcbiAgICAgICAgICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxyXG4gICAgICAgICAgICAgICAgLnNldEJsb2NrVHlwZShyYW5nZS5mcm9tLCByYW5nZS5mcm9tLCBjb25maWcudHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI2lucHV0LXJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb207XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxyXG4gKiBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxyXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXHJcbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxyXG4gKlxyXG4gKiBgdHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGVyZeKAmXMgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcclxuICogd3JhcHBlZCBub2RlLCB0aGUgcnVsZSB3aWxsIHRyeSB0byBqb2luIHRob3NlXHJcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxyXG4gKiBleHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxyXG4gKiByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgYSBqb2luIHNob3VsZCBoYXBwZW4uXHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zLyNpbnB1dC1ydWxlc1xyXG4gKi9cclxuZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XHJcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXHJcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4sIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge307XHJcbiAgICAgICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHIuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcclxuICAgICAgICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrUmFuZ2UgPSAkc3RhcnQuYmxvY2tSYW5nZSgpO1xyXG4gICAgICAgICAgICBjb25zdCB3cmFwcGluZyA9IGJsb2NrUmFuZ2UgJiYgZmluZFdyYXBwaW5nKGJsb2NrUmFuZ2UsIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgaWYgKCF3cmFwcGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZyk7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcua2VlcE1hcmtzICYmIGNvbmZpZy5lZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb25maWcua2VlcEF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIC8qKiBJZiB0aGUgbm9kZVR5cGUgaXMgYGJ1bGxldExpc3RgIG9yIGBvcmRlcmVkTGlzdGAgc2V0IHRoZSBgbm9kZVR5cGVgIGFzIGBsaXN0SXRlbWAgKi9cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0JztcclxuICAgICAgICAgICAgICAgIGNoYWluKCkudXBkYXRlQXR0cmlidXRlcyhub2RlVHlwZSwgYXR0cmlidXRlcykucnVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmU7XHJcbiAgICAgICAgICAgIGlmIChiZWZvcmVcclxuICAgICAgICAgICAgICAgICYmIGJlZm9yZS50eXBlID09PSBjb25maWcudHlwZVxyXG4gICAgICAgICAgICAgICAgJiYgY2FuSm9pbih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKVxyXG4gICAgICAgICAgICAgICAgJiYgKCFjb25maWcuam9pblByZWRpY2F0ZSB8fCBjb25maWcuam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpIHtcclxuICAgICAgICAgICAgICAgIHRyLmpvaW4ocmFuZ2UuZnJvbSAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgTWFyayBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBjdXN0b20gbWFyayBleHRlbnNpb25zLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXHJcbiAqL1xyXG5jbGFzcyBNYXJrIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ21hcmsnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdtYXJrJztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxyXG4gICAgICAgICAgICAuLi5jb25maWcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xyXG4gICAgICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZE9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgICB9KSkgfHwge307XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBjb25maWd1cmUob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXHJcbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcclxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgTWFyayh7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KTtcclxuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcclxuICAgICAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uO1xyXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XHJcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBoYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrIH0pIHtcclxuICAgICAgICBjb25zdCB7IHRyIH0gPSBlZGl0b3Iuc3RhdGU7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XHJcbiAgICAgICAgY29uc3QgaXNBdEVuZCA9IGN1cnJlbnRQb3MucG9zID09PSBjdXJyZW50UG9zLmVuZCgpO1xyXG4gICAgICAgIGlmIChpc0F0RW5kKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IGN1cnJlbnRQb3MubWFya3MoKTtcclxuICAgICAgICAgICAgY29uc3QgaXNJbk1hcmsgPSAhIWN1cnJlbnRNYXJrcy5maW5kKG0gPT4gKG0gPT09IG51bGwgfHwgbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbS50eXBlLm5hbWUpID09PSBtYXJrLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzSW5NYXJrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlTWFyayA9IGN1cnJlbnRNYXJrcy5maW5kKG0gPT4gKG0gPT09IG51bGwgfHwgbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbS50eXBlLm5hbWUpID09PSBtYXJrLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAocmVtb3ZlTWFyaykge1xyXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KCcgJywgY3VycmVudFBvcy5wb3MpO1xyXG4gICAgICAgICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBOb2RlIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBub2RlIGV4dGVuc2lvbnMuXHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cclxuICovXHJcbmNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnbm9kZSc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uczoge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXHJcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxyXG4gICAgICAgIH0pKSB8fCB7fTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5vZGUoY29uZmlnKTtcclxuICAgIH1cclxuICAgIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcclxuICAgICAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cclxuICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKCk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb247XHJcbiAgICB9XHJcbiAgICBleHRlbmQoZXh0ZW5kZWRDb25maWcgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBOb2RlKHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pO1xyXG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XHJcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcclxuICAgICAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcclxuICAgIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdBbmRyb2lkJyB8fCAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbn1cblxuLyoqXHJcbiAqIE5vZGUgdmlld3MgYXJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSByZW5kZXJlZCBET00gc3RydWN0dXJlIG9mIGEgbm9kZS5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvbm9kZS12aWV3c1xyXG4gKi9cclxuY2xhc3MgTm9kZVZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3RvcEV2ZW50OiBudWxsLFxyXG4gICAgICAgICAgICBpZ25vcmVNdXRhdGlvbjogbnVsbCxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gcHJvcHMuZXh0ZW5zaW9uO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHByb3BzLm5vZGU7XHJcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zO1xyXG4gICAgICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zO1xyXG4gICAgICAgIHRoaXMubW91bnQoKTtcclxuICAgIH1cclxuICAgIG1vdW50KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGdldCBkb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRlbnRET00oKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBvbkRyYWdTdGFydChldmVudCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcclxuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICAvLyBnZXQgdGhlIGRyYWcgaGFuZGxlIGVsZW1lbnRcclxuICAgICAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxyXG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQubm9kZVR5cGUgPT09IDNcclxuICAgICAgICAgICAgPyAoX2EgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpO1xyXG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgKChfYiA9IHRoaXMuY29udGVudERPTSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRhaW5zKHRhcmdldCkpIHx8ICFkcmFnSGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcclxuICAgICAgICBpZiAodGhpcy5kb20gIT09IGRyYWdIYW5kbGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIC8vIEluIFJlYWN0LCB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggbmF0aXZlRXZlbnQgdG8gcmVhY2ggb2Zmc2V0WC9vZmZzZXRZLlxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gKF9jID0gZXZlbnQub2Zmc2V0WCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKF9kID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5vZmZzZXRYO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gKF9lID0gZXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5vZmZzZXRZO1xyXG4gICAgICAgICAgICB4ID0gaGFuZGxlQm94LnggLSBkb21Cb3gueCArIG9mZnNldFg7XHJcbiAgICAgICAgICAgIHkgPSBoYW5kbGVCb3gueSAtIGRvbUJveC55ICsgb2Zmc2V0WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9nID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc2V0RHJhZ0ltYWdlKHRoaXMuZG9tLCB4LCB5KTtcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHRlbGwgUHJvc2VNaXJyb3IgdGhhdCB3ZSB3YW50IHRvIG1vdmUgdGhlIHdob2xlIG5vZGVcclxuICAgICAgICAvLyBzbyB3ZSBjcmVhdGUgYSBOb2RlU2VsZWN0aW9uXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHRoaXMuZ2V0UG9zKCkpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcclxuICAgIH1cclxuICAgIHN0b3BFdmVudChldmVudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgISgoX2EgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyh0YXJnZXQpKTtcclxuICAgICAgICAvLyBhbnkgZXZlbnQgZnJvbSBjaGlsZCBub2RlcyBzaG91bGQgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvclxyXG4gICAgICAgIGlmICghaXNJbkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc0RyYWdFdmVudCA9IGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgnZHJhZycpO1xyXG4gICAgICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnO1xyXG4gICAgICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ0JVVFRPTicsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQudGFnTmFtZSkgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlO1xyXG4gICAgICAgIC8vIGFueSBpbnB1dCBldmVudCB3aXRoaW4gbm9kZSB2aWV3cyBzaG91bGQgYmUgaWdub3JlZCBieSBQcm9zZU1pcnJvclxyXG4gICAgICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3I7XHJcbiAgICAgICAgY29uc3QgeyBpc0RyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZTtcclxuICAgICAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2NvcHknO1xyXG4gICAgICAgIGNvbnN0IGlzUGFzdGVFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSc7XHJcbiAgICAgICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnO1xyXG4gICAgICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG4gICAgICAgIC8vIFByb3NlTWlycm9yIHRyaWVzIHRvIGRyYWcgc2VsZWN0YWJsZSBub2Rlc1xyXG4gICAgICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcclxuICAgICAgICAvLyB0aGlzIGZpeCBwcmV2ZW50cyB0aGF0XHJcbiAgICAgICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRHJhZ0V2ZW50ICYmICFpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBzdG9yZSB0aGF0IGRyYWdnaW5nIHN0YXJ0ZWRcclxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKTtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZERyYWdIYW5kbGUgPSBkcmFnSGFuZGxlICYmICh0aGlzLmRvbSA9PT0gZHJhZ0hhbmRsZSB8fCB0aGlzLmRvbS5jb250YWlucyhkcmFnSGFuZGxlKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIGhhbmRsZWQgYnkgcHJvc2VtaXJyb3JcclxuICAgICAgICBpZiAoaXNEcmFnZ2luZ1xyXG4gICAgICAgICAgICB8fCBpc0Ryb3BFdmVudFxyXG4gICAgICAgICAgICB8fCBpc0NvcHlFdmVudFxyXG4gICAgICAgICAgICB8fCBpc1Bhc3RlRXZlbnRcclxuICAgICAgICAgICAgfHwgaXNDdXRFdmVudFxyXG4gICAgICAgICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGEgbGVhZi9hdG9tIG5vZGUgaXMgbGlrZSBhIGJsYWNrIGJveCBmb3IgUHJvc2VNaXJyb3JcclxuICAgICAgICAvLyBhbmQgc2hvdWxkIGJlIGZ1bGx5IGhhbmRsZWQgYnkgdGhlIG5vZGUgdmlld1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmIHx8IHRoaXMubm9kZS5pc0F0b20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcclxuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcclxuICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2Fu4oCZdCBwcmV2ZW50RGlzcGF0Y2ggb24gZW50ZXJcclxuICAgICAgICAvLyB0aGlzIHdpbGwgbGVhZCB0byBhIHJlLXJlbmRlciBvZiB0aGUgbm9kZSB2aWV3IG9uIGVudGVyXHJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjUzNFxyXG4gICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpXHJcbiAgICAgICAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXHJcbiAgICAgICAgICAgICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKVxyXG4gICAgICAgICAgICAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xyXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSxcclxuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgLy8gd2XigJlsbCBjaGVjayBpZiBldmVyeSBjaGFuZ2VkIG5vZGUgaXMgY29udGVudEVkaXRhYmxlXHJcbiAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdOKAmXMgcHJvYmFibHkgbXV0YXRlZCBieSBQcm9zZU1pcnJvclxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3ZSB3aWxsIGFsbG93IG11dGF0aW9uIGNvbnRlbnRET00gd2l0aCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgLy8gc28gd2UgY2FuIGZvciBleGFtcGxlIGFkZGluZyBjbGFzc2VzIHdpdGhpbiBvdXIgbm9kZSB2aWV3XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XHJcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcclxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlbGV0ZU5vZGUoKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZ2V0UG9zKCk7XHJcbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zLyNwYXN0ZS1ydWxlc1xyXG4gKi9cclxuZnVuY3Rpb24gbWFya1Bhc3RlUnVsZShjb25maWcpIHtcclxuICAgIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcclxuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcclxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBwYXN0ZUV2ZW50LCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50bztcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XHJcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XHJcbmZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4KHN0cmluZykge1xyXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcclxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucy8jcGFzdGUtcnVsZXNcclxuICovXHJcbmZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XHJcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXHJcbiAgICAgICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQsIH0pIHtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudCk7XHJcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2guaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGNoYWluKCkuZGVsZXRlUmFuZ2UocmFuZ2UpLmluc2VydENvbnRlbnRBdChyYW5nZS5mcm9tLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY29uZmlnLnR5cGUubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyczogYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zLyNwYXN0ZS1ydWxlc1xyXG4gKi9cclxuZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWcpIHtcclxuICAgIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcclxuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcclxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcclxuICAgICAgICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSByYW5nZS50bztcclxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxuXG5jbGFzcyBUcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIG1hcChwb3NpdGlvbikge1xyXG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbWFwcGVkUG9zaXRpb24gPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzXHJcbiAgICAgICAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxyXG4gICAgICAgICAgICAucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXBSZXN1bHQgPSBzdGVwLmdldE1hcCgpLm1hcFJlc3VsdChuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChtYXBSZXN1bHQuZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XHJcbiAgICAgICAgfSwgcG9zaXRpb24pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcclxuICAgICAgICAgICAgZGVsZXRlZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbW1hbmRNYW5hZ2VyLCBFZGl0b3IsIEV4dGVuc2lvbiwgSW5wdXRSdWxlLCBNYXJrLCBOb2RlLCBOb2RlUG9zLCBOb2RlVmlldywgUGFzdGVSdWxlLCBUcmFja2VyLCBjYWxsT3JSZXR1cm4sIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLCBjcmVhdGVDaGFpbmFibGVTdGF0ZSwgY3JlYXRlRG9jdW1lbnQsIGNyZWF0ZU5vZGVGcm9tQ29udGVudCwgY3JlYXRlU3R5bGVUYWcsIGRlZmF1bHRCbG9ja0F0LCBkZWxldGVQcm9wcywgZWxlbWVudEZyb21TdHJpbmcsIGVzY2FwZUZvclJlZ0V4LCBpbmRleCBhcyBleHRlbnNpb25zLCBmaW5kQ2hpbGRyZW4sIGZpbmRDaGlsZHJlbkluUmFuZ2UsIGZpbmREdXBsaWNhdGVzLCBmaW5kUGFyZW50Tm9kZSwgZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MsIGZyb21TdHJpbmcsIGdlbmVyYXRlSFRNTCwgZ2VuZXJhdGVKU09OLCBnZW5lcmF0ZVRleHQsIGdldEF0dHJpYnV0ZXMsIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucywgZ2V0Q2hhbmdlZFJhbmdlcywgZ2V0RGVidWdKU09OLCBnZXRFeHRlbnNpb25GaWVsZCwgZ2V0SFRNTEZyb21GcmFnbWVudCwgZ2V0TWFya0F0dHJpYnV0ZXMsIGdldE1hcmtSYW5nZSwgZ2V0TWFya1R5cGUsIGdldE1hcmtzQmV0d2VlbiwgZ2V0Tm9kZUF0UG9zaXRpb24sIGdldE5vZGVBdHRyaWJ1dGVzLCBnZXROb2RlVHlwZSwgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLCBnZXRTY2hlbWEsIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLCBnZXRTY2hlbWFUeXBlQnlOYW1lLCBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSwgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLCBnZXRUZXh0LCBnZXRUZXh0QmV0d2VlbiwgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMsIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEsIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZSwgaW5wdXRSdWxlc1BsdWdpbiwgaXNBY3RpdmUsIGlzQXRFbmRPZk5vZGUsIGlzQXRTdGFydE9mTm9kZSwgaXNFbXB0eU9iamVjdCwgaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQsIGlzRnVuY3Rpb24sIGlzTGlzdCwgaXNNYWNPUywgaXNNYXJrQWN0aXZlLCBpc05vZGVBY3RpdmUsIGlzTm9kZUVtcHR5LCBpc05vZGVTZWxlY3Rpb24sIGlzTnVtYmVyLCBpc1BsYWluT2JqZWN0LCBpc1JlZ0V4cCwgaXNTdHJpbmcsIGlzVGV4dFNlbGVjdGlvbiwgaXNpT1MsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcywgbWVyZ2VEZWVwLCBtaW5NYXgsIG5vZGVJbnB1dFJ1bGUsIG5vZGVQYXN0ZVJ1bGUsIG9iamVjdEluY2x1ZGVzLCBwYXN0ZVJ1bGVzUGx1Z2luLCBwb3NUb0RPTVJlY3QsIHJlbW92ZUR1cGxpY2F0ZXMsIHJlc29sdmVGb2N1c1Bvc2l0aW9uLCBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCwgc3BsaXRFeHRlbnNpb25zLCB0ZXh0SW5wdXRSdWxlLCB0ZXh0UGFzdGVSdWxlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiUGx1Z2luIiwiUGx1Z2luS2V5IiwiVGV4dFNlbGVjdGlvbiIsIlNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJFZGl0b3JTdGF0ZSIsIkVkaXRvclZpZXciLCJrZXltYXAiLCJTY2hlbWEiLCJGcmFnbWVudCIsIkRPTVBhcnNlciIsIkRPTVNlcmlhbGl6ZXIiLCJOb2RlIiwiTm9kZSQxIiwiU2xpY2UiLCJsaWZ0VGFyZ2V0IiwiUmVwbGFjZVN0ZXAiLCJSZXBsYWNlQXJvdW5kU3RlcCIsImpvaW5Qb2ludCIsIlRyYW5zZm9ybSIsImNhblNwbGl0IiwiY2FuSm9pbiIsImZpbmRXcmFwcGluZyIsImNyZWF0ZVBhcmFncmFwaE5lYXIiLCJjcmVhdGVQYXJhZ3JhcGhOZWFyJDEiLCJkZWxldGVTZWxlY3Rpb24iLCJkZWxldGVTZWxlY3Rpb24kMSIsImV4aXRDb2RlIiwiZXhpdENvZGUkMSIsImpvaW5VcCIsImpvaW5VcCQxIiwiam9pbkRvd24iLCJqb2luRG93biQxIiwiam9pbkJhY2t3YXJkIiwiam9pbkJhY2t3YXJkJDEiLCJqb2luRm9yd2FyZCIsImpvaW5Gb3J3YXJkJDEiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQkMSIsImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwiam9pblRleHRibG9ja0ZvcndhcmQkMSIsImxpZnQiLCJsaWZ0JDEiLCJsaWZ0RW1wdHlCbG9jayIsImxpZnRFbXB0eUJsb2NrJDEiLCJuZXdsaW5lSW5Db2RlIiwibmV3bGluZUluQ29kZSQxIiwic2VsZWN0Tm9kZUJhY2t3YXJkIiwic2VsZWN0Tm9kZUJhY2t3YXJkJDEiLCJzZWxlY3ROb2RlRm9yd2FyZCIsInNlbGVjdE5vZGVGb3J3YXJkJDEiLCJzZWxlY3RQYXJlbnROb2RlIiwic2VsZWN0UGFyZW50Tm9kZSQxIiwic2VsZWN0VGV4dGJsb2NrRW5kIiwic2VsZWN0VGV4dGJsb2NrRW5kJDEiLCJzZWxlY3RUZXh0YmxvY2tTdGFydCIsInNlbGVjdFRleHRibG9ja1N0YXJ0JDEiLCJzZXRCbG9ja1R5cGUiLCJ3cmFwSW4iLCJ3cmFwSW4kMSIsImxpZnRMaXN0SXRlbSIsImxpZnRMaXN0SXRlbSQxIiwic2lua0xpc3RJdGVtIiwic2lua0xpc3RJdGVtJDEiLCJ3cmFwSW5MaXN0Iiwid3JhcEluTGlzdCQxIiwiY3JlYXRlQ2hhaW5hYmxlU3RhdGUiLCJjb25maWciLCJzdGF0ZSIsInRyYW5zYWN0aW9uIiwic2VsZWN0aW9uIiwiZG9jIiwic3RvcmVkTWFya3MiLCJhcHBseSIsImJpbmQiLCJhcHBseVRyYW5zYWN0aW9uIiwicGx1Z2lucyIsInNjaGVtYSIsInJlY29uZmlndXJlIiwidG9KU09OIiwidHIiLCJDb21tYW5kTWFuYWdlciIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJlZGl0b3IiLCJyYXdDb21tYW5kcyIsImV4dGVuc2lvbk1hbmFnZXIiLCJjb21tYW5kcyIsImN1c3RvbVN0YXRlIiwiaGFzQ3VzdG9tU3RhdGUiLCJ2aWV3IiwiYnVpbGRQcm9wcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsIm5hbWUiLCJjb21tYW5kIiwibWV0aG9kIiwiYXJncyIsImNhbGxiYWNrIiwiZ2V0TWV0YSIsImRpc3BhdGNoIiwiY2hhaW4iLCJjcmVhdGVDaGFpbiIsImNhbiIsImNyZWF0ZUNhbiIsInN0YXJ0VHIiLCJzaG91bGREaXNwYXRjaCIsImNhbGxiYWNrcyIsImhhc1N0YXJ0VHJhbnNhY3Rpb24iLCJydW4iLCJldmVyeSIsImNoYWluZWRDb21tYW5kIiwicHVzaCIsImZvcm1hdHRlZENvbW1hbmRzIiwidW5kZWZpbmVkIiwiRXZlbnRFbWl0dGVyIiwib24iLCJldmVudCIsImZuIiwiZW1pdCIsImZvckVhY2giLCJvZmYiLCJmaWx0ZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJnZXRFeHRlbnNpb25GaWVsZCIsImV4dGVuc2lvbiIsImZpZWxkIiwiY29udGV4dCIsInBhcmVudCIsInZhbHVlIiwic3BsaXRFeHRlbnNpb25zIiwiZXh0ZW5zaW9ucyIsImJhc2VFeHRlbnNpb25zIiwidHlwZSIsIm5vZGVFeHRlbnNpb25zIiwibWFya0V4dGVuc2lvbnMiLCJnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMiLCJleHRlbnNpb25BdHRyaWJ1dGVzIiwibm9kZUFuZE1hcmtFeHRlbnNpb25zIiwiZGVmYXVsdEF0dHJpYnV0ZSIsImRlZmF1bHQiLCJyZW5kZXJlZCIsInJlbmRlckhUTUwiLCJwYXJzZUhUTUwiLCJrZWVwT25TcGxpdCIsImlzUmVxdWlyZWQiLCJvcHRpb25zIiwic3RvcmFnZSIsImFkZEdsb2JhbEF0dHJpYnV0ZXMiLCJnbG9iYWxBdHRyaWJ1dGVzIiwiZ2xvYmFsQXR0cmlidXRlIiwidHlwZXMiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlIiwiYWRkQXR0cmlidXRlcyIsIm1lcmdlZEF0dHIiLCJnZXROb2RlVHlwZSIsIm5hbWVPclR5cGUiLCJub2RlcyIsIkVycm9yIiwibWVyZ2VBdHRyaWJ1dGVzIiwib2JqZWN0cyIsIml0ZW0iLCJyZWR1Y2UiLCJpdGVtcyIsIm1lcmdlZEF0dHJpYnV0ZXMiLCJrZXkiLCJleGlzdHMiLCJ2YWx1ZUNsYXNzZXMiLCJzcGxpdCIsImV4aXN0aW5nQ2xhc3NlcyIsImluc2VydENsYXNzZXMiLCJ2YWx1ZUNsYXNzIiwiaW5jbHVkZXMiLCJqb2luIiwiZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIiwibm9kZU9yTWFyayIsImF0dHJzIiwiaXNGdW5jdGlvbiIsImNhbGxPclJldHVybiIsImlzRW1wdHlPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZnJvbVN0cmluZyIsIm1hdGNoIiwiTnVtYmVyIiwiaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlIiwicGFyc2VSdWxlIiwic3R5bGUiLCJnZXRBdHRycyIsIm5vZGUiLCJvbGRBdHRyaWJ1dGVzIiwibmV3QXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZSIsImNsZWFuVXBTY2hlbWFJdGVtIiwiZGF0YSIsImdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIiwiX2EiLCJhbGxBdHRyaWJ1dGVzIiwidG9wTm9kZSIsImZpbmQiLCJleHRyYU5vZGVGaWVsZHMiLCJmaWVsZHMiLCJlIiwiZXh0ZW5kTm9kZVNjaGVtYSIsImNvbnRlbnQiLCJtYXJrcyIsImdyb3VwIiwiaW5saW5lIiwiYXRvbSIsInNlbGVjdGFibGUiLCJkcmFnZ2FibGUiLCJjb2RlIiwiZGVmaW5pbmciLCJpc29sYXRpbmciLCJleHRlbnNpb25BdHRyaWJ1dGUiLCJwYXJzZURPTSIsInRvRE9NIiwiSFRNTEF0dHJpYnV0ZXMiLCJyZW5kZXJUZXh0IiwidG9UZXh0IiwiZXh0cmFNYXJrRmllbGRzIiwiZXh0ZW5kTWFya1NjaGVtYSIsImluY2x1c2l2ZSIsImV4Y2x1ZGVzIiwic3Bhbm5pbmciLCJtYXJrIiwiZ2V0U2NoZW1hVHlwZUJ5TmFtZSIsImlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkIiwiZW5hYmxlZCIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJlbmFibGVkRXh0ZW5zaW9uIiwiZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMiLCIkZnJvbSIsIm1heE1hdGNoIiwidGV4dEJlZm9yZSIsInNsaWNlRW5kUG9zIiwicGFyZW50T2Zmc2V0Iiwibm9kZXNCZXR3ZWVuIiwiTWF0aCIsIm1heCIsInBvcyIsImluZGV4IiwiX2IiLCJjaHVuayIsInNwZWMiLCJjYWxsIiwidGV4dENvbnRlbnQiLCJzbGljZSIsImlzUmVnRXhwIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJJbnB1dFJ1bGUiLCJoYW5kbGVyIiwiaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIiLCJ0ZXh0IiwiZXhlYyIsImlucHV0UnVsZU1hdGNoIiwicmVzdWx0IiwiaW5wdXQiLCJyZXBsYWNlV2l0aCIsImNvbnNvbGUiLCJ3YXJuIiwicnVuJDEiLCJmcm9tIiwidG8iLCJydWxlcyIsInBsdWdpbiIsImNvbXBvc2luZyIsInJlc29sdmUiLCJub2RlQmVmb3JlIiwibm9kZUFmdGVyIiwibWF0Y2hlZCIsInJ1bGUiLCJyYW5nZSIsInN0ZXBzIiwic2V0TWV0YSIsInRyYW5zZm9ybSIsImlucHV0UnVsZXNQbHVnaW4iLCJpbml0IiwicHJldiIsInN0b3JlZCIsInNpbXVsYXRlZElucHV0TWV0YSIsImlzU2ltdWxhdGVkSW5wdXQiLCJzZXRUaW1lb3V0Iiwic2VsZWN0aW9uU2V0IiwiZG9jQ2hhbmdlZCIsImhhbmRsZVRleHRJbnB1dCIsImhhbmRsZURPTUV2ZW50cyIsImNvbXBvc2l0aW9uZW5kIiwiJGN1cnNvciIsImhhbmRsZUtleURvd24iLCJpc0lucHV0UnVsZXMiLCJpc051bWJlciIsIlBhc3RlUnVsZSIsInBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyIiwibWF0Y2hBbGwiLCJtYXRjaGVzIiwicGFzdGVSdWxlTWF0Y2giLCJwYXN0ZUV2ZW50IiwiZHJvcEV2ZW50IiwiaGFuZGxlcnMiLCJpc1RleHRibG9jayIsInJlc29sdmVkRnJvbSIsInJlc29sdmVkVG8iLCJtaW4iLCJzaXplIiwidGV4dFRvTWF0Y2giLCJ0ZXh0QmV0d2VlbiIsInN0YXJ0IiwiZW5kIiwibWFwcGluZyIsInN1Y2Nlc3MiLCJjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50IiwiQ2xpcGJvYXJkRXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiRGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsInBhc3RlUnVsZXNQbHVnaW4iLCJkcmFnU291cmNlRWxlbWVudCIsImlzUGFzdGVkRnJvbVByb3NlTWlycm9yIiwiaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yIiwiRHJhZ0V2ZW50IiwicHJvY2Vzc0V2ZW50IiwicGFzdGVFdnQiLCJjaGFpbmFibGVTdGF0ZSIsImIiLCJoYW5kbGVEcmFnc3RhcnQiLCJkb20iLCJwYXJlbnRFbGVtZW50IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkcm9wIiwicGFzdGUiLCJfdmlldyIsImh0bWwiLCJnZXREYXRhIiwiYXBwZW5kVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbnMiLCJvbGRTdGF0ZSIsImlzUGFzdGUiLCJpc0Ryb3AiLCJzaW11bGF0ZWRQYXN0ZU1ldGEiLCJpc1NpbXVsYXRlZFBhc3RlIiwiZmluZERpZmZTdGFydCIsImZpbmREaWZmRW5kIiwiZmluZER1cGxpY2F0ZXMiLCJmaWx0ZXJlZCIsImVsIiwiaW5kZXhPZiIsIlNldCIsIkV4dGVuc2lvbk1hbmFnZXIiLCJzcGxpdHRhYmxlTWFya3MiLCJzZXR1cEV4dGVuc2lvbnMiLCJyZXNvbHZlZEV4dGVuc2lvbnMiLCJzb3J0IiwiZmxhdHRlbiIsImR1cGxpY2F0ZWROYW1lcyIsImFkZEV4dGVuc2lvbnMiLCJmbGF0IiwiZGVmYXVsdFByaW9yaXR5IiwiYSIsInByaW9yaXR5QSIsInByaW9yaXR5QiIsImFkZENvbW1hbmRzIiwicmV2ZXJzZSIsImlucHV0UnVsZXMiLCJwYXN0ZVJ1bGVzIiwiYWxsUGx1Z2lucyIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZGVmYXVsdEJpbmRpbmdzIiwiZXhpdGFibGUiLCJBcnJvd1JpZ2h0IiwiTWFyayIsImhhbmRsZUV4aXQiLCJiaW5kaW5ncyIsInNob3J0Y3V0Iiwia2V5TWFwUGx1Z2luIiwiYWRkSW5wdXRSdWxlcyIsImVuYWJsZUlucHV0UnVsZXMiLCJhZGRQYXN0ZVJ1bGVzIiwiZW5hYmxlUGFzdGVSdWxlcyIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsInByb3NlTWlycm9yUGx1Z2lucyIsIm5vZGVWaWV3cyIsImFkZE5vZGVWaWV3Iiwibm9kZXZpZXciLCJnZXRQb3MiLCJkZWNvcmF0aW9ucyIsImV4dGVuc2lvblN0b3JhZ2UiLCJvbkJlZm9yZUNyZWF0ZSIsIm9uQ3JlYXRlIiwib25VcGRhdGUiLCJvblNlbGVjdGlvblVwZGF0ZSIsIm9uVHJhbnNhY3Rpb24iLCJvbkZvY3VzIiwib25CbHVyIiwib25EZXN0cm95IiwiZ2V0VHlwZSIsImlzUGxhaW5PYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIm1lcmdlRGVlcCIsInNvdXJjZSIsIm91dHB1dCIsImFzc2lnbiIsIkV4dGVuc2lvbiIsImNoaWxkIiwiZGVmYXVsdE9wdGlvbnMiLCJhZGRPcHRpb25zIiwiY3JlYXRlIiwiY29uZmlndXJlIiwiZXh0ZW5kIiwiZXh0ZW5kZWRDb25maWciLCJnZXRUZXh0QmV0d2VlbiIsInN0YXJ0Tm9kZSIsImJsb2NrU2VwYXJhdG9yIiwidGV4dFNlcmlhbGl6ZXJzIiwiaXNCbG9jayIsInRleHRTZXJpYWxpemVyIiwiaXNUZXh0IiwiZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSIsIkNsaXBib2FyZFRleHRTZXJpYWxpemVyIiwiY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIiLCJyYW5nZXMiLCIkdG8iLCJibHVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaXNEZXN0cm95ZWQiLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJjbGVhckNvbnRlbnQiLCJlbWl0VXBkYXRlIiwic2V0Q29udGVudCIsImNsZWFyTm9kZXMiLCIkbWFwcGVkRnJvbSIsIiRtYXBwZWRUbyIsIm5vZGVTaXplIiwibm9kZVJhbmdlIiwiYmxvY2tSYW5nZSIsInRhcmdldExpZnREZXB0aCIsImRlZmF1bHRUeXBlIiwiY29udGVudE1hdGNoQXQiLCJzZXROb2RlTWFya3VwIiwiY3V0Iiwib3JpZ2luUmFuZ2UiLCJ0YXJnZXRQb3MiLCJjb250ZW50U2xpY2UiLCJkZWxldGVSYW5nZSIsIm5ld1BvcyIsImluc2VydCIsInNldFNlbGVjdGlvbiIsImRlbGV0ZUN1cnJlbnROb2RlIiwiY3VycmVudE5vZGUiLCIkYW5jaG9yIiwiJHBvcyIsImRlcHRoIiwiYmVmb3JlIiwiYWZ0ZXIiLCJkZWxldGUiLCJzY3JvbGxJbnRvVmlldyIsImRlbGV0ZU5vZGUiLCJ0eXBlT3JOYW1lIiwiZW50ZXIiLCJrZXlib2FyZFNob3J0Y3V0Iiwib2JqZWN0SW5jbHVkZXMiLCJvYmplY3QxIiwib2JqZWN0MiIsInN0cmljdCIsInRlc3QiLCJmaW5kTWFya0luU2V0IiwiaXNNYXJrSW5TZXQiLCJnZXRNYXJrUmFuZ2UiLCJjaGlsZEFmdGVyIiwib2Zmc2V0IiwiY2hpbGRCZWZvcmUiLCJzdGFydEluZGV4Iiwic3RhcnRQb3MiLCJlbmRJbmRleCIsImVuZFBvcyIsImlzSW5TZXQiLCJjaGlsZENvdW50IiwiZ2V0TWFya1R5cGUiLCJleHRlbmRNYXJrUmFuZ2UiLCJuZXdTZWxlY3Rpb24iLCJmaXJzdCIsImkiLCJpc1RleHRTZWxlY3Rpb24iLCJtaW5NYXgiLCJyZXNvbHZlRm9jdXNQb3NpdGlvbiIsInBvc2l0aW9uIiwic2VsZWN0aW9uQXRTdGFydCIsImF0U3RhcnQiLCJzZWxlY3Rpb25BdEVuZCIsImF0RW5kIiwibWluUG9zIiwibWF4UG9zIiwiaXNpT1MiLCJuYXZpZ2F0b3IiLCJwbGF0Zm9ybSIsInVzZXJBZ2VudCIsImRvY3VtZW50IiwiZm9jdXMiLCJkZWxheWVkRm9jdXMiLCJoYXNGb2N1cyIsImlzU2FtZVNlbGVjdGlvbiIsImVxIiwic2V0U3RvcmVkTWFya3MiLCJpbnNlcnRDb250ZW50IiwiaW5zZXJ0Q29udGVudEF0IiwicmVtb3ZlV2hpdGVzcGFjZXMiLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsIm5vZGVWYWx1ZSIsInJlbW92ZUNoaWxkIiwiZWxlbWVudEZyb21TdHJpbmciLCJ3cmFwcGVkVmFsdWUiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwiY3JlYXRlTm9kZUZyb21Db250ZW50IiwicGFyc2VPcHRpb25zIiwiaXNKU09OQ29udGVudCIsImlzVGV4dENvbnRlbnQiLCJpc0FycmF5Q29udGVudCIsImZyb21BcnJheSIsIm5vZGVGcm9tSlNPTiIsImVycm9yIiwicGFyc2VyIiwiZnJvbVNjaGVtYSIsInBhcnNlU2xpY2UiLCJwYXJzZSIsInNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kIiwic3RhcnRMZW4iLCJiaWFzIiwibGFzdCIsInN0ZXAiLCJtYXBzIiwiX2Zyb20iLCJfdG8iLCJfbmV3RnJvbSIsIm5ld1RvIiwibmVhciIsImlzRnJhZ21lbnQiLCJub2RlT3JGcmFnbWVudCIsInN0YXJ0c1dpdGgiLCJ1cGRhdGVTZWxlY3Rpb24iLCJhcHBseUlucHV0UnVsZXMiLCJhcHBseVBhc3RlUnVsZXMiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJpc09ubHlUZXh0Q29udGVudCIsImlzT25seUJsb2NrQ29udGVudCIsImNoZWNrIiwiaXNFbXB0eVRleHRCbG9jayIsIm5ld0NvbnRlbnQiLCJ2IiwiaW5zZXJ0VGV4dCIsImpvaW5JdGVtQmFja3dhcmQiLCJwb2ludCIsImpvaW5JdGVtRm9yd2FyZCIsImlzTWFjT1MiLCJub3JtYWxpemVLZXlOYW1lIiwicGFydHMiLCJhbHQiLCJjdHJsIiwic2hpZnQiLCJtZXRhIiwibW9kIiwiS2V5Ym9hcmRFdmVudCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNhcHR1cmVkVHJhbnNhY3Rpb24iLCJjYXB0dXJlVHJhbnNhY3Rpb24iLCJzb21lUHJvcCIsImYiLCJuZXdTdGVwIiwibWF5YmVTdGVwIiwiaXNOb2RlQWN0aXZlIiwiZW1wdHkiLCJub2RlUmFuZ2VzIiwicmVsYXRpdmVGcm9tIiwicmVsYXRpdmVUbyIsInNlbGVjdGlvblJhbmdlIiwibWF0Y2hlZE5vZGVSYW5nZXMiLCJzdW0iLCJpc0FjdGl2ZSIsImdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIiwiZGVsZXRlUHJvcHMiLCJvYmoiLCJwcm9wT3JQcm9wcyIsIm5ld09iaiIsInByb3AiLCJyZXNldEF0dHJpYnV0ZXMiLCJtYXJrVHlwZSIsInNjaGVtYVR5cGUiLCJhZGRNYXJrIiwic2VsZWN0QWxsIiwic2V0VGV4dFNlbGVjdGlvbiIsImNyZWF0ZURvY3VtZW50IiwiZ2V0TWFya0F0dHJpYnV0ZXMiLCIkaGVhZCIsIm1hcmtJdGVtIiwiY29tYmluZVRyYW5zYWN0aW9uU3RlcHMiLCJvbGREb2MiLCJkZWZhdWx0QmxvY2tBdCIsImVkZ2VDb3VudCIsImVkZ2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiZmluZENoaWxkcmVuIiwicHJlZGljYXRlIiwibm9kZXNXaXRoUG9zIiwiZGVzY2VuZGFudHMiLCJmaW5kQ2hpbGRyZW5JblJhbmdlIiwiZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MiLCJmaW5kUGFyZW50Tm9kZSIsImdldEhUTUxGcm9tRnJhZ21lbnQiLCJmcmFnbWVudCIsImRvY3VtZW50RnJhZ21lbnQiLCJzZXJpYWxpemVGcmFnbWVudCIsInRlbXBvcmFyeURvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJpbm5lckhUTUwiLCJnZXRTY2hlbWEiLCJnZW5lcmF0ZUhUTUwiLCJjb250ZW50Tm9kZSIsImZyb21KU09OIiwiZ2VuZXJhdGVKU09OIiwiZ2V0VGV4dCIsImdlbmVyYXRlVGV4dCIsImdldE5vZGVBdHRyaWJ1dGVzIiwibm9kZUl0ZW0iLCJnZXRBdHRyaWJ1dGVzIiwicmVtb3ZlRHVwbGljYXRlcyIsImFycmF5IiwiYnkiLCJKU09OIiwic3RyaW5naWZ5Iiwic2VlbiIsImhhc093blByb3BlcnR5Iiwic2ltcGxpZnlDaGFuZ2VkUmFuZ2VzIiwiY2hhbmdlcyIsInVuaXF1ZUNoYW5nZXMiLCJjaGFuZ2UiLCJyZXN0IiwiXyIsIm90aGVyQ2hhbmdlIiwib2xkUmFuZ2UiLCJuZXdSYW5nZSIsImdldENoYW5nZWRSYW5nZXMiLCJzdGVwTWFwIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJvbGRTdGFydCIsImludmVydCIsIm9sZEVuZCIsImdldERlYnVnSlNPTiIsInN0YXJ0T2Zmc2V0IiwiaXNUb3BOb2RlIiwidG9wTm9kZVR5cGUiLCJpbmNyZW1lbnQiLCJnZXRNYXJrc0JldHdlZW4iLCJnZXROb2RlQXRQb3NpdGlvbiIsIm1heERlcHRoIiwiY3VycmVudERlcHRoIiwiZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIiwidHlwZU5hbWUiLCJpc01hcmtBY3RpdmUiLCJtYXJrUmFuZ2VzIiwibWF0Y2hlZFJhbmdlIiwibWFya1JhbmdlIiwiZXhjbHVkZWRSYW5nZSIsImlzQXRFbmRPZk5vZGUiLCJwYXJlbnROb2RlIiwiJHBhcmVudFBvcyIsImlzQXRTdGFydE9mTm9kZSIsImlzTGlzdCIsImlzTm9kZUVtcHR5IiwiZGVmYXVsdENvbnRlbnQiLCJjcmVhdGVBbmRGaWxsIiwiaXNOb2RlU2VsZWN0aW9uIiwicG9zVG9ET01SZWN0IiwicmVzb2x2ZWRFbmQiLCJjb29yZHNBdFBvcyIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJjYW5TZXRNYXJrIiwibmV3TWFya1R5cGUiLCJjdXJzb3IiLCJjdXJyZW50TWFya3MiLCJzb21lTm9kZVN1cHBvcnRzTWFyayIsImlubGluZUNvbnRlbnQiLCJhbGxvd3NNYXJrVHlwZSIsIl9wb3MiLCJpc0lubGluZSIsInBhcmVudEFsbG93c01hcmtUeXBlIiwiY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZSIsIm90aGVyTWFyayIsInNldE1hcmsiLCJhZGRTdG9yZWRNYXJrIiwidHJpbW1lZEZyb20iLCJ0cmltbWVkVG8iLCJzb21lSGFzTWFyayIsInNldE5vZGUiLCJjYW5TZXRCbG9jayIsInVwZGF0ZWRTdGF0ZSIsInNldE5vZGVTZWxlY3Rpb24iLCJlbnN1cmVNYXJrcyIsImZpbHRlcmVkTWFya3MiLCJzcGxpdEJsb2NrIiwia2VlcE1hcmtzIiwiZGVmbHQiLCJpbmRleEFmdGVyIiwiJGZpcnN0IiwiY2FuUmVwbGFjZVdpdGgiLCJzcGxpdExpc3RJdGVtIiwic2FtZVBhcmVudCIsImdyYW5kUGFyZW50Iiwid3JhcCIsImRlcHRoQmVmb3JlIiwiZCIsImNvcHkiLCJkZXB0aEFmdGVyIiwibmV3TmV4dFR5cGVBdHRyaWJ1dGVzIiwibmV4dFR5cGUiLCJjb250ZW50TWF0Y2giLCJhcHBlbmQiLCJyZXBsYWNlIiwic2VsIiwibiIsIm5ld1R5cGVBdHRyaWJ1dGVzIiwiam9pbkxpc3RCYWNrd2FyZHMiLCJsaXN0VHlwZSIsImxpc3QiLCJub2RlQXQiLCJjYW5Kb2luQmFja3dhcmRzIiwiam9pbkxpc3RGb3J3YXJkcyIsImNhbkpvaW5Gb3J3YXJkcyIsInRvZ2dsZUxpc3QiLCJsaXN0VHlwZU9yTmFtZSIsIml0ZW1UeXBlT3JOYW1lIiwiaXRlbVR5cGUiLCJwYXJlbnRMaXN0IiwidmFsaWRDb250ZW50IiwiY2FuV3JhcEluTGlzdCIsInRvZ2dsZU1hcmsiLCJleHRlbmRFbXB0eU1hcmtSYW5nZSIsInVuc2V0TWFyayIsInRvZ2dsZU5vZGUiLCJ0b2dnbGVUeXBlT3JOYW1lIiwidG9nZ2xlVHlwZSIsInRvZ2dsZVdyYXAiLCJ1bmRvSW5wdXRSdWxlIiwidW5kb2FibGUiLCJnZXRTdGF0ZSIsInRvVW5kbyIsImoiLCJkb2NzIiwidW5zZXRBbGxNYXJrcyIsInJlbW92ZU1hcmsiLCJyZW1vdmVTdG9yZWRNYXJrIiwidXBkYXRlQXR0cmlidXRlcyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkNvbW1hbmRzIiwiRWRpdGFibGUiLCJlZGl0YWJsZSIsIkZvY3VzRXZlbnRzIiwiaXNGb2N1c2VkIiwiS2V5bWFwIiwiaGFuZGxlQmFja3NwYWNlIiwicGFyZW50SXNJc29sYXRpbmciLCJwYXJlbnRQb3MiLCJpc0F0U3RhcnQiLCJoYW5kbGVEZWxldGUiLCJoYW5kbGVFbnRlciIsImJhc2VLZXltYXAiLCJFbnRlciIsIkJhY2tzcGFjZSIsIkRlbGV0ZSIsInBjS2V5bWFwIiwibWFjS2V5bWFwIiwibmV3U3RhdGUiLCJkb2NDaGFuZ2VzIiwiYWxsRnJvbSIsImFsbEVuZCIsImFsbFdhc1NlbGVjdGVkIiwiaXNFbXB0eSIsIlRhYmluZGV4IiwiaXNFZGl0YWJsZSIsInRhYmluZGV4IiwiTm9kZVBvcyIsImFjdHVhbERlcHRoIiwicmVzb2x2ZWRQb3MiLCJlbGVtZW50IiwiZG9tQXRQb3MiLCJjaGlsZE5vZGVQb3MiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2xvc2VzdCIsInNlbGVjdG9yIiwibm9kZUF0dHJpYnV0ZXMiLCJhdHRyS2V5cyIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZmlyc3RJdGVtT25seSIsImNoaWxkUG9zIiwiZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCIsImNvbmNhdCIsInNldEF0dHJpYnV0ZSIsIm9sZFNlbGVjdGlvbiIsImNyZWF0ZVN0eWxlVGFnIiwibm9uY2UiLCJzdWZmaXgiLCJ0aXB0YXBTdHlsZVRhZyIsInN0eWxlTm9kZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiRWRpdG9yIiwiaW5qZWN0Q1NTIiwiaW5qZWN0Tm9uY2UiLCJhdXRvZm9jdXMiLCJlZGl0b3JQcm9wcyIsImNvcmVFeHRlbnNpb25PcHRpb25zIiwiZW5hYmxlQ29yZUV4dGVuc2lvbnMiLCJpc0NhcHR1cmluZ1RyYW5zYWN0aW9uIiwic2V0T3B0aW9ucyIsImNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIiLCJjcmVhdGVDb21tYW5kTWFuYWdlciIsImNyZWF0ZVNjaGVtYSIsImNyZWF0ZVZpZXciLCJjb21tYW5kTWFuYWdlciIsImNzcyIsInNldFByb3BzIiwidXBkYXRlU3RhdGUiLCJzZXRFZGl0YWJsZSIsInJlZ2lzdGVyUGx1Z2luIiwiaGFuZGxlUGx1Z2lucyIsInVucmVnaXN0ZXJQbHVnaW4iLCJuYW1lT3JQbHVnaW5LZXkiLCJjb3JlRXh0ZW5zaW9ucyIsImFsbEV4dGVuc2lvbnMiLCJkaXNwYXRjaFRyYW5zYWN0aW9uIiwiY3JlYXRlTm9kZVZpZXdzIiwicHJlcGVuZENsYXNzIiwiY2xhc3NOYW1lIiwic2VsZWN0aW9uSGFzQ2hhbmdlZCIsIm5hbWVPckF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzT3JVbmRlZmluZWQiLCJnZXRKU09OIiwiZ2V0SFRNTCIsImdldENoYXJhY3RlckNvdW50IiwiZG9jVmlldyIsIiRub2RlIiwiJGRvYyIsIiRub2RlcyIsIm1hcmtJbnB1dFJ1bGUiLCJjYXB0dXJlR3JvdXAiLCJmdWxsTWF0Y2giLCJzdGFydFNwYWNlcyIsInNlYXJjaCIsInRleHRTdGFydCIsInRleHRFbmQiLCJleGNsdWRlZE1hcmtzIiwiZXhjbHVkZWQiLCJtYXJrRW5kIiwibm9kZUlucHV0UnVsZSIsIm5ld05vZGUiLCJsYXN0SW5kZXhPZiIsIm1hdGNoU3RhcnQiLCJsYXN0Q2hhciIsInRleHRibG9ja1R5cGVJbnB1dFJ1bGUiLCIkc3RhcnQiLCJ0ZXh0SW5wdXRSdWxlIiwiY3V0T2ZmIiwid3JhcHBpbmdJbnB1dFJ1bGUiLCJ3cmFwcGluZyIsImtlZXBBdHRyaWJ1dGVzIiwiam9pblByZWRpY2F0ZSIsImN1cnJlbnRQb3MiLCJpc0F0RW5kIiwiaXNJbk1hcmsiLCJtIiwiaXNBbmRyb2lkIiwiTm9kZVZpZXciLCJjb21wb25lbnQiLCJpc0RyYWdnaW5nIiwic3RvcEV2ZW50IiwiaWdub3JlTXV0YXRpb24iLCJtb3VudCIsImNvbnRlbnRET00iLCJvbkRyYWdTdGFydCIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJkcmFnSGFuZGxlIiwiZG9tQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFuZGxlQm94Iiwib2Zmc2V0WCIsIm5hdGl2ZUV2ZW50Iiwib2Zmc2V0WSIsImRhdGFUcmFuc2ZlciIsInNldERyYWdJbWFnZSIsImlzSW5FbGVtZW50IiwiaXNEcmFnRXZlbnQiLCJpc0Ryb3BFdmVudCIsImlzSW5wdXQiLCJ0YWdOYW1lIiwiaXNDb250ZW50RWRpdGFibGUiLCJpc0RyYWdnYWJsZSIsImlzU2VsZWN0YWJsZSIsImlzQ29weUV2ZW50IiwiaXNQYXN0ZUV2ZW50IiwiaXNDdXRFdmVudCIsImlzQ2xpY2tFdmVudCIsInByZXZlbnREZWZhdWx0IiwiaXNWYWxpZERyYWdIYW5kbGUiLCJvbmNlIiwibXV0YXRpb24iLCJpc0xlYWYiLCJpc0F0b20iLCJjaGFuZ2VkTm9kZXMiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwibWFya1Bhc3RlUnVsZSIsImVzY2FwZUZvclJlZ0V4Iiwic3RyaW5nIiwiaXNTdHJpbmciLCJub2RlUGFzdGVSdWxlIiwidGV4dFBhc3RlUnVsZSIsIlRyYWNrZXIiLCJjdXJyZW50U3RlcCIsImRlbGV0ZWQiLCJtYXBwZWRQb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwibWFwUmVzdWx0IiwiZ2V0TWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ Blockquote),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * Matches a blockquote to a `>` as input.\r\n */ const inputRegex = /^\\s*>\\s$/;\n/**\r\n * This extension allows you to create blockquotes.\r\n * @see https://tiptap.dev/api/nodes/blockquote\r\n */ const Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"blockquote\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"blockquote\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"blockquote\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setBlockquote: ()=>({ commands })=>{\n                    return commands.wrapIn(this.name);\n                },\n            toggleBlockquote: ()=>({ commands })=>{\n                    return commands.toggleWrap(this.name);\n                },\n            unsetBlockquote: ()=>({ commands })=>{\n                    return commands.lift(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-b\": ()=>this.editor.commands.toggleBlockquote()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0U7QUFFeEU7O0NBRUMsR0FDRCxNQUFNRyxhQUFhO0FBQ25COzs7Q0FHQyxHQUNELE1BQU1DLGFBQWFKLDhDQUFJQSxDQUFDSyxNQUFNLENBQUM7SUFDM0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBYTtTQUN2QjtJQUNMO0lBQ0FDLFlBQVcsRUFBRU4sY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFjUCw2REFBZUEsQ0FBQyxJQUFJLENBQUNjLE9BQU8sQ0FBQ1AsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQzFGO0lBQ0FRO1FBQ0ksT0FBTztZQUNIQyxlQUFlLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzlCLE9BQU9BLFNBQVNDLE1BQU0sQ0FBQyxJQUFJLENBQUNiLElBQUk7Z0JBQ3BDO1lBQ0FjLGtCQUFrQixJQUFNLENBQUMsRUFBRUYsUUFBUSxFQUFFO29CQUNqQyxPQUFPQSxTQUFTRyxVQUFVLENBQUMsSUFBSSxDQUFDZixJQUFJO2dCQUN4QztZQUNBZ0IsaUJBQWlCLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQ2hDLE9BQU9BLFNBQVNLLElBQUksQ0FBQyxJQUFJLENBQUNqQixJQUFJO2dCQUNsQztRQUNKO0lBQ0o7SUFDQWtCO1FBQ0ksT0FBTztZQUNILGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxnQkFBZ0I7UUFDOUQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSHhCLCtEQUFpQkEsQ0FBQztnQkFDZHlCLE1BQU14QjtnQkFDTnlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtBQUNKO0FBRXlELENBQ3pELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL2Rpc3QvaW5kZXguanM/ZTFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXHJcbiAqIE1hdGNoZXMgYSBibG9ja3F1b3RlIHRvIGEgYD5gIGFzIGlucHV0LlxyXG4gKi9cclxuY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKj5cXHMkLztcclxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGJsb2NrcXVvdGVzLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvYmxvY2txdW90ZVxyXG4gKi9cclxuY29uc3QgQmxvY2txdW90ZSA9IE5vZGUuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdibG9ja3F1b3RlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY29udGVudDogJ2Jsb2NrKycsXHJcbiAgICBncm91cDogJ2Jsb2NrJyxcclxuICAgIGRlZmluaW5nOiB0cnVlLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgdGFnOiAnYmxvY2txdW90ZScgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnYmxvY2txdW90ZScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlV3JhcCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQmxvY2txdW90ZSwgQmxvY2txdW90ZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwid3JhcHBpbmdJbnB1dFJ1bGUiLCJpbnB1dFJlZ2V4IiwiQmxvY2txdW90ZSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiSFRNTEF0dHJpYnV0ZXMiLCJjb250ZW50IiwiZ3JvdXAiLCJkZWZpbmluZyIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRCbG9ja3F1b3RlIiwiY29tbWFuZHMiLCJ3cmFwSW4iLCJ0b2dnbGVCbG9ja3F1b3RlIiwidG9nZ2xlV3JhcCIsInVuc2V0QmxvY2txdW90ZSIsImxpZnQiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ Bold),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * Matches bold text via `**` as input.\r\n */ const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\n/**\r\n * Matches bold text via `**` while pasting.\r\n */ const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\n/**\r\n * Matches bold text via `__` as input.\r\n */ const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\n/**\r\n * Matches bold text via `__` while pasting.\r\n */ const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\n/**\r\n * This extension allows you to mark text as bold.\r\n * @see https://tiptap.dev/api/marks/bold\r\n */ const Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"bold\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"strong\"\n            },\n            {\n                tag: \"b\",\n                getAttrs: (node)=>node.style.fontWeight !== \"normal\" && null\n            },\n            {\n                style: \"font-weight\",\n                getAttrs: (value)=>/^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"strong\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setBold: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleBold: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetBold: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-b\": ()=>this.editor.commands.toggleBold(),\n            \"Mod-B\": ()=>this.editor.commands.toggleBold()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxpQkFBaUI7QUFDdkI7O0NBRUMsR0FDRCxNQUFNQyxpQkFBaUI7QUFDdkI7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUI7QUFDN0I7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUI7QUFDN0I7OztDQUdDLEdBQ0QsTUFBTUMsT0FBT1IsOENBQUlBLENBQUNTLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1lBQ0E7Z0JBQ0lBLEtBQUs7Z0JBQ0xDLFVBQVVDLENBQUFBLE9BQVFBLEtBQUtDLEtBQUssQ0FBQ0MsVUFBVSxLQUFLLFlBQVk7WUFDNUQ7WUFDQTtnQkFDSUQsT0FBTztnQkFDUEYsVUFBVUksQ0FBQUEsUUFBUyw0QkFBNEJDLElBQUksQ0FBQ0QsVUFBVTtZQUNsRTtTQUNIO0lBQ0w7SUFDQUUsWUFBVyxFQUFFVCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQVVYLDZEQUFlQSxDQUFDLElBQUksQ0FBQ3FCLE9BQU8sQ0FBQ1YsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3RGO0lBQ0FXO1FBQ0ksT0FBTztZQUNIQyxTQUFTLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3hCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNoQixJQUFJO2dCQUNyQztZQUNBaUIsWUFBWSxJQUFNLENBQUMsRUFBRUYsUUFBUSxFQUFFO29CQUMzQixPQUFPQSxTQUFTRyxVQUFVLENBQUMsSUFBSSxDQUFDbEIsSUFBSTtnQkFDeEM7WUFDQW1CLFdBQVcsSUFBTSxDQUFDLEVBQUVKLFFBQVEsRUFBRTtvQkFDMUIsT0FBT0EsU0FBU0ssU0FBUyxDQUFDLElBQUksQ0FBQ3BCLElBQUk7Z0JBQ3ZDO1FBQ0o7SUFDSjtJQUNBcUI7UUFDSSxPQUFPO1lBQ0gsU0FBUyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDUCxRQUFRLENBQUNFLFVBQVU7WUFDOUMsU0FBUyxJQUFNLElBQUksQ0FBQ0ssTUFBTSxDQUFDUCxRQUFRLENBQUNFLFVBQVU7UUFDbEQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSC9CLDJEQUFhQSxDQUFDO2dCQUNWZ0MsTUFBTTlCO2dCQUNOK0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7WUFDQWpDLDJEQUFhQSxDQUFDO2dCQUNWZ0MsTUFBTTVCO2dCQUNONkIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FDO1FBQ0ksT0FBTztZQUNIakMsMkRBQWFBLENBQUM7Z0JBQ1YrQixNQUFNN0I7Z0JBQ044QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtZQUNBaEMsMkRBQWFBLENBQUM7Z0JBQ1YrQixNQUFNM0I7Z0JBQ040QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUU2RyxDQUM3RyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzP2RmNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXHJcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIGFzIGlucHV0LlxyXG4gKi9cclxuY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkkLztcclxuLyoqXHJcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIHdoaWxlIHBhc3RpbmcuXHJcbiAqL1xyXG5jb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqXFwqKD8hXFxzK1xcKlxcKikoKD86W14qXSspKVxcKlxcKig/IVxccytcXCpcXCopKS9nO1xyXG4vKipcclxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGBfX2AgYXMgaW5wdXQuXHJcbiAqL1xyXG5jb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC87XHJcbi8qKlxyXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYF9fYCB3aGlsZSBwYXN0aW5nLlxyXG4gKi9cclxuY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKS9nO1xyXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBtYXJrIHRleHQgYXMgYm9sZC5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL21hcmtzL2JvbGRcclxuICovXHJcbmNvbnN0IEJvbGQgPSBNYXJrLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnYm9sZCcsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdzdHJvbmcnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdiJyxcclxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBub2RlID0+IG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodCcsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogdmFsdWUgPT4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICByZXR1cm4gWydzdHJvbmcnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxyXG4gICAgICAgICAgICAnTW9kLUInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQm9sZCwgQm9sZCBhcyBkZWZhdWx0LCBzdGFySW5wdXRSZWdleCwgc3RhclBhc3RlUmVnZXgsIHVuZGVyc2NvcmVJbnB1dFJlZ2V4LCB1bmRlcnNjb3JlUGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTWFyayIsIm1lcmdlQXR0cmlidXRlcyIsIm1hcmtJbnB1dFJ1bGUiLCJtYXJrUGFzdGVSdWxlIiwic3RhcklucHV0UmVnZXgiLCJzdGFyUGFzdGVSZWdleCIsInVuZGVyc2NvcmVJbnB1dFJlZ2V4IiwidW5kZXJzY29yZVBhc3RlUmVnZXgiLCJCb2xkIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsImdldEF0dHJzIiwibm9kZSIsInN0eWxlIiwiZm9udFdlaWdodCIsInZhbHVlIiwidGVzdCIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRCb2xkIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlQm9sZCIsInRvZ2dsZU1hcmsiLCJ1bnNldEJvbGQiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImFkZFBhc3RlUnVsZXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bubble-menu/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   BubbleMenuPlugin: () => (/* binding */ BubbleMenuPlugin),\n/* harmony export */   BubbleMenuView: () => (/* binding */ BubbleMenuView),\n/* harmony export */   \"default\": () => (/* binding */ BubbleMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }){\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to })=>{\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isTextSelection)(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = ()=>{\n            this.preventHide = true;\n        };\n        this.dragstartHandler = ()=>{\n            this.hide();\n        };\n        this.focusHandler = ()=>{\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(()=>this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event })=>{\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event)=>{\n            this.blurHandler({\n                event\n            });\n        };\n        this.handleDebouncedUpdate = (view, oldState)=>{\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(()=>{\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState)=>{\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range)=>range.$from.pos));\n            const to = Math.max(...ranges.map((range)=>range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                view,\n                state,\n                oldState,\n                from,\n                to\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (()=>{\n                    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {\n                        let node = view.nodeDOM(from);\n                        const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector(\"[data-node-view-wrapper]\");\n                        if (nodeViewWrapper) {\n                            node = nodeViewWrapper.firstChild;\n                        }\n                        if (node) {\n                            return node.getBoundingClientRect();\n                        }\n                    }\n                    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);\n                })\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.view.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n        this.editor.on(\"focus\", this.focusHandler);\n        this.editor.on(\"blur\", this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = \"visible\";\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"top\",\n            hideOnClick: \"toggle\",\n            ...this.tippyOptions\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener(\"blur\", this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener(\"blur\", this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.view.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n        this.editor.off(\"focus\", this.focusHandler);\n        this.editor.off(\"blur\", this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options)=>{\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === \"string\" ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: (view)=>new BubbleMenuView({\n                view,\n                ...options\n            })\n    });\n};\n/**\r\n * This extension allows you to create a bubble menu.\r\n * @see https://tiptap.dev/api/extensions/bubble-menu\r\n */ const BubbleMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"bubbleMenu\",\n    addOptions () {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: \"bubbleMenu\",\n            updateDelay: undefined,\n            shouldShow: null\n        };\n    },\n    addProseMirrorPlugins () {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlGO0FBQ3BDO0FBQ3hCO0FBRTdCLE1BQU1PO0lBQ0ZDLFlBQVksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsZUFBZSxDQUFDLENBQUMsRUFBRUMsY0FBYyxHQUFHLEVBQUVDLFVBQVUsRUFBRyxDQUFFO1FBQ3RGLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0QsVUFBVSxHQUFHLENBQUMsRUFBRUgsSUFBSSxFQUFFSyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFHO1lBQ3pDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxTQUFTLEVBQUUsR0FBR0o7WUFDM0IsTUFBTSxFQUFFSyxLQUFLLEVBQUUsR0FBR0Q7WUFDbEIsNENBQTRDO1lBQzVDLDJEQUEyRDtZQUMzRCwyQ0FBMkM7WUFDM0MsTUFBTUUsbUJBQW1CLENBQUNILElBQUlJLFdBQVcsQ0FBQ04sTUFBTUMsSUFBSU0sTUFBTSxJQUFJeEIsNkRBQWVBLENBQUNnQixNQUFNSSxTQUFTO1lBQzdGLDRFQUE0RTtZQUM1RSx5RUFBeUU7WUFDekUsb0VBQW9FO1lBQ3BFLE1BQU1LLGdCQUFnQixJQUFJLENBQUNmLE9BQU8sQ0FBQ2dCLFFBQVEsQ0FBQ0MsU0FBU0MsYUFBYTtZQUNsRSxNQUFNQyxpQkFBaUJsQixLQUFLbUIsUUFBUSxNQUFNTDtZQUMxQyxJQUFJLENBQUNJLGtCQUFrQlIsU0FBU0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDYixNQUFNLENBQUNzQixVQUFVLEVBQUU7Z0JBQ3pFLE9BQU87WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7WUFDcEIsSUFBSSxDQUFDakIsV0FBVyxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDa0IsZ0JBQWdCLEdBQUc7WUFD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Q0FBQ0EsTUFBTTtnQkFDbkJDLFNBQVMsSUFBSSxDQUFDNEUsT0FBTyxDQUFDNUUsT0FBTztnQkFDN0JFLGNBQWMsSUFBSSxDQUFDMEUsT0FBTyxDQUFDMUUsWUFBWTtnQkFDdkNDLGFBQWEsSUFBSSxDQUFDeUUsT0FBTyxDQUFDekUsV0FBVztnQkFDckNDLFlBQVksSUFBSSxDQUFDd0UsT0FBTyxDQUFDeEUsVUFBVTtZQUN2QztTQUNIO0lBQ0w7QUFDSjtBQUUrRSxDQUMvRSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5qcz81ZTQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiwgaXNOb2RlU2VsZWN0aW9uLCBwb3NUb0RPTVJlY3QsIEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJztcblxuY2xhc3MgQnViYmxlTWVudVZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSA9IDI1MCwgc2hvdWxkU2hvdywgfSkge1xyXG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3VsZFNob3cgPSAoeyB2aWV3LCBzdGF0ZSwgZnJvbSwgdG8sIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgLy8gU29tZXRpbWUgY2hlY2sgZm9yIGBlbXB0eWAgaXMgbm90IGVub3VnaC5cclxuICAgICAgICAgICAgLy8gRG91YmxlY2xpY2sgYW4gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgYSBub2RlIHNpemUgb2YgMi5cclxuICAgICAgICAgICAgLy8gU28gd2UgY2hlY2sgYWxzbyBmb3IgYW4gZW1wdHkgdGV4dCBzaXplLlxyXG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gIWRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoICYmIGlzVGV4dFNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcclxuICAgICAgICAgICAgLy8gaXMgY2FsbGVkIGFuZCB0aGUgYnViYmxlIG1lbnUgaXRlbSBpcyBmb2N1c3NlZC4gSW4gdGhpcyBjYXNlIHdlIHNob3VsZFxyXG4gICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgbWVudSBhcyBwYXJ0IG9mIHRoZSBlZGl0b3IgYW5kIGtlZXAgc2hvd2luZyB0aGUgbWVudVxyXG4gICAgICAgICAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51O1xyXG4gICAgICAgICAgICBpZiAoIWhhc0VkaXRvckZvY3VzIHx8IGVtcHR5IHx8IGlzRW1wdHlUZXh0QmxvY2sgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRyYWdzdGFydEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5mb2N1c0hhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHdlIHVzZSBgc2V0VGltZW91dGAgdG8gbWFrZSBzdXJlIGBzZWxlY3Rpb25gIGlzIGFscmVhZHkgdXBkYXRlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmx1ckhhbmRsZXIgPSAoeyBldmVudCB9KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmVudEhpZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiAoKF9hID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudGlwcHlCbHVySGFuZGxlciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJIYW5kbGVyKHsgZXZlbnQgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSA9ICh2aWV3LCBvbGRTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKTtcclxuICAgICAgICAgICAgfSwgdGhpcy51cGRhdGVEZWxheSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSAodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIGNvbXBvc2luZyB9ID0gdmlldztcclxuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgQ2VsbFNlbGVjdGlvbnNcclxuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNob3cgPSAoX2EgPSB0aGlzLnNob3VsZFNob3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgICAgICB2aWV3LFxyXG4gICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcclxuICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghc2hvdWxkU2hvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFByb3BzKHtcclxuICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgoX2MgPSB0aGlzLnRpcHB5T3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFJlZmVyZW5jZUNsaWVudFJlY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpZXcubm9kZURPTShmcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3V3JhcHBlciA9IG5vZGUuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPyBub2RlIDogbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctd3JhcHBlcl0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVmlld1dyYXBwZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVZpZXdXcmFwcGVyLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEZWxheSA9IHVwZGF0ZURlbGF5O1xyXG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnM7XHJcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlVG9vbHRpcCgpIHtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aXBweSA9IHRpcHB5KGVkaXRvckVsZW1lbnQsIHtcclxuICAgICAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxyXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxyXG4gICAgICAgICAgICBoaWRlT25DbGljazogJ3RvZ2dsZScsXHJcbiAgICAgICAgICAgIC4uLnRoaXMudGlwcHlPcHRpb25zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIG1heWJlIHdlIGhhdmUgdG8gaGlkZSB0aXBweSBvbiBpdHMgb3duIGJsdXIgZXZlbnQgYXMgd2VsbFxyXG4gICAgICAgIGlmICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcclxuICAgICAgICBjb25zdCBoYXNWYWxpZFNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MgIT09IHN0YXRlLnNlbGVjdGlvbi4kdG8ucG9zO1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZURlbGF5ID4gMCAmJiBoYXNWYWxpZFNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xyXG4gICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgc2hvdygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3BwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2IgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnMpID0+IHtcclxuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcclxuICAgICAgICBrZXk6IHR5cGVvZiBvcHRpb25zLnBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBuZXcgUGx1Z2luS2V5KG9wdGlvbnMucGx1Z2luS2V5KSA6IG9wdGlvbnMucGx1Z2luS2V5LFxyXG4gICAgICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcclxuICAgIH0pO1xyXG59O1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBidWJibGUgbWVudS5cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvYnViYmxlLW1lbnVcclxuICovXHJcbmNvbnN0IEJ1YmJsZU1lbnUgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdidWJibGVNZW51JyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcclxuICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB7fSxcclxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnYnViYmxlTWVudScsXHJcbiAgICAgICAgICAgIHVwZGF0ZURlbGF5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHNob3VsZFNob3c6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIEJ1YmJsZU1lbnVQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luS2V5OiB0aGlzLm9wdGlvbnMucGx1Z2luS2V5LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB0aGlzLm9wdGlvbnMudGlwcHlPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlRGVsYXk6IHRoaXMub3B0aW9ucy51cGRhdGVEZWxheSxcclxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEJ1YmJsZU1lbnUsIEJ1YmJsZU1lbnVQbHVnaW4sIEJ1YmJsZU1lbnVWaWV3LCBCdWJibGVNZW51IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzVGV4dFNlbGVjdGlvbiIsImlzTm9kZVNlbGVjdGlvbiIsInBvc1RvRE9NUmVjdCIsIkV4dGVuc2lvbiIsIlBsdWdpbiIsIlBsdWdpbktleSIsInRpcHB5IiwiQnViYmxlTWVudVZpZXciLCJjb25zdHJ1Y3RvciIsImVkaXRvciIsImVsZW1lbnQiLCJ2aWV3IiwidGlwcHlPcHRpb25zIiwidXBkYXRlRGVsYXkiLCJzaG91bGRTaG93IiwicHJldmVudEhpZGUiLCJzdGF0ZSIsImZyb20iLCJ0byIsImRvYyIsInNlbGVjdGlvbiIsImVtcHR5IiwiaXNFbXB0eVRleHRCbG9jayIsInRleHRCZXR3ZWVuIiwibGVuZ3RoIiwiaXNDaGlsZE9mTWVudSIsImNvbnRhaW5zIiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiaGFzRWRpdG9yRm9jdXMiLCJoYXNGb2N1cyIsImlzRWRpdGFibGUiLCJtb3VzZWRvd25IYW5kbGVyIiwiZHJhZ3N0YXJ0SGFuZGxlciIsImhpZGUiLCJmb2N1c0hhbmRsZXIiLCJzZXRUaW1lb3V0IiwidXBkYXRlIiwiYmx1ckhhbmRsZXIiLCJldmVudCIsIl9hIiwicmVsYXRlZFRhcmdldCIsInBhcmVudE5vZGUiLCJ0aXBweUJsdXJIYW5kbGVyIiwiaGFuZGxlRGVib3VuY2VkVXBkYXRlIiwib2xkU3RhdGUiLCJzZWxlY3Rpb25DaGFuZ2VkIiwiZXEiLCJkb2NDaGFuZ2VkIiwidXBkYXRlRGVib3VuY2VUaW1lciIsImNsZWFyVGltZW91dCIsIndpbmRvdyIsInVwZGF0ZUhhbmRsZXIiLCJfYiIsIl9jIiwiY29tcG9zaW5nIiwiaXNTYW1lIiwiY3JlYXRlVG9vbHRpcCIsInJhbmdlcyIsIk1hdGgiLCJtaW4iLCJtYXAiLCJyYW5nZSIsIiRmcm9tIiwicG9zIiwibWF4IiwiJHRvIiwiY2FsbCIsInNldFByb3BzIiwiZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCIsIm5vZGUiLCJub2RlRE9NIiwibm9kZVZpZXdXcmFwcGVyIiwiZGF0YXNldCIsInF1ZXJ5U2VsZWN0b3IiLCJmaXJzdENoaWxkIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2hvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXB0dXJlIiwiZG9tIiwib24iLCJyZW1vdmUiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJlZGl0b3JFbGVtZW50Iiwib3B0aW9ucyIsImVkaXRvcklzQXR0YWNoZWQiLCJwYXJlbnRFbGVtZW50IiwiZHVyYXRpb24iLCJjb250ZW50IiwiaW50ZXJhY3RpdmUiLCJ0cmlnZ2VyIiwicGxhY2VtZW50IiwiaGlkZU9uQ2xpY2siLCJwb3BwZXIiLCJoYXNWYWxpZFNlbGVjdGlvbiIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmIiwiQnViYmxlTWVudVBsdWdpbiIsImtleSIsInBsdWdpbktleSIsIkJ1YmJsZU1lbnUiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsInVuZGVmaW5lZCIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   \"default\": () => (/* binding */ BulletList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create list items.\r\n * @see https://www.tiptap.dev/api/nodes/list-item\r\n */ const ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"listItem\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: \"bulletList\",\n            orderedListTypeName: \"orderedList\"\n        };\n    },\n    content: \"paragraph block*\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"li\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            Tab: ()=>this.editor.commands.sinkListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n    }\n});\n/**\r\n * This extension allows you to create text styles. It is required by default\r\n * for the `textColor` and `backgroundColor` extensions.\r\n * @see https://www.tiptap.dev/api/marks/text-style\r\n */ const TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"textStyle\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"span\",\n                getAttrs: (element)=>{\n                    const hasStyles = element.hasAttribute(\"style\");\n                    if (!hasStyles) {\n                        return false;\n                    }\n                    return {};\n                }\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"span\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            removeEmptyTextStyle: ()=>({ state, commands })=>{\n                    const attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, this.type);\n                    const hasStyles = Object.entries(attributes).some(([, value])=>!!value);\n                    if (hasStyles) {\n                        return true;\n                    }\n                    return commands.unsetMark(this.name);\n                }\n        };\n    }\n});\n/**\r\n * Matches a bullet list to a dash or asterisk.\r\n */ const inputRegex = /^\\s*([-+*])\\s$/;\n/**\r\n * This extension allows you to create bullet lists.\r\n * This requires the ListItem extension\r\n * @see https://tiptap.dev/api/nodes/bullet-list\r\n * @see https://tiptap.dev/api/nodes/list-item.\r\n */ const BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"bulletList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ul\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleBulletList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-8\": ()=>this.editor.commands.toggleBulletList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: ()=>{\n                    return this.editor.getAttributes(TextStyle.name);\n                },\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlHO0FBRWpHOzs7Q0FHQyxHQUNELE1BQU1LLFdBQVdMLDhDQUFJQSxDQUFDTSxNQUFNLENBQUM7SUFDekJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1lBQ2pCQyxvQkFBb0I7WUFDcEJDLHFCQUFxQjtRQUN6QjtJQUNKO0lBQ0FDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTVIsNkRBQWVBLENBQUMsSUFBSSxDQUFDZ0IsT0FBTyxDQUFDUixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDbEY7SUFDQVM7UUFDSSxPQUFPO1lBQ0hDLE9BQU8sSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxhQUFhLENBQUMsSUFBSSxDQUFDZixJQUFJO1lBQ3pEZ0IsS0FBSyxJQUFNLElBQUksQ0FBQ0gsTUFBTSxDQUFDQyxRQUFRLENBQUNHLFlBQVksQ0FBQyxJQUFJLENBQUNqQixJQUFJO1lBQ3RELGFBQWEsSUFBTSxJQUFJLENBQUNhLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDSSxZQUFZLENBQUMsSUFBSSxDQUFDbEIsSUFBSTtRQUNsRTtJQUNKO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTW1CLFlBQVl4Qiw4Q0FBSUEsQ0FBQ0ksTUFBTSxDQUFDO0lBQzFCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FLO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO2dCQUNMWSxVQUFVQyxDQUFBQTtvQkFDTixNQUFNQyxZQUFZRCxRQUFRRSxZQUFZLENBQUM7b0JBQ3ZDLElB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T0FBTyxJQUFJLENBQUMvQixNQUFNLENBQUMrQixhQUFhLENBQUN6QixVQUFVbkIsSUFBSTtnQkFBRztnQkFDekVhLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPO1lBQ0hrQztTQUNIO0lBQ0w7QUFDSjtBQUV5RCxDQUN6RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcz80NzRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgTWFyaywgZ2V0TWFya0F0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGxpc3QgaXRlbXMuXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvbGlzdC1pdGVtXHJcbiAqL1xyXG5jb25zdCBMaXN0SXRlbSA9IE5vZGUuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdsaXN0SXRlbScsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXHJcbiAgICAgICAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6ICdvcmRlcmVkTGlzdCcsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXHJcbiAgICBkZWZpbmluZzogdHJ1ZSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdsaScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxyXG4gICAgICAgICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxyXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdGV4dCBzdHlsZXMuIEl0IGlzIHJlcXVpcmVkIGJ5IGRlZmF1bHRcclxuICogZm9yIHRoZSBgdGV4dENvbG9yYCBhbmQgYGJhY2tncm91bmRDb2xvcmAgZXh0ZW5zaW9ucy5cclxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy90ZXh0LXN0eWxlXHJcbiAqL1xyXG5jb25zdCBUZXh0U3R5bGUgPSBNYXJrLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAndGV4dFN0eWxlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHRoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1N0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuLyoqXHJcbiAqIE1hdGNoZXMgYSBidWxsZXQgbGlzdCB0byBhIGRhc2ggb3IgYXN0ZXJpc2suXHJcbiAqL1xyXG5jb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqKFstKypdKVxccyQvO1xyXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYnVsbGV0IGxpc3RzLlxyXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBMaXN0SXRlbSBleHRlbnNpb25cclxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL25vZGVzL2J1bGxldC1saXN0XHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW0uXHJcbiAqL1xyXG5jb25zdCBCdWxsZXRMaXN0ID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2J1bGxldExpc3QnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAga2VlcE1hcmtzOiBmYWxzZSxcclxuICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ3JvdXA6ICdibG9jayBsaXN0JyxcclxuICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2A7XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgdGFnOiAndWwnIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ3VsJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b2dnbGVCdWxsZXRMaXN0OiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtLm5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpKS5ydW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LTgnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xyXG4gICAgICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcclxuICAgICAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiAoKSA9PiB7IHJldHVybiB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKTsgfSxcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBpbnB1dFJ1bGUsXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBCdWxsZXRMaXN0LCBCdWxsZXRMaXN0IGFzIGRlZmF1bHQsIGlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJNYXJrIiwiZ2V0TWFya0F0dHJpYnV0ZXMiLCJ3cmFwcGluZ0lucHV0UnVsZSIsIkxpc3RJdGVtIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImJ1bGxldExpc3RUeXBlTmFtZSIsIm9yZGVyZWRMaXN0VHlwZU5hbWUiLCJjb250ZW50IiwiZGVmaW5pbmciLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiRW50ZXIiLCJlZGl0b3IiLCJjb21tYW5kcyIsInNwbGl0TGlzdEl0ZW0iLCJUYWIiLCJzaW5rTGlzdEl0ZW0iLCJsaWZ0TGlzdEl0ZW0iLCJUZXh0U3R5bGUiLCJnZXRBdHRycyIsImVsZW1lbnQiLCJoYXNTdHlsZXMiLCJoYXNBdHRyaWJ1dGUiLCJhZGRDb21tYW5kcyIsInJlbW92ZUVtcHR5VGV4dFN0eWxlIiwic3RhdGUiLCJhdHRyaWJ1dGVzIiwidHlwZSIsIk9iamVjdCIsImVudHJpZXMiLCJzb21lIiwidmFsdWUiLCJ1bnNldE1hcmsiLCJpbnB1dFJlZ2V4IiwiQnVsbGV0TGlzdCIsIml0ZW1UeXBlTmFtZSIsImtlZXBNYXJrcyIsImtlZXBBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJ0b2dnbGVCdWxsZXRMaXN0IiwiY2hhaW4iLCJ0b2dnbGVMaXN0IiwidXBkYXRlQXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZXMiLCJydW4iLCJhZGRJbnB1dFJ1bGVzIiwiaW5wdXRSdWxlIiwiZmluZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ CodeBlock),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n/**\r\n * Matches a code block with backticks.\r\n */ const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\n/**\r\n * Matches a code block with tildes.\r\n */ const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\n/**\r\n * This extension allows you to create code blocks.\r\n * @see https://tiptap.dev/api/nodes/code-block\r\n */ const CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"codeBlock\",\n    addOptions () {\n        return {\n            languageClassPrefix: \"language-\",\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            HTMLAttributes: {}\n        };\n    },\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    addAttributes () {\n        return {\n            language: {\n                default: null,\n                parseHTML: (element)=>{\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    const classNames = [\n                        ...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []\n                    ];\n                    const languages = classNames.filter((className)=>className.startsWith(languageClassPrefix)).map((className)=>className.replace(languageClassPrefix, \"\"));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"pre\",\n                preserveWhitespace: \"full\"\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"pre\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                \"code\",\n                {\n                    class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n                },\n                0\n            ]\n        ];\n    },\n    addCommands () {\n        return {\n            setCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-c\": ()=>this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: ()=>{\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // exit node on triple enter\n            Enter: ({ editor })=>{\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor.chain().command(({ tr })=>{\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                }).exitCode().run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor })=>{\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === undefined) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return false;\n                }\n                return editor.commands.exitCode();\n            }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            })\n        ];\n    },\n    addProseMirrorPlugins () {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n                props: {\n                    handlePaste: (view, event)=>{\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        // don’t create a new code block within code blocks\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData(\"text/plain\");\n                        const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr } = view.state;\n                        // create an empty code block´\n                        // if the cursor is at the absolute end of the document, insert the code block before the cursor instead\n                        // of replacing the selection as the replaceSelectionWith function will cause the insertion to\n                        // happen at the previous node\n                        if (view.state.selection.from === view.state.doc.nodeSize - (1 + view.state.selection.$to.depth * 2)) {\n                            tr.insert(view.state.selection.from - 1, this.type.create({\n                                language\n                            }));\n                        } else {\n                            tr.replaceSelectionWith(this.type.create({\n                                language\n                            }));\n                        }\n                        // put cursor inside the newly created code block\n                        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        // add text to code block\n                        // strip carriage return chars from text pasted as code\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n                        tr.insertText(text.replace(/\\r\\n?/g, \"\\n\"));\n                        // store meta information\n                        // this is useful for other plugins that depends on the paste event\n                        // like the paste rule plugin\n                        tr.setMeta(\"paste\", true);\n                        view.dispatch(tr);\n                        return true;\n                    }\n                }\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RTtBQUNUO0FBRXBFOztDQUVDLEdBQ0QsTUFBTU0scUJBQXFCO0FBQzNCOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1DLFlBQVlSLDhDQUFJQSxDQUFDUyxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDO1FBQ0ksT0FBTztZQUNIQyxVQUFVO2dCQUNOQyxTQUFTO2dCQUNUQyxXQUFXQyxDQUFBQTtvQkFDUCxJQUFJQztvQkFDSixNQUFNLEVBQUVkLG1CQUFtQixFQUFFLEdBQUcsSUFBSSxDQUFDZSxPQUFPO29CQUM1QyxNQUFNQyxhQUFhOzJCQUFLLENBQUMsQ0FBQ0YsS0FBS0QsUUFBUUksaUJBQWlCLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxTQUFTLEtBQUssRUFBRTtxQkFBRTtvQkFDcEgsTUFBTUMsWUFBWUgsV0FDYkksTUFBTSxDQUFDQyxDQUFBQSxZQUFhQSxVQUFVQyxVQUFVLENBQUN0QixzQkFDekN1QixHQUFHLENBQUNGLENBQUFBLFlBQWFBLFVBQVVHLE9BQU8sQ0FBQ3hCLHFCQUFxQjtvQkFDN0QsTUFBTVUsV0FBV1MsU0FBUyxDQUFDLEVBQUU7b0JBQzdCLElBQUksQ0FBQ1QsVUFBVTt3QkFDWCxPQUFPO29CQUNYO29CQUNBLE9BQU9BO2dCQUNYO2dCQUNBZSxVQUFVO1lBQ2Q7UUFDSjtJQUNKO0lBQ0FiO1FBQ0ksT0FBTztZQUNIO2dCQUNJYyxLQUFLO2dC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REFBaUQ7d0JBQ2pEb0QsR0FBR2tDLFlBQVksQ0FBQ3ZHLDJEQUFhQSxDQUFDd0csSUFBSSxDQUFDbkMsR0FBR0ssR0FBRyxDQUFDK0IsT0FBTyxDQUFDQyxLQUFLQyxHQUFHLENBQUMsR0FBR3RDLEdBQUdqQixTQUFTLENBQUM4QyxJQUFJLEdBQUc7d0JBQ2xGLHlCQUF5Qjt3QkFDekIsdURBQXVEO3dCQUN2RCx1R0FBdUc7d0JBQ3ZHN0IsR0FBR3VDLFVBQVUsQ0FBQ2pCLEtBQUs1RCxPQUFPLENBQUMsVUFBVTt3QkFDckMseUJBQXlCO3dCQUN6QixtRUFBbUU7d0JBQ25FLDZCQUE2Qjt3QkFDN0JzQyxHQUFHd0MsT0FBTyxDQUFDLFNBQVM7d0JBQ3BCdEIsS0FBS3VCLFFBQVEsQ0FBQ3pDO3dCQUNkLE9BQU87b0JBQ1g7Z0JBQ0o7WUFDSjtTQUNIO0lBQ0w7QUFDSjtBQUVnRixDQUNoRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzP2NiYTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5cbi8qKlxyXG4gKiBNYXRjaGVzIGEgY29kZSBibG9jayB3aXRoIGJhY2t0aWNrcy5cclxuICovXHJcbmNvbnN0IGJhY2t0aWNrSW5wdXRSZWdleCA9IC9eYGBgKFthLXpdKyk/W1xcc1xcbl0kLztcclxuLyoqXHJcbiAqIE1hdGNoZXMgYSBjb2RlIGJsb2NrIHdpdGggdGlsZGVzLlxyXG4gKi9cclxuY29uc3QgdGlsZGVJbnB1dFJlZ2V4ID0gL15+fn4oW2Etel0rKT9bXFxzXFxuXSQvO1xyXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgY29kZSBibG9ja3MuXHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9jb2RlLWJsb2NrXHJcbiAqL1xyXG5jb25zdCBDb2RlQmxvY2sgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnY29kZUJsb2NrJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VDbGFzc1ByZWZpeDogJ2xhbmd1YWdlLScsXHJcbiAgICAgICAgICAgIGV4aXRPblRyaXBsZUVudGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNvbnRlbnQ6ICd0ZXh0KicsXHJcbiAgICBtYXJrczogJycsXHJcbiAgICBncm91cDogJ2Jsb2NrJyxcclxuICAgIGNvZGU6IHRydWUsXHJcbiAgICBkZWZpbmluZzogdHJ1ZSxcclxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gWy4uLigoKF9hID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdCkgfHwgW10pXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSBjbGFzc05hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5zdGFydHNXaXRoKGxhbmd1YWdlQ2xhc3NQcmVmaXgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUucmVwbGFjZShsYW5ndWFnZUNsYXNzUHJlZml4LCAnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gbGFuZ3VhZ2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAncHJlJyxcclxuICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAncHJlJyxcclxuICAgICAgICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnY29kZScsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IG5vZGUuYXR0cnMubGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VDbGFzc1ByZWZpeCArIG5vZGUuYXR0cnMubGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRDb2RlQmxvY2s6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdG9nZ2xlQ29kZUJsb2NrOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1BbHQtYyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGVCbG9jaygpLFxyXG4gICAgICAgICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcclxuICAgICAgICAgICAgQmFja3NwYWNlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAkYW5jaG9yLnBvcyA9PT0gMTtcclxuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lICE9PSB0aGlzLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBdFN0YXJ0IHx8ICEkYW5jaG9yLnBhcmVudC50ZXh0Q29udGVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWFuZHMuY2xlYXJOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBleGl0IG5vZGUgb24gdHJpcGxlIGVudGVyXHJcbiAgICAgICAgICAgIEVudGVyOiAoeyBlZGl0b3IgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhpdE9uVHJpcGxlRW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuXFxuJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXRFbmQgfHwgIWVuZHNXaXRoRG91YmxlTmV3bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3JcclxuICAgICAgICAgICAgICAgICAgICAuY2hhaW4oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyIH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoJGZyb20ucG9zIC0gMiwgJGZyb20ucG9zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmV4aXRDb2RlKClcclxuICAgICAgICAgICAgICAgICAgICAucnVuKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGV4aXQgbm9kZSBvbiBhcnJvdyBkb3duXHJcbiAgICAgICAgICAgIEFycm93RG93bjogKHsgZWRpdG9yIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXRFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlciA9ICRmcm9tLmFmdGVyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVBZnRlciA9IGRvYy5ub2RlQXQoYWZ0ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVBZnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBiYWNrdGlja0lucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXSxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiB0aWxkZUlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXSxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyB0aGlzIHBsdWdpbiBjcmVhdGVzIGEgY29kZSBibG9jayBmb3IgcGFzdGVkIGNvbnRlbnQgZnJvbSBWUyBDb2RlXHJcbiAgICAgICAgICAgIC8vIHdlIGNhbiBhbHNvIGRldGVjdCB0aGUgY29waWVkIGNvZGUgbGFuZ3VhZ2VcclxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XHJcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NvZGVCbG9ja1ZTQ29kZUhhbmRsZXInKSxcclxuICAgICAgICAgICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb27igJl0IGNyZWF0ZSBhIG5ldyBjb2RlIGJsb2NrIHdpdGhpbiBjb2RlIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNBY3RpdmUodGhpcy50eXBlLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2c2NvZGUgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3ZzY29kZS1lZGl0b3ItZGF0YScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2c2NvZGVEYXRhID0gdnNjb2RlID8gSlNPTi5wYXJzZSh2c2NvZGUpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IHZzY29kZURhdGEgPT09IG51bGwgfHwgdnNjb2RlRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdnNjb2RlRGF0YS5tb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gdmlldy5zdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IGNvZGUgYmxvY2vCtFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBhYnNvbHV0ZSBlbmQgb2YgdGhlIGRvY3VtZW50LCBpbnNlcnQgdGhlIGNvZGUgYmxvY2sgYmVmb3JlIHRoZSBjdXJzb3IgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiBhcyB0aGUgcmVwbGFjZVNlbGVjdGlvbldpdGggZnVuY3Rpb24gd2lsbCBjYXVzZSB0aGUgaW5zZXJ0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhcHBlbiBhdCB0aGUgcHJldmlvdXMgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA9PT0gdmlldy5zdGF0ZS5kb2Mubm9kZVNpemUgLSAoMSArICh2aWV3LnN0YXRlLnNlbGVjdGlvbi4kdG8uZGVwdGggKiAyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIC0gMSwgdGhpcy50eXBlLmNyZWF0ZSh7IGxhbmd1YWdlIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRoaXMudHlwZS5jcmVhdGUoeyBsYW5ndWFnZSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHV0IGN1cnNvciBpbnNpZGUgdGhlIG5ld2x5IGNyZWF0ZWQgY29kZSBibG9ja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIHRyLnNlbGVjdGlvbi5mcm9tIC0gMikpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0ZXh0IHRvIGNvZGUgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgY2FycmlhZ2UgcmV0dXJuIGNoYXJzIGZyb20gdGV4dCBwYXN0ZWQgYXMgY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci12aWV3L2NvbW1pdC9hNTBhNmJjY2ViNGNlNTJhYzhmY2M2MTYyNDg4ZDg4NzU2MTNhYWNkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydFRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIG1ldGEgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIG90aGVyIHBsdWdpbnMgdGhhdCBkZXBlbmRzIG9uIHRoZSBwYXN0ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZSBwYXN0ZSBydWxlIHBsdWdpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKCdwYXN0ZScsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQ29kZUJsb2NrLCBiYWNrdGlja0lucHV0UmVnZXgsIENvZGVCbG9jayBhcyBkZWZhdWx0LCB0aWxkZUlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJ0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwiVGV4dFNlbGVjdGlvbiIsImJhY2t0aWNrSW5wdXRSZWdleCIsInRpbGRlSW5wdXRSZWdleCIsIkNvZGVCbG9jayIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwibGFuZ3VhZ2VDbGFzc1ByZWZpeCIsImV4aXRPblRyaXBsZUVudGVyIiwiZXhpdE9uQXJyb3dEb3duIiwiSFRNTEF0dHJpYnV0ZXMiLCJjb250ZW50IiwibWFya3MiLCJncm91cCIsImNvZGUiLCJkZWZpbmluZyIsImFkZEF0dHJpYnV0ZXMiLCJsYW5ndWFnZSIsImRlZmF1bHQiLCJwYXJzZUhUTUwiLCJlbGVtZW50IiwiX2EiLCJvcHRpb25zIiwiY2xhc3NOYW1lcyIsImZpcnN0RWxlbWVudENoaWxkIiwiY2xhc3NMaXN0IiwibGFuZ3VhZ2VzIiwiZmlsdGVyIiwiY2xhc3NOYW1lIiwic3RhcnRzV2l0aCIsIm1hcCIsInJlcGxhY2UiLCJyZW5kZXJlZCIsInRhZyIsInByZXNlcnZlV2hpdGVzcGFjZSIsInJlbmRlckhUTUwiLCJub2RlIiwiY2xhc3MiLCJhdHRycyIsImFkZENvbW1hbmRzIiwic2V0Q29kZUJsb2NrIiwiYXR0cmlidXRlcyIsImNvbW1hbmRzIiwic2V0Tm9kZSIsInRvZ2dsZUNvZGVCbG9jayIsInRvZ2dsZU5vZGUiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsIkJhY2tzcGFjZSIsImVtcHR5IiwiJGFuY2hvciIsInN0YXRlIiwic2VsZWN0aW9uIiwiaXNBdFN0YXJ0IiwicG9zIiwicGFyZW50IiwidHlwZSIsInRleHRDb250ZW50IiwibGVuZ3RoIiwiY2xlYXJOb2RlcyIsIkVudGVyIiwiJGZyb20iLCJpc0F0RW5kIiwicGFyZW50T2Zmc2V0Iiwibm9kZVNpemUiLCJlbmRzV2l0aERvdWJsZU5ld2xpbmUiLCJlbmRzV2l0aCIsImNoYWluIiwiY29tbWFuZCIsInRyIiwiZGVsZXRlIiwiZXhpdENvZGUiLCJydW4iLCJBcnJvd0Rvd24iLCJkb2MiLCJhZnRlciIsInVuZGVmaW5lZCIsIm5vZGVBZnRlciIsIm5vZGVBdCIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiZ2V0QXR0cmlidXRlcyIsIm1hdGNoIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwia2V5IiwicHJvcHMiLCJoYW5kbGVQYXN0ZSIsInZpZXciLCJldmVudCIsImNsaXBib2FyZERhdGEiLCJpc0FjdGl2ZSIsInRleHQiLCJnZXREYXRhIiwidnNjb2RlIiwidnNjb2RlRGF0YSIsIkpTT04iLCJwYXJzZSIsIm1vZGUiLCJmcm9tIiwiJHRvIiwiZGVwdGgiLCJpbnNlcnQiLCJyZXBsYWNlU2VsZWN0aW9uV2l0aCIsInNldFNlbGVjdGlvbiIsIm5lYXIiLCJyZXNvbHZlIiwiTWF0aCIsIm1heCIsImluc2VydFRleHQiLCJzZXRNZXRhIiwiZGlzcGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ Code),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * Matches inline code.\r\n */ const inputRegex = /(?:^|\\s)(`(?!\\s+`)((?:[^`]+))`(?!\\s+`))$/;\n/**\r\n * Matches inline code while pasting.\r\n */ const pasteRegex = /(?:^|\\s)(`(?!\\s+`)((?:[^`]+))`(?!\\s+`))/g;\n/**\r\n * This extension allows you to mark text as inline code.\r\n * @see https://tiptap.dev/api/marks/code\r\n */ const Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"code\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    excludes: \"_\",\n    code: true,\n    exitable: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"code\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"code\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setCode: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleCode: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetCode: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-e\": ()=>this.editor.commands.toggleCode()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1GO0FBRW5GOztDQUVDLEdBQ0QsTUFBTUksYUFBYTtBQUNuQjs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkI7OztDQUdDLEdBQ0QsTUFBTUMsT0FBT04sOENBQUlBLENBQUNPLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFBRUMsS0FBSztZQUFPO1NBQ2pCO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQVFULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1AsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3BGO0lBQ0FRO1FBQ0ksT0FBTztZQUNIQyxTQUFTLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3hCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNiLElBQUk7Z0JBQ3JDO1lBQ0FjLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDM0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2YsSUFBSTtnQkFDeEM7WUFDQWdCLFdBQVcsSUFBTSxDQUFDLEVBQUVKLFFBQVEsRUFBRTtvQkFDMUIsT0FBT0EsU0FBU0ssU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7Z0JBQ3ZDO1FBQ0o7SUFDSjtJQUNBa0I7UUFDSSxPQUFPO1lBQ0gsU0FBUyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDUCxRQUFRLENBQUNFLFVBQVU7UUFDbEQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSDFCLDJEQUFhQSxDQUFDO2dCQUNWMkIsTUFBTXpCO2dCQUNOMEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FDO1FBQ0ksT0FBTztZQUNINUIsMkRBQWFBLENBQUM7Z0JBQ1YwQixNQUFNeEI7Z0JBQ055QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUV5RCxDQUN6RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzPzM2NjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXHJcbiAqIE1hdGNoZXMgaW5saW5lIGNvZGUuXHJcbiAqL1xyXG5jb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShgKD8hXFxzK2ApKCg/OlteYF0rKSlgKD8hXFxzK2ApKSQvO1xyXG4vKipcclxuICogTWF0Y2hlcyBpbmxpbmUgY29kZSB3aGlsZSBwYXN0aW5nLlxyXG4gKi9cclxuY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykoYCg/IVxccytgKSgoPzpbXmBdKykpYCg/IVxccytgKSkvZztcclxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gbWFyayB0ZXh0IGFzIGlubGluZSBjb2RlLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbWFya3MvY29kZVxyXG4gKi9cclxuY29uc3QgQ29kZSA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdjb2RlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZXhjbHVkZXM6ICdfJyxcclxuICAgIGNvZGU6IHRydWUsXHJcbiAgICBleGl0YWJsZTogdHJ1ZSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7IHRhZzogJ2NvZGUnIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ2NvZGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvZ2dsZUNvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZSgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQ29kZSwgQ29kZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4LCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwibWFya0lucHV0UnVsZSIsIm1hcmtQYXN0ZVJ1bGUiLCJpbnB1dFJlZ2V4IiwicGFzdGVSZWdleCIsIkNvZGUiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiZXhjbHVkZXMiLCJjb2RlIiwiZXhpdGFibGUiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0Q29kZSIsImNvbW1hbmRzIiwic2V0TWFyayIsInRvZ2dsZUNvZGUiLCJ0b2dnbGVNYXJrIiwidW5zZXRDb2RlIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsInR5cGUiLCJhZGRQYXN0ZVJ1bGVzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-color/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@tiptap/extension-color/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   \"default\": () => (/* binding */ Color)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_text_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-text-style */ \"(ssr)/./node_modules/@tiptap/extension-text-style/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\r\n * This extension allows you to color your text.\r\n * @see https://tiptap.dev/api/extensions/color\r\n */ const Color = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"color\",\n    addOptions () {\n        return {\n            types: [\n                \"textStyle\"\n            ]\n        };\n    },\n    addGlobalAttributes () {\n        return [\n            {\n                types: this.options.types,\n                attributes: {\n                    color: {\n                        default: null,\n                        parseHTML: (element)=>{\n                            var _a;\n                            return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['\"]+/g, \"\");\n                        },\n                        renderHTML: (attributes)=>{\n                            if (!attributes.color) {\n                                return {};\n                            }\n                            return {\n                                style: `color: ${attributes.color}`\n                            };\n                        }\n                    }\n                }\n            }\n        ];\n    },\n    addCommands () {\n        return {\n            setColor: (color)=>({ chain })=>{\n                    return chain().setMark(\"textStyle\", {\n                        color\n                    }).run();\n                },\n            unsetColor: ()=>({ chain })=>{\n                    return chain().setMark(\"textStyle\", {\n                        color: null\n                    }).removeEmptyTextStyle().run();\n                }\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29sb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNDO0FBQ0c7QUFFekM7OztDQUdDLEdBQ0QsTUFBTUMsUUFBUUQsbURBQVNBLENBQUNFLE1BQU0sQ0FBQztJQUMzQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsT0FBTztnQkFBQzthQUFZO1FBQ3hCO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lELE9BQU8sSUFBSSxDQUFDRSxPQUFPLENBQUNGLEtBQUs7Z0JBQ3pCRyxZQUFZO29CQUNSQyxPQUFPO3dCQUNIQyxTQUFTO3dCQUNUQyxXQUFXQyxDQUFBQTs0QkFBYSxJQUFJQzs0QkFBSSxPQUFPLENBQUNBLEtBQUtELFFBQVFFLEtBQUssQ0FBQ0wsS0FBSyxNQUFNLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0UsT0FBTyxDQUFDLFVBQVU7d0JBQUs7d0JBQ2pJQyxZQUFZUixDQUFBQTs0QkFDUixJQUFJLENBQUNBLFdBQVdDLEtBQUssRUFBRTtnQ0FDbkIsT0FBTyxDQUFDOzRCQUNaOzRCQUNBLE9BQU87Z0NBQ0hLLE9BQU8sQ0FBQyxPQUFPLEVBQUVOLFdBQVdDLEtBQUssQ0FBQyxDQUFDOzRCQUN2Qzt3QkFDSjtvQkFDSjtnQkFDSjtZQUNKO1NBQ0g7SUFDTDtJQUNBUTtRQUNJLE9BQU87WUFDSEMsVUFBVVQsQ0FBQUEsUUFBUyxDQUFDLEVBQUVVLEtBQUssRUFBRTtvQkFDekIsT0FBT0EsUUFDRkMsT0FBTyxDQUFDLGFBQWE7d0JBQUVYO29CQUFNLEdBQzdCWSxHQUFHO2dCQUNaO1lBQ0FDLFlBQVksSUFBTSxDQUFDLEVBQUVILEtBQUssRUFBRTtvQkFDeEIsT0FBT0EsUUFDRkMsT0FBTyxDQUFDLGFBQWE7d0JBQUVYLE9BQU87b0JBQUssR0FDbkNjLG9CQUFvQixHQUNwQkYsR0FBRztnQkFDWjtRQUNKO0lBQ0o7QUFDSjtBQUVtQyxDQUNuQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29sb3IvZGlzdC9pbmRleC5qcz83YjQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZSc7XG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjb2xvciB5b3VyIHRleHQuXHJcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2NvbG9yXHJcbiAqL1xyXG5jb25zdCBDb2xvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2NvbG9yJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZXM6IFsndGV4dFN0eWxlJ10sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzOiB0aGlzLm9wdGlvbnMudHlwZXMsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZWxlbWVudC5zdHlsZS5jb2xvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoL1snXCJdKy9nLCAnJyk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGNvbG9yOiAke2F0dHJpYnV0ZXMuY29sb3J9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRDb2xvcjogY29sb3IgPT4gKHsgY2hhaW4gfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TWFyaygndGV4dFN0eWxlJywgeyBjb2xvciB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5zZXRDb2xvcjogKCkgPT4gKHsgY2hhaW4gfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TWFyaygndGV4dFN0eWxlJywgeyBjb2xvcjogbnVsbCB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVFbXB0eVRleHRTdHlsZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQ29sb3IsIENvbG9yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsIkNvbG9yIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJ0eXBlcyIsImFkZEdsb2JhbEF0dHJpYnV0ZXMiLCJvcHRpb25zIiwiYXR0cmlidXRlcyIsImNvbG9yIiwiZGVmYXVsdCIsInBhcnNlSFRNTCIsImVsZW1lbnQiLCJfYSIsInN0eWxlIiwicmVwbGFjZSIsInJlbmRlckhUTUwiLCJhZGRDb21tYW5kcyIsInNldENvbG9yIiwiY2hhaW4iLCJzZXRNYXJrIiwicnVuIiwidW5zZXRDb2xvciIsInJlbW92ZUVtcHR5VGV4dFN0eWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-color/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ Document)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * The default document node which represents the top level node of the editor.\r\n * @see https://tiptap.dev/api/nodes/document\r\n */ const Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"block+\"\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFFcEM7OztDQUdDLEdBQ0QsTUFBTUMsV0FBV0QsOENBQUlBLENBQUNFLE1BQU0sQ0FBQztJQUN6QkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7QUFDYjtBQUV5QyxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcz9jY2ZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcclxuICogVGhlIGRlZmF1bHQgZG9jdW1lbnQgbm9kZSB3aGljaCByZXByZXNlbnRzIHRoZSB0b3AgbGV2ZWwgbm9kZSBvZiB0aGUgZWRpdG9yLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvZG9jdW1lbnRcclxuICovXHJcbmNvbnN0IERvY3VtZW50ID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2RvYycsXHJcbiAgICB0b3BOb2RlOiB0cnVlLFxyXG4gICAgY29udGVudDogJ2Jsb2NrKycsXHJcbn0pO1xuXG5leHBvcnQgeyBEb2N1bWVudCwgRG9jdW1lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIkRvY3VtZW50IiwiY3JlYXRlIiwibmFtZSIsInRvcE5vZGUiLCJjb250ZW50IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   \"default\": () => (/* binding */ Dropcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\");\n\n\n/**\r\n * This extension allows you to add a drop cursor to your editor.\r\n * A drop cursor is a line that appears when you drag and drop content\r\n * inbetween nodes.\r\n * @see https://tiptap.dev/api/extensions/dropcursor\r\n */ const Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"dropCursor\",\n    addOptions () {\n        return {\n            color: \"currentColor\",\n            width: 1,\n            class: undefined\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(this.options)\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDVTtBQUVuRDs7Ozs7Q0FLQyxHQUNELE1BQU1FLGFBQWFGLG1EQUFTQSxDQUFDRyxNQUFNLENBQUM7SUFDaENDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxPQUFPQztRQUNYO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hULGlFQUFVQSxDQUFDLElBQUksQ0FBQ1UsT0FBTztTQUMxQjtJQUNMO0FBQ0o7QUFFNkMsQ0FDN0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5qcz9mOWMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9kcm9wY3Vyc29yJztcblxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgZHJvcCBjdXJzb3IgdG8geW91ciBlZGl0b3IuXHJcbiAqIEEgZHJvcCBjdXJzb3IgaXMgYSBsaW5lIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBkcmFnIGFuZCBkcm9wIGNvbnRlbnRcclxuICogaW5iZXR3ZWVuIG5vZGVzLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9kcm9wY3Vyc29yXHJcbiAqL1xyXG5jb25zdCBEcm9wY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnZHJvcEN1cnNvcicsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcclxuICAgICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgICAgIGNsYXNzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZHJvcEN1cnNvcih0aGlzLm9wdGlvbnMpLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgRHJvcGN1cnNvciwgRHJvcGN1cnNvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJFeHRlbnNpb24iLCJkcm9wQ3Vyc29yIiwiRHJvcGN1cnNvciIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiY29sb3IiLCJ3aWR0aCIsImNsYXNzIiwidW5kZWZpbmVkIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwib3B0aW9ucyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-floating-menu/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   FloatingMenuPlugin: () => (/* binding */ FloatingMenuPlugin),\n/* harmony export */   FloatingMenuView: () => (/* binding */ FloatingMenuView),\n/* harmony export */   \"default\": () => (/* binding */ FloatingMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\nclass FloatingMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow }){\n        this.preventHide = false;\n        this.shouldShow = ({ view, state })=>{\n            const { selection } = state;\n            const { $anchor, empty } = selection;\n            const isRootDepth = $anchor.depth === 1;\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;\n            if (!view.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = ()=>{\n            this.preventHide = true;\n        };\n        this.focusHandler = ()=>{\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(()=>this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event })=>{\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event)=>{\n            this.blurHandler({\n                event\n            });\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.editor.on(\"focus\", this.focusHandler);\n        this.editor.on(\"blur\", this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = \"visible\";\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"right\",\n            hideOnClick: \"toggle\",\n            ...this.tippyOptions\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener(\"blur\", this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        var _a, _b, _c;\n        const { state } = view;\n        const { doc, selection } = state;\n        const { from, to } = selection;\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n        if (isSame) {\n            return;\n        }\n        this.createTooltip();\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n            editor: this.editor,\n            view,\n            state,\n            oldState\n        });\n        if (!shouldShow) {\n            this.hide();\n            return;\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (()=>(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect)(view, from, to))\n        });\n        this.show();\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener(\"blur\", this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.editor.off(\"focus\", this.focusHandler);\n        this.editor.off(\"blur\", this.blurHandler);\n    }\n}\nconst FloatingMenuPlugin = (options)=>{\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === \"string\" ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: (view)=>new FloatingMenuView({\n                view,\n                ...options\n            })\n    });\n};\n/**\r\n * This extension allows you to create a floating menu.\r\n * @see https://tiptap.dev/api/extensions/floating-menu\r\n */ const FloatingMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension.create({\n    name: \"floatingMenu\",\n    addOptions () {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: \"floatingMenu\",\n            shouldShow: null\n        };\n    },\n    addProseMirrorPlugins () {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            FloatingMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                shouldShow: this.options.shouldShow\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUQ7QUFDRjtBQUN4QjtBQUU3QixNQUFNSztJQUNGQyxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsQ0FBQyxDQUFDLEVBQUVDLFVBQVUsRUFBRyxDQUFFO1FBQ25FLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0QsVUFBVSxHQUFHLENBQUMsRUFBRUYsSUFBSSxFQUFFSSxLQUFLLEVBQUU7WUFDOUIsTUFBTSxFQUFFQyxTQUFTLEVBQUUsR0FBR0Q7WUFDdEIsTUFBTSxFQUFFRSxPQUFPLEVBQUVDLEtBQUssRUFBRSxHQUFHRjtZQUMzQixNQUFNRyxjQUFjRixRQUFRRyxLQUFLLEtBQUs7WUFDdEMsTUFBTUMsbUJBQW1CSixRQUFRSyxNQUFNLENBQUNDLFdBQVcsSUFBSSxDQUFDTixRQUFRSyxNQUFNLENBQUNFLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLElBQUksQ0FBQ1QsUUFBUUssTUFBTSxDQUFDSyxXQUFXO1lBQ3BILElBQUksQ0FBQ2hCLEtBQUtpQixRQUFRLE1BQ1gsQ0FBQ1YsU0FDRCxDQUFDQyxlQUNELENBQUNFLG9CQUNELENBQUMsSUFBSSxDQUFDWixNQUFNLENBQUNvQixVQUFVLEVBQUU7Z0JBQzVCLE9BQU87WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7WUFDcEIsSUFBSSxDQUFDaEIsV0FBVyxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDaUIsWUFBWSxHQUFHO1lBQ2hCLGtFQUFrRTtZQUNsRUMsV0FBVyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ0UsSUFBSTtRQUNqRDtRQUNBLElBQUksQ0FBQ3VCLFdBQVcsR0FBRyxDQUFDLEVBQUVDLEtBQUssRUFBRTtZQUN6QixJQUFJQztZQUNKLElBQUksSUFBSSxDQUFDdEIsV0FBVyxFQUFFO2dCQUNsQixJQUFJLENBQUNBLFdBQVcsR0FBRztnQkFDbkI7WUFDSjtZQUNBLElBQUksQ0FBQ3FCLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNRSxhQUFhLEtBQU0sRUFBQ0QsS0FBSyxJQUFJLENBQUMxQixPQUFPLENBQUM0QixVQUFVLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxRQUFRLENBQUNKLE1BQU1FLGFBQWEsSUFBSTtnQkFDL0s7WUFDSjtZQUNBLElBQUksQ0FBQ0csSUFBSTtRQUNiO1FBQ0EsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxDQUFDTjtZQUNyQixJQUFJLENBQUNELFdBQVcsQ0FBQztnQkFBRUM7WUFBTTtRQUM3QjtRQUNBLElBQUksQ0FBQzFCLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJRSxZQUFZO1lBQ1osSUFBSSxDQUFDQSxVQUFVLEdBQUdBO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDSCxPQUFPLENBQUNnQyxnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ1osZ0JBQWdCLEVBQUU7WUFBRWEsU0FBUztRQUFLO1FBQ2xGLElBQUksQ0FBQ2xDLE1BQU0sQ0FBQ21DLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQ2IsWUFBWTtRQUN6QyxJQUFJLENBQUN0QixNQUFNLENBQUNtQyxFQUFFLENBQUMsUUFBUSxJQUFJLENBQUNWLFdBQVc7UUFDdkMsSUFBSSxDQUFDdEIsWUFBWSxHQUFHQTtRQUNwQixnREFBZ0Q7UUFDaEQsSUFBSSxDQUFDRixPQUFPLENBQUNtQyxNQUFNO1FBQ25CLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ29DLEtBQUssQ0FBQ0MsVUFBVSxHQUFHO0lBQ3BDO0lBQ0FDLGdCQUFnQjtRQUNaLE1BQU0sRUFBRXRDLFNBQVN1QyxhQUFhLEVBQUUsR0FBRyxJQUFJLENBQUN4QyxNQUFNLENBQUN5QyxPQUFPO1FBQ3RELE1BQU1DLG1CQUFtQixDQUFDLENBQUNGLGNBQWNHLGFBQWE7UUFDdEQsSUFBSSxJQUFJLENBQUM5QyxLQUFLLElBQUksQ0FBQzZDLGtCQUFrQjtZQUNqQztRQUNKO1FBQ0EsSUFBSSxDQUFDN0MsS0FBSyxHQUFHQSxvREFBS0EsQ0FBQzJDLGVBQWU7WUFDOUJJLFVBQVU7WUFDVkMsd0JBQXdCO1lBQ3hCQyxTQUFTLElBQUksQ0FBQzdDLE9BQU87WUFDckI4QyxhQUFhO1lBQ2JDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxhQUFhO1lBQ2IsR0FBRyxJQUFJLENBQUMvQyxZQUFZO1FBQ3hCO1FBQ0EsNERBQTREO1FBQzVELElBQUksSUFBSSxDQUFDTixLQUFLLENBQUNzRCxNQUFNLENBQUNDLFVBQVUsRUFBRTtZQUM5QixJQUFJLENBQUN2RCxLQUFLLENBQUNzRCxNQUFNLENBQUNDLFVBQVUsQ0FBQ25CLGdCQUFnQixDQUFDLFFBQVEsSUFBSSxDQUFDRCxnQkFBZ0I7UUFDL0U7SUFDSjtJQUNBUixPQUFPdEIsSUFBSSxFQUFFbUQsUUFBUSxFQUFFO1FBQ25CLElBQUkxQixJQUFJMkIsSUFBSUM7UUFDWixNQUFNLEVBQUVqRCxLQUFLLEVBQUUsR0FBR0o7UUFDbEIsTUFBTSxFQUFFc0QsR0FBRyxFQUFFakQsU0FBUyxFQUFFLEdBQUdEO1FBQzNCLE1BQU0sRUFBRW1ELElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUduRDtRQUNyQixNQUFNb0QsU0FBU04sWUFBWUEsU0FBU0csR0FBRyxDQUFDSSxFQUFFLENBQUNKLFFBQVFILFNBQVM5QyxTQUFTLENBQUNxRCxFQUFFLENBQUNyRDtRQUN6RSxJQUFJb0QsUUFBUTtZQUNSO1FBQ0o7UUFDQSxJQUFJLENBQUNwQixhQUFhO1FBQ2xCLE1BQU1uQyxhQUFhLENBQUN1QixLQUFLLElBQUksQ0FBQ3ZCLFVBQVUsTUFBTSxRQUFRdUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa0MsSUFBSSxDQUFDLElBQUksRUFBRTtZQUN6RjdELFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CRTtZQUNBSTtZQUNBK0M7UUFDSjtRQUNBLElBQUksQ0FBQ2pELFlBQVk7WUFDYixJQUFJLENBQUMyQixJQUFJO1lBQ1Q7UUFDSjtRQUNDdUIsQ0FBQUEsS0FBSyxJQUFJLENBQUN6RCxLQUFLLE1BQU0sUUFBUXlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1EsUUFBUSxDQUFDO1lBQy9EakIsd0JBQXdCLENBQUMsQ0FBQ1UsS0FBSyxJQUFJLENBQUNwRCxZQUFZLE1BQU0sUUFBUW9ELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1Ysc0JBQXNCLEtBQU0sS0FBTXBELDBEQUFZQSxDQUFDUyxNQUFNdUQsTUFBTUMsR0FBRTtRQUMzSjtRQUNBLElBQUksQ0FBQ0ssSUFBSTtJQUNiO0lBQ0FBLE9BQU87UUFDSCxJQUFJcEM7UUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUM5QixLQUFLLE1BQU0sUUFBUThCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR29DLElBQUk7SUFDbEU7SUFDQWhDLE9BQU87UUFDSCxJQUFJSjtRQUNIQSxDQUFBQSxLQUFLLElBQUksQ0FBQzlCLEtBQUssTUFBTSxRQUFROEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxJQUFJO0lBQ2xFO0lBQ0FpQyxVQUFVO1FBQ04sSUFBSXJDLElBQUkyQjtRQUNSLElBQUksQ0FBQzNCLEtBQUssSUFBSSxDQUFDOUIsS0FBSyxNQUFNLFFBQVE4QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3QixNQUFNLENBQUNDLFVBQVUsRUFBRTtZQUM3RSxJQUFJLENBQUN2RCxLQUFLLENBQUNzRCxNQUFNLENBQUNDLFVBQVUsQ0FBQ2EsbUJBQW1CLENBQUMsUUFBUSxJQUFJLENBQUNqQyxnQkFBZ0I7UUFDbEY7UUFDQ3NCLENBQUFBLEtBQUssSUFBSSxDQUFDekQsS0FBSyxNQUFNLFFBQVF5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdVLE9BQU87UUFDakUsSUFBSSxDQUFDL0QsT0FBTyxDQUFDZ0UsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUM1QyxnQkFBZ0IsRUFBRTtZQUFFYSxTQUFTO1FBQUs7UUFDckYsSUFBSSxDQUFDbEMsTUFBTSxDQUFDa0UsR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDNUMsWUFBWTtRQUMxQyxJQUFJLENBQUN0QixNQUFNLENBQUNrRSxHQUFHLENBQUMsUUFBUSxJQUFJLENBQUN6QyxXQUFXO0lBQzVDO0FBQ0o7QUFDQSxNQUFNMEMscUJBQXFCLENBQUMxQjtJQUN4QixPQUFPLElBQUk5QyxvREFBTUEsQ0FBQztRQUNkeUUsS0FBSyxPQUFPM0IsUUFBUTRCLFNBQVMsS0FBSyxXQUFXLElBQUl6RSx1REFBU0EsQ0FBQzZDLFFBQVE0QixTQUFTLElBQUk1QixRQUFRNEIsU0FBUztRQUNqR25FLE1BQU1BLENBQUFBLE9BQVEsSUFBSUosaUJBQWlCO2dCQUFFSTtnQkFBTSxHQUFHdUMsT0FBTztZQUFDO0lBQzFEO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxNQUFNNkIsZUFBZTVFLG1EQUFTQSxDQUFDNkUsTUFBTSxDQUFDO0lBQ2xDQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIeEUsU0FBUztZQUNURSxjQUFjLENBQUM7WUFDZmtFLFdBQVc7WUFDWGpFLFlBQVk7UUFDaEI7SUFDSjtJQUNBc0U7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDakMsT0FBTyxDQUFDeEMsT0FBTyxFQUFFO1lBQ3ZCLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBTztZQUNIa0UsbUJBQW1CO2dCQUNmRSxXQUFXLElBQUksQ0FBQzVCLE9BQU8sQ0FBQzRCLFNBQVM7Z0JBQ2pDckUsUUFBUSxJQUFJLENBQUNBLE1BQU07Z0JBQ25CQyxTQUFTLElBQUksQ0FBQ3dDLE9BQU8sQ0FBQ3hDLE9BQU87Z0JBQzdCRSxjQUFjLElBQUksQ0FBQ3NDLE9BQU8sQ0FBQ3RDLFlBQVk7Z0JBQ3ZDQyxZQUFZLElBQUksQ0FBQ3FDLE9BQU8sQ0FBQ3JDLFVBQVU7WUFDdkM7U0FDSDtJQUNMO0FBQ0o7QUFFdUYsQ0FDdkYsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWZsb2F0aW5nLW1lbnUvZGlzdC9pbmRleC5qcz82NWUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvc1RvRE9NUmVjdCwgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgdGlwcHkgZnJvbSAndGlwcHkuanMnO1xuXG5jbGFzcyBGbG9hdGluZ01lbnVWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHsgZWRpdG9yLCBlbGVtZW50LCB2aWV3LCB0aXBweU9wdGlvbnMgPSB7fSwgc2hvdWxkU2hvdywgfSkge1xyXG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3VsZFNob3cgPSAoeyB2aWV3LCBzdGF0ZSB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgY29uc3QgeyAkYW5jaG9yLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBpc1Jvb3REZXB0aCA9ICRhbmNob3IuZGVwdGggPT09IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayAmJiAhJGFuY2hvci5wYXJlbnQudHlwZS5zcGVjLmNvZGUgJiYgISRhbmNob3IucGFyZW50LnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICBpZiAoIXZpZXcuaGFzRm9jdXMoKVxyXG4gICAgICAgICAgICAgICAgfHwgIWVtcHR5XHJcbiAgICAgICAgICAgICAgICB8fCAhaXNSb290RGVwdGhcclxuICAgICAgICAgICAgICAgIHx8ICFpc0VtcHR5VGV4dEJsb2NrXHJcbiAgICAgICAgICAgICAgICB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25IYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB3ZSB1c2UgYHNldFRpbWVvdXRgIHRvIG1ha2Ugc3VyZSBgc2VsZWN0aW9uYCBpcyBhbHJlYWR5IHVwZGF0ZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLmVkaXRvci52aWV3KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJsdXJIYW5kbGVyID0gKHsgZXZlbnQgfSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgKChfYSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5ibHVySGFuZGxlcih7IGV2ZW50IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLnRpcHB5T3B0aW9ucyA9IHRpcHB5T3B0aW9ucztcclxuICAgICAgICAvLyBEZXRhY2hlcyBtZW51IGNvbnRlbnQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcclxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVUb29sdGlwKCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudDogZWRpdG9yRWxlbWVudCB9ID0gdGhpcy5lZGl0b3Iub3B0aW9ucztcclxuICAgICAgICBjb25zdCBlZGl0b3JJc0F0dGFjaGVkID0gISFlZGl0b3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHRoaXMudGlwcHkgfHwgIWVkaXRvcklzQXR0YWNoZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpcHB5ID0gdGlwcHkoZWRpdG9yRWxlbWVudCwge1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcclxuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcclxuICAgICAgICAgICAgY29udGVudDogdGhpcy5lbGVtZW50LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXHJcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcclxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxyXG4gICAgICAgICAgICAuLi50aGlzLnRpcHB5T3B0aW9ucyxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcclxuICAgICAgICBpZiAodGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XHJcbiAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XHJcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGlzU2FtZSA9IG9sZFN0YXRlICYmIG9sZFN0YXRlLmRvYy5lcShkb2MpICYmIG9sZFN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pO1xyXG4gICAgICAgIGlmIChpc1NhbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKTtcclxuICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gKF9hID0gdGhpcy5zaG91bGRTaG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgIHZpZXcsXHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICBvbGRTdGF0ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXNob3VsZFNob3cpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFByb3BzKHtcclxuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogKChfYyA9IHRoaXMudGlwcHlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCkgfHwgKCgpID0+IHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bykpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgfVxyXG4gICAgc2hvdygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3BwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2IgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEZsb2F0aW5nTWVudVBsdWdpbiA9IChvcHRpb25zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XHJcbiAgICAgICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcclxuICAgICAgICB2aWV3OiB2aWV3ID0+IG5ldyBGbG9hdGluZ01lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcclxuICAgIH0pO1xyXG59O1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBmbG9hdGluZyBtZW51LlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9mbG9hdGluZy1tZW51XHJcbiAqL1xyXG5jb25zdCBGbG9hdGluZ01lbnUgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdmbG9hdGluZ01lbnUnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxyXG4gICAgICAgICAgICB0aXBweU9wdGlvbnM6IHt9LFxyXG4gICAgICAgICAgICBwbHVnaW5LZXk6ICdmbG9hdGluZ01lbnUnLFxyXG4gICAgICAgICAgICBzaG91bGRTaG93OiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBGbG9hdGluZ01lbnVQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luS2V5OiB0aGlzLm9wdGlvbnMucGx1Z2luS2V5LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB0aGlzLm9wdGlvbnMudGlwcHlPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc2hvdWxkU2hvdzogdGhpcy5vcHRpb25zLnNob3VsZFNob3csXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgRmxvYXRpbmdNZW51LCBGbG9hdGluZ01lbnVQbHVnaW4sIEZsb2F0aW5nTWVudVZpZXcsIEZsb2F0aW5nTWVudSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwb3NUb0RPTVJlY3QiLCJFeHRlbnNpb24iLCJQbHVnaW4iLCJQbHVnaW5LZXkiLCJ0aXBweSIsIkZsb2F0aW5nTWVudVZpZXciLCJjb25zdHJ1Y3RvciIsImVkaXRvciIsImVsZW1lbnQiLCJ2aWV3IiwidGlwcHlPcHRpb25zIiwic2hvdWxkU2hvdyIsInByZXZlbnRIaWRlIiwic3RhdGUiLCJzZWxlY3Rpb24iLCIkYW5jaG9yIiwiZW1wdHkiLCJpc1Jvb3REZXB0aCIsImRlcHRoIiwiaXNFbXB0eVRleHRCbG9jayIsInBhcmVudCIsImlzVGV4dGJsb2NrIiwidHlwZSIsInNwZWMiLCJjb2RlIiwidGV4dENvbnRlbnQiLCJoYXNGb2N1cyIsImlzRWRpdGFibGUiLCJtb3VzZWRvd25IYW5kbGVyIiwiZm9jdXNIYW5kbGVyIiwic2V0VGltZW91dCIsInVwZGF0ZSIsImJsdXJIYW5kbGVyIiwiZXZlbnQiLCJfYSIsInJlbGF0ZWRUYXJnZXQiLCJwYXJlbnROb2RlIiwiY29udGFpbnMiLCJoaWRlIiwidGlwcHlCbHVySGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXB0dXJlIiwib24iLCJyZW1vdmUiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJjcmVhdGVUb29sdGlwIiwiZWRpdG9yRWxlbWVudCIsIm9wdGlvbnMiLCJlZGl0b3JJc0F0dGFjaGVkIiwicGFyZW50RWxlbWVudCIsImR1cmF0aW9uIiwiZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCIsImNvbnRlbnQiLCJpbnRlcmFjdGl2ZSIsInRyaWdnZXIiLCJwbGFjZW1lbnQiLCJoaWRlT25DbGljayIsInBvcHBlciIsImZpcnN0Q2hpbGQiLCJvbGRTdGF0ZSIsIl9iIiwiX2MiLCJkb2MiLCJmcm9tIiwidG8iLCJpc1NhbWUiLCJlcSIsImNhbGwiLCJzZXRQcm9wcyIsInNob3ciLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZiIsIkZsb2F0aW5nTWVudVBsdWdpbiIsImtleSIsInBsdWdpbktleSIsIkZsb2F0aW5nTWVudSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   \"default\": () => (/* binding */ Gapcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\");\n\n\n/**\r\n * This extension allows you to add a gap cursor to your editor.\r\n * A gap cursor is a cursor that appears when you click on a place\r\n * where no content is present, for example inbetween nodes.\r\n * @see https://tiptap.dev/api/extensions/gapcursor\r\n */ const Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"gapCursor\",\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)()\n        ];\n    },\n    extendNodeSchema (extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        return {\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) !== null && _a !== void 0 ? _a : null\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwRTtBQUN6QjtBQUVqRDs7Ozs7Q0FLQyxHQUNELE1BQU1JLFlBQVlKLG1EQUFTQSxDQUFDSyxNQUFNLENBQUM7SUFDL0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hKLCtEQUFTQTtTQUNaO0lBQ0w7SUFDQUssa0JBQWlCQyxTQUFTO1FBQ3RCLElBQUlDO1FBQ0osTUFBTUMsVUFBVTtZQUNaTCxNQUFNRyxVQUFVSCxJQUFJO1lBQ3BCTSxTQUFTSCxVQUFVRyxPQUFPO1lBQzFCQyxTQUFTSixVQUFVSSxPQUFPO1FBQzlCO1FBQ0EsT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQ0osS0FBS1QsMERBQVlBLENBQUNDLCtEQUFpQkEsQ0FBQ08sV0FBVyxrQkFBa0JFLFNBQVEsTUFBTyxRQUFRRCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNsSTtJQUNKO0FBQ0o7QUFFMkMsQ0FDM0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvci9kaXN0L2luZGV4LmpzPzBkZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uLCBjYWxsT3JSZXR1cm4sIGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IGdhcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZ2FwY3Vyc29yJztcblxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgZ2FwIGN1cnNvciB0byB5b3VyIGVkaXRvci5cclxuICogQSBnYXAgY3Vyc29yIGlzIGEgY3Vyc29yIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBjbGljayBvbiBhIHBsYWNlXHJcbiAqIHdoZXJlIG5vIGNvbnRlbnQgaXMgcHJlc2VudCwgZm9yIGV4YW1wbGUgaW5iZXR3ZWVuIG5vZGVzLlxyXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9nYXBjdXJzb3JcclxuICovXHJcbmNvbnN0IEdhcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2dhcEN1cnNvcicsXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZ2FwQ3Vyc29yKCksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWxsb3dHYXBDdXJzb3I6IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhbGxvd0dhcEN1cnNvcicsIGNvbnRleHQpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEdhcGN1cnNvciwgR2FwY3Vyc29yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsImNhbGxPclJldHVybiIsImdldEV4dGVuc2lvbkZpZWxkIiwiZ2FwQ3Vyc29yIiwiR2FwY3Vyc29yIiwiY3JlYXRlIiwibmFtZSIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsImV4dGVuZE5vZGVTY2hlbWEiLCJleHRlbnNpb24iLCJfYSIsImNvbnRleHQiLCJvcHRpb25zIiwic3RvcmFnZSIsImFsbG93R2FwQ3Vyc29yIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ HardBreak)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to insert hard breaks.\r\n * @see https://www.tiptap.dev/api/nodes/hard-break\r\n */ const HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"hardBreak\",\n    addOptions () {\n        return {\n            keepMarks: true,\n            HTMLAttributes: {}\n        };\n    },\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    parseHTML () {\n        return [\n            {\n                tag: \"br\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"br\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    renderText () {\n        return \"\\n\";\n    },\n    addCommands () {\n        return {\n            setHardBreak: ()=>({ commands, chain, state, editor })=>{\n                    return commands.first([\n                        ()=>commands.exitCode(),\n                        ()=>commands.command(()=>{\n                                const { selection, storedMarks } = state;\n                                if (selection.$from.parent.type.spec.isolating) {\n                                    return false;\n                                }\n                                const { keepMarks } = this.options;\n                                const { splittableMarks } = editor.extensionManager;\n                                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                                return chain().insertContent({\n                                    type: this.name\n                                }).command(({ tr, dispatch })=>{\n                                    if (dispatch && marks && keepMarks) {\n                                        const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                                        tr.ensureMarks(filteredMarks);\n                                    }\n                                    return true;\n                                }).run();\n                            })\n                    ]);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Enter\": ()=>this.editor.commands.setHardBreak(),\n            \"Shift-Enter\": ()=>this.editor.commands.setHardBreak()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUVyRDs7O0NBR0MsR0FDRCxNQUFNRSxZQUFZRiw4Q0FBSUEsQ0FBQ0csTUFBTSxDQUFDO0lBQzFCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxXQUFXO1lBQ1hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFlBQVk7SUFDWkM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBSztTQUNmO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQU1OLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2EsT0FBTyxDQUFDUCxjQUFjLEVBQUVBO1NBQWdCO0lBQy9FO0lBQ0FRO1FBQ0ksT0FBTztJQUNYO0lBQ0FDO1FBQ0ksT0FBTztZQUNIQyxjQUFjLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUc7b0JBQ3BELE9BQU9ILFNBQVNJLEtBQUssQ0FBQzt3QkFDbEIsSUFBTUosU0FBU0ssUUFBUTt3QkFDdkIsSUFBTUwsU0FBU00sT0FBTyxDQUFDO2dDQUNuQixNQUFNLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFLEdBQUdOO2dDQUNuQyxJQUFJSyxVQUFVRSxLQUFLLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFNBQVMsRUFBRTtvQ0FDNUMsT0FBTztnQ0FDWDtnQ0FDQSxNQUFNLEVBQUV6QixTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNRLE9BQU87Z0NBQ2xDLE1BQU0sRUFBRWtCLGVBQWUsRUFBRSxHQUFHWCxPQUFPWSxnQkFBZ0I7Z0NBQ25ELE1BQU1DLFFBQVFSLGVBQ05ELFVBQVVVLEdBQUcsQ0FBQ0MsWUFBWSxJQUFJWCxVQUFVRSxLQUFLLENBQUNPLEtBQUs7Z0NBQzNELE9BQU9mLFFBQ0ZrQixhQUFhLENBQUM7b0NBQUVSLE1BQU0sSUFBSSxDQUFDekIsSUFBSTtnQ0FBQyxHQUNoQ29CLE9BQU8sQ0FBQyxDQUFDLEVBQUVjLEVBQUUsRUFBRUMsUUFBUSxFQUFFO29DQUMxQixJQUFJQSxZQUFZTCxTQUFTNUIsV0FBVzt3Q0FDaEMsTUFBTWtDLGdCQUFnQk4sTUFDakJPLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUVYsZ0JBQWdCVyxRQUFRLENBQUNELEtBQUtiLElBQUksQ0FBQ3pCLElBQUk7d0NBQzNEa0MsR0FBR00sV0FBVyxDQUFDSjtvQ0FDbkI7b0NBQ0EsT0FBTztnQ0FDWCxHQUNLSyxHQUFHOzRCQUNaO3FCQUNIO2dCQUNMO1FBQ0o7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSCxhQUFhLElBQU0sSUFBSSxDQUFDekIsTUFBTSxDQUFDSCxRQUFRLENBQUNELFlBQVk7WUFDcEQsZUFBZSxJQUFNLElBQUksQ0FBQ0ksTUFBTSxDQUFDSCxRQUFRLENBQUNELFlBQVk7UUFDMUQ7SUFDSjtBQUNKO0FBRTJDLENBQzNDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrL2Rpc3QvaW5kZXguanM/MDE1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBpbnNlcnQgaGFyZCBicmVha3MuXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvaGFyZC1icmVha1xyXG4gKi9cclxuY29uc3QgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2hhcmRCcmVhaycsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtlZXBNYXJrczogdHJ1ZSxcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgaW5saW5lOiB0cnVlLFxyXG4gICAgZ3JvdXA6ICdpbmxpbmUnLFxyXG4gICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgeyB0YWc6ICdicicgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnYnInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldO1xyXG4gICAgfSxcclxuICAgIHJlbmRlclRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXG4nO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluLCBzdGF0ZSwgZWRpdG9yLCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuZmlyc3QoW1xyXG4gICAgICAgICAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmV4aXRDb2RlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtlZXBNYXJrcyB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucnVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcclxuICAgICAgICAgICAgJ1NoaWZ0LUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBIYXJkQnJlYWssIEhhcmRCcmVhayBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiSGFyZEJyZWFrIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJrZWVwTWFya3MiLCJIVE1MQXR0cmlidXRlcyIsImlubGluZSIsImdyb3VwIiwic2VsZWN0YWJsZSIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwicmVuZGVyVGV4dCIsImFkZENvbW1hbmRzIiwic2V0SGFyZEJyZWFrIiwiY29tbWFuZHMiLCJjaGFpbiIsInN0YXRlIiwiZWRpdG9yIiwiZmlyc3QiLCJleGl0Q29kZSIsImNvbW1hbmQiLCJzZWxlY3Rpb24iLCJzdG9yZWRNYXJrcyIsIiRmcm9tIiwicGFyZW50IiwidHlwZSIsInNwZWMiLCJpc29sYXRpbmciLCJzcGxpdHRhYmxlTWFya3MiLCJleHRlbnNpb25NYW5hZ2VyIiwibWFya3MiLCIkdG8iLCJwYXJlbnRPZmZzZXQiLCJpbnNlcnRDb250ZW50IiwidHIiLCJkaXNwYXRjaCIsImZpbHRlcmVkTWFya3MiLCJmaWx0ZXIiLCJtYXJrIiwiaW5jbHVkZXMiLCJlbnN1cmVNYXJrcyIsInJ1biIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ Heading)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create headings.\r\n * @see https://www.tiptap.dev/api/nodes/heading\r\n */ const Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"heading\",\n    addOptions () {\n        return {\n            levels: [\n                1,\n                2,\n                3,\n                4,\n                5,\n                6\n            ],\n            HTMLAttributes: {}\n        };\n    },\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    addAttributes () {\n        return {\n            level: {\n                default: 1,\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return this.options.levels.map((level)=>({\n                tag: `h${level}`,\n                attrs: {\n                    level\n                }\n            }));\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        const hasLevel = this.options.levels.includes(node.attrs.level);\n        const level = hasLevel ? node.attrs.level : this.options.levels[0];\n        return [\n            `h${level}`,\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return this.options.levels.reduce((items, level)=>({\n                ...items,\n                ...{\n                    [`Mod-Alt-${level}`]: ()=>this.editor.commands.toggleHeading({\n                            level\n                        })\n                }\n            }), {});\n    },\n    addInputRules () {\n        return this.options.levels.map((level)=>{\n            return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n                find: new RegExp(`^(#{1,${level}})\\\\s$`),\n                type: this.type,\n                getAttributes: {\n                    level\n                }\n            });\n        });\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RTtBQUU3RTs7O0NBR0MsR0FDRCxNQUFNRyxVQUFVSCw4Q0FBSUEsQ0FBQ0ksTUFBTSxDQUFDO0lBQ3hCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxRQUFRO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7WUFDMUJDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLE9BQU87Z0JBQ0hDLFNBQVM7Z0JBQ1RDLFVBQVU7WUFDZDtRQUNKO0lBQ0o7SUFDQUM7UUFDSSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDVixNQUFNLENBQ3JCVyxHQUFHLENBQUMsQ0FBQ0wsUUFBVztnQkFDakJNLEtBQUssQ0FBQyxDQUFDLEVBQUVOLE1BQU0sQ0FBQztnQkFDaEJPLE9BQU87b0JBQUVQO2dCQUFNO1lBQ25CO0lBQ0o7SUFDQVEsWUFBVyxFQUFFQyxJQUFJLEVBQUVkLGNBQWMsRUFBRTtRQUMvQixNQUFNZSxXQUFXLElBQUksQ0FBQ04sT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNGLEtBQUtGLEtBQUssQ0FBQ1AsS0FBSztRQUM5RCxNQUFNQSxRQUFRVSxXQUNSRCxLQUFLRixLQUFLLENBQUNQLEtBQUssR0FDaEIsSUFBSSxDQUFDSSxPQUFPLENBQUNWLE1BQU0sQ0FBQyxFQUFFO1FBQzVCLE9BQU87WUFBQyxDQUFDLENBQUMsRUFBRU0sTUFBTSxDQUFDO1lBQUVaLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1QsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3pGO0lBQ0FpQjtRQUNJLE9BQU87WUFDSEMsWUFBWUMsQ0FBQUEsYUFBYyxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQ1gsT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNHLFdBQVdkLEtBQUssR0FBRzt3QkFDakQsT0FBTztvQkFDWDtvQkFDQSxPQUFPZSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDeEIsSUFBSSxFQUFFc0I7Z0JBQ3ZDO1lBQ0FHLGVBQWVILENBQUFBLGFBQWMsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUNYLE9BQU8sQ0FBQ1YsTUFBTSxDQUFDaUIsUUFBUSxDQUFDRyxXQUFXZCxLQUFLLEdBQUc7d0JBQ2pELE9BQU87b0JBQ1g7b0JBQ0EsT0FBT2UsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQzFCLElBQUksRUFBRSxhQUFhc0I7Z0JBQ3ZEO1FBQ0o7SUFDSjtJQUNBSztRQUNJLE9BQU8sSUFBSSxDQUFDZixPQUFPLENBQUNWLE1BQU0sQ0FBQzBCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPckIsUUFBVztnQkFDakQsR0FBR3FCLEtBQUs7Z0JBQ1IsR0FBRztvQkFDQyxDQUFDLENBQUMsUUFBUSxFQUFFckIsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFNLElBQUksQ0FBQ3NCLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxhQUFhLENBQUM7NEJBQUVqQjt3QkFBTTtnQkFDM0UsQ0FBQztZQUNMLElBQUksQ0FBQztJQUNUO0lBQ0F1QjtRQUNJLE9BQU8sSUFBSSxDQUFDbkIsT0FBTyxDQUFDVixNQUFNLENBQUNXLEdBQUcsQ0FBQ0wsQ0FBQUE7WUFDM0IsT0FBT1gsb0VBQXNCQSxDQUFDO2dCQUMxQm1DLE1BQU0sSUFBSUMsT0FBTyxDQUFDLE1BQU0sRUFBRXpCLE1BQU0sTUFBTSxDQUFDO2dCQUN2QzBCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUNmQyxlQUFlO29CQUNYM0I7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUV1QyxDQUN2QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzP2QzMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGhlYWRpbmdzLlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hlYWRpbmdcclxuICovXHJcbmNvbnN0IEhlYWRpbmcgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnaGVhZGluZycsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjb250ZW50OiAnaW5saW5lKicsXHJcbiAgICBncm91cDogJ2Jsb2NrJyxcclxuICAgIGRlZmluaW5nOiB0cnVlLFxyXG4gICAgYWRkQXR0cmlidXRlcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZXZlbDoge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMSxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVsc1xyXG4gICAgICAgICAgICAubWFwKChsZXZlbCkgPT4gKHtcclxuICAgICAgICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcclxuICAgICAgICAgICAgYXR0cnM6IHsgbGV2ZWwgfSxcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICBjb25zdCBoYXNMZXZlbCA9IHRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMobm9kZS5hdHRycy5sZXZlbCk7XHJcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbFxyXG4gICAgICAgICAgICA/IG5vZGUuYXR0cnMubGV2ZWxcclxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnMubGV2ZWxzWzBdO1xyXG4gICAgICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0SGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b2dnbGVIZWFkaW5nOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMucmVkdWNlKChpdGVtcywgbGV2ZWwpID0+ICh7XHJcbiAgICAgICAgICAgIC4uLml0ZW1zLFxyXG4gICAgICAgICAgICAuLi57XHJcbiAgICAgICAgICAgICAgICBbYE1vZC1BbHQtJHtsZXZlbH1gXTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSGVhZGluZyh7IGxldmVsIH0pLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLCB7fSk7XHJcbiAgICB9LFxyXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAobGV2ZWwgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKGBeKCN7MSwke2xldmVsfX0pXFxcXHMkYCksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBIZWFkaW5nLCBIZWFkaW5nIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJ0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIiwiSGVhZGluZyIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwibGV2ZWxzIiwiSFRNTEF0dHJpYnV0ZXMiLCJjb250ZW50IiwiZ3JvdXAiLCJkZWZpbmluZyIsImFkZEF0dHJpYnV0ZXMiLCJsZXZlbCIsImRlZmF1bHQiLCJyZW5kZXJlZCIsInBhcnNlSFRNTCIsIm9wdGlvbnMiLCJtYXAiLCJ0YWciLCJhdHRycyIsInJlbmRlckhUTUwiLCJub2RlIiwiaGFzTGV2ZWwiLCJpbmNsdWRlcyIsImFkZENvbW1hbmRzIiwic2V0SGVhZGluZyIsImF0dHJpYnV0ZXMiLCJjb21tYW5kcyIsInNldE5vZGUiLCJ0b2dnbGVIZWFkaW5nIiwidG9nZ2xlTm9kZSIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwicmVkdWNlIiwiaXRlbXMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsIlJlZ0V4cCIsInR5cGUiLCJnZXRBdHRyaWJ1dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   History: () => (/* binding */ History),\n/* harmony export */   \"default\": () => (/* binding */ History)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/history/dist/index.js\");\n\n\n/**\r\n * This extension allows you to undo and redo recent changes.\r\n * @see https://www.tiptap.dev/api/extensions/history\r\n *\r\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\r\n * the `history` extension, as it is not compatible with the `collaboration` extension.\r\n *\r\n * `@tiptap/extension-collaboration` uses its own history implementation.\r\n */ const History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"history\",\n    addOptions () {\n        return {\n            depth: 100,\n            newGroupDelay: 500\n        };\n    },\n    addCommands () {\n        return {\n            undo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);\n                },\n            redo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);\n                }\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options)\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-z\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-z\": ()=>this.editor.commands.redo(),\n            \"Mod-y\": ()=>this.editor.commands.redo(),\n            // Russian keyboard layouts\n            \"Mod-я\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-я\": ()=>this.editor.commands.redo()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDZ0I7QUFFekQ7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNSSxVQUFVSixtREFBU0EsQ0FBQ0ssTUFBTSxDQUFDO0lBQzdCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxPQUFPO1lBQ1BDLGVBQWU7UUFDbkI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSFQsTUFBTSxJQUFNLENBQUMsRUFBRVUsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVCLE9BQU9YLHdEQUFJQSxDQUFDVSxPQUFPQztnQkFDdkI7WUFDQVYsTUFBTSxJQUFNLENBQUMsRUFBRVMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVCLE9BQU9WLHdEQUFJQSxDQUFDUyxPQUFPQztnQkFDdkI7UUFDSjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIViwyREFBT0EsQ0FBQyxJQUFJLENBQUNXLE9BQU87U0FDdkI7SUFDTDtJQUNBQztRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNDLFFBQVEsQ0FBQ2hCLElBQUk7WUFDeEMsZUFBZSxJQUFNLElBQUksQ0FBQ2UsTUFBTSxDQUFDQyxRQUFRLENBQUNmLElBQUk7WUFDOUMsU0FBUyxJQUFNLElBQUksQ0FBQ2MsTUFBTSxDQUFDQyxRQUFRLENBQUNmLElBQUk7WUFDeEMsMkJBQTJCO1lBQzNCLFNBQVMsSUFBTSxJQUFJLENBQUNjLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDaEIsSUFBSTtZQUN4QyxlQUFlLElBQU0sSUFBSSxDQUFDZSxNQUFNLENBQUNDLFFBQVEsQ0FBQ2YsSUFBSTtRQUNsRDtJQUNKO0FBQ0o7QUFFdUMsQ0FDdkMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhpc3RvcnkvZGlzdC9pbmRleC5qcz8yNmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyB1bmRvLCByZWRvLCBoaXN0b3J5IH0gZnJvbSAnQHRpcHRhcC9wbS9oaXN0b3J5JztcblxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gdW5kbyBhbmQgcmVkbyByZWNlbnQgY2hhbmdlcy5cclxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2hpc3RvcnlcclxuICpcclxuICogKipJbXBvcnRhbnQqKjogSWYgdGhlIGBAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uYCBwYWNrYWdlIGlzIHVzZWQsIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICogdGhlIGBoaXN0b3J5YCBleHRlbnNpb24sIGFzIGl0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGBjb2xsYWJvcmF0aW9uYCBleHRlbnNpb24uXHJcbiAqXHJcbiAqIGBAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uYCB1c2VzIGl0cyBvd24gaGlzdG9yeSBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNvbnN0IEhpc3RvcnkgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdoaXN0b3J5JyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVwdGg6IDEwMCxcclxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRvKHN0YXRlLCBkaXNwYXRjaCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGhpc3RvcnkodGhpcy5vcHRpb25zKSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdNb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcclxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxyXG4gICAgICAgICAgICAnTW9kLXknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXHJcbiAgICAgICAgICAgIC8vIFJ1c3NpYW4ga2V5Ym9hcmQgbGF5b3V0c1xyXG4gICAgICAgICAgICAnTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxyXG4gICAgICAgICAgICAnU2hpZnQtTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgSGlzdG9yeSwgSGlzdG9yeSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJFeHRlbnNpb24iLCJ1bmRvIiwicmVkbyIsImhpc3RvcnkiLCJIaXN0b3J5IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJkZXB0aCIsIm5ld0dyb3VwRGVsYXkiLCJhZGRDb21tYW5kcyIsInN0YXRlIiwiZGlzcGF0Y2giLCJhZGRQcm9zZU1pcnJvclBsdWdpbnMiLCJvcHRpb25zIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJjb21tYW5kcyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ HorizontalRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n/**\r\n * This extension allows you to insert horizontal rules.\r\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\r\n */ const HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"horizontalRule\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    parseHTML () {\n        return [\n            {\n                tag: \"hr\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"hr\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    addCommands () {\n        return {\n            setHorizontalRule: ()=>({ chain, state })=>{\n                    const { $to: $originTo } = state.selection;\n                    const currentChain = chain();\n                    if ($originTo.parentOffset === 0) {\n                        currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), {\n                            type: this.name\n                        });\n                    } else {\n                        currentChain.insertContent({\n                            type: this.name\n                        });\n                    }\n                    return currentChain// set cursor after horizontal rule\n                    .command(({ tr, dispatch })=>{\n                        var _a;\n                        if (dispatch) {\n                            const { $to } = tr.selection;\n                            const posAfter = $to.end();\n                            if ($to.nodeAfter) {\n                                if ($to.nodeAfter.isTextblock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n                                } else if ($to.nodeAfter.isBlock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n                                } else {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n                                }\n                            } else {\n                                // add node after horizontal rule if it’s the end of the document\n                                const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n                                if (node) {\n                                    tr.insert(posAfter, node);\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n                                }\n                            }\n                            tr.scrollIntoView();\n                        }\n                        return true;\n                    }).run();\n                }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n                find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRTtBQUNKO0FBRWhFOzs7Q0FHQyxHQUNELE1BQU1LLGlCQUFpQkwsOENBQUlBLENBQUNNLE1BQU0sQ0FBQztJQUMvQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxPQUFPO0lBQ1BDO1FBQ0ksT0FBTztZQUFDO2dCQUFFQyxLQUFLO1lBQUs7U0FBRTtJQUMxQjtJQUNBQyxZQUFXLEVBQUVKLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTVIsNkRBQWVBLENBQUMsSUFBSSxDQUFDYSxPQUFPLENBQUNMLGNBQWMsRUFBRUE7U0FBZ0I7SUFDL0U7SUFDQU07UUFDSSxPQUFPO1lBQ0hDLG1CQUFtQixJQUFNLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7b0JBQ3RDLE1BQU0sRUFBRUMsS0FBS0MsU0FBUyxFQUFFLEdBQUdGLE1BQU1HLFNBQVM7b0JBQzFDLE1BQU1DLGVBQWVMO29CQUNyQixJQUFJRyxVQUFVRyxZQUFZLEtBQUssR0FBRzt3QkFDOUJELGFBQWFFLGVBQWUsQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDTixVQUFVTyxHQUFHLEdBQUcsR0FBRyxJQUFJOzRCQUFFQyxNQUFNLElBQUksQ0FBQ3JCLElBQUk7d0JBQUM7b0JBQ25GLE9BQ0s7d0JBQ0RlLGFBQWFPLGFBQWEsQ0FBQzs0QkFBRUQsTUFBTSxJQUFJLENBQUNyQixJQUFJO3dCQUFDO29CQUNqRDtvQkFDQSxPQUFRZSxZQUNKLG1DQUFtQztxQkFDbENRLE9BQU8sQ0FBQyxDQUFDLEVBQUVDLEVBQUUsRUFBRUMsUUFBUSxFQUFFO3dCQUMxQixJQUFJQzt3QkFDSixJQUFJRCxVQUFVOzRCQUNWLE1BQU0sRUFBRWIsR0FBRyxFQUFFLEdBQUdZLEdBQUdWLFNBQVM7NEJBQzVCLE1BQU1hLFdBQVdmLElBQUlnQixHQUFHOzRCQUN4QixJQUFJaEIsSUFBSWlCLFNBQVMsRUFBRTtnQ0FDZixJQUFJakIsSUFBSWlCLFNBQVMsQ0FBQ0MsV0FBVyxFQUFFO29DQUMzQk4sR0FBR08sWUFBWSxDQUFDbkMsMkRBQWFBLENBQUNHLE1BQU0sQ0FBQ3lCLEdBQUdRLEdBQUcsRUFBRXBCLElBQUlRLEdBQUcsR0FBRztnQ0FDM0QsT0FDSyxJQUFJUixJQUFJaUIsU0FBUyxDQUFDSSxPQUFPLEVBQUU7b0NBQzVCVCxHQUFHTyxZQUFZLENBQUNsQywyREFBYUEsQ0FBQ0UsTUFBTSxDQUFDeUIsR0FBR1EsR0FBRyxFQUFFcEIsSUFBSVEsR0FBRztnQ0FDeEQsT0FDSztvQ0FDREksR0FBR08sWUFBWSxDQUFDbkMsMkRBQWFBLENBQUNHLE1BQU0sQ0FBQ3lCLEdBQUdRLEdBQUcsRUFBRXBCLElBQUlRLEdBQUc7Z0NBQ3hEOzRCQUNKLE9BQ0s7Z0NBQ0QsaUVBQWlFO2dDQUNqRSxNQUFNYyxPQUFPLENBQUNSLEtBQUtkLElBQUl1QixNQUFNLENBQUNkLElBQUksQ0FBQ2UsWUFBWSxDQUFDQyxXQUFXLE1BQU0sUUFBUVgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHM0IsTUFBTTtnQ0FDM0csSUFBSW1DLE1BQU07b0NBQ05WLEdBQUdjLE1BQU0sQ0FBQ1gsVUFBVU87b0NBQ3BCVixHQUFHTyxZQUFZLENBQUNuQywyREFBYUEsQ0FBQ0csTUFBTSxDQUFDeUIsR0FBR1EsR0FBRyxFQUFFTCxXQUFXO2dDQUM1RDs0QkFDSjs0QkFDQUgsR0FBR2UsY0FBYzt3QkFDckI7d0JBQ0EsT0FBTztvQkFDWCxHQUNLQyxHQUFHO2dCQUNaO1FBQ0o7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSDlDLDJEQUFhQSxDQUFDO2dCQUNWK0MsTUFBTTtnQkFDTnJCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtBQUNKO0FBRXFELENBQ3JELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUvZGlzdC9pbmRleC5qcz8yNzAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgbm9kZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5cbi8qKlxyXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGluc2VydCBob3Jpem9udGFsIHJ1bGVzLlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hvcml6b250YWwtcnVsZVxyXG4gKi9cclxuY29uc3QgSG9yaXpvbnRhbFJ1bGUgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnaG9yaXpvbnRhbFJ1bGUnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBncm91cDogJ2Jsb2NrJyxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW3sgdGFnOiAnaHInIH1dO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnaHInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldEhvcml6b250YWxSdWxlOiAoKSA9PiAoeyBjaGFpbiwgc3RhdGUgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyAkdG86ICRvcmlnaW5UbyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENoYWluID0gY2hhaW4oKTtcclxuICAgICAgICAgICAgICAgIGlmICgkb3JpZ2luVG8ucGFyZW50T2Zmc2V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnRBdChNYXRoLm1heCgkb3JpZ2luVG8ucG9zIC0gMiwgMCksIHsgdHlwZTogdGhpcy5uYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnJlbnRDaGFpblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBjdXJzb3IgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJHRvIH0gPSB0ci5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc0FmdGVyID0gJHRvLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIuaXNUZXh0YmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJHRvLm5vZGVBZnRlci5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5vZGUgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlIGlmIGl04oCZcyB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IChfYSA9ICR0by5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHBvc0FmdGVyLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbm9kZUlucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgSG9yaXpvbnRhbFJ1bGUsIEhvcml6b250YWxSdWxlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJub2RlSW5wdXRSdWxlIiwiVGV4dFNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJIb3Jpem9udGFsUnVsZSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiSFRNTEF0dHJpYnV0ZXMiLCJncm91cCIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRIb3Jpem9udGFsUnVsZSIsImNoYWluIiwic3RhdGUiLCIkdG8iLCIkb3JpZ2luVG8iLCJzZWxlY3Rpb24iLCJjdXJyZW50Q2hhaW4iLCJwYXJlbnRPZmZzZXQiLCJpbnNlcnRDb250ZW50QXQiLCJNYXRoIiwibWF4IiwicG9zIiwidHlwZSIsImluc2VydENvbnRlbnQiLCJjb21tYW5kIiwidHIiLCJkaXNwYXRjaCIsIl9hIiwicG9zQWZ0ZXIiLCJlbmQiLCJub2RlQWZ0ZXIiLCJpc1RleHRibG9jayIsInNldFNlbGVjdGlvbiIsImRvYyIsImlzQmxvY2siLCJub2RlIiwicGFyZW50IiwiY29udGVudE1hdGNoIiwiZGVmYXVsdFR5cGUiLCJpbnNlcnQiLCJzY3JvbGxJbnRvVmlldyIsInJ1biIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ Italic),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * Matches an italic to a *italic* on input.\r\n */ const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\n/**\r\n * Matches an italic to a *italic* on paste.\r\n */ const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\n/**\r\n * Matches an italic to a _italic_ on input.\r\n */ const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\n/**\r\n * Matches an italic to a _italic_ on paste.\r\n */ const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\n/**\r\n * This extension allows you to create italic text.\r\n * @see https://www.tiptap.dev/api/marks/italic\r\n */ const Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"italic\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"em\"\n            },\n            {\n                tag: \"i\",\n                getAttrs: (node)=>node.style.fontStyle !== \"normal\" && null\n            },\n            {\n                style: \"font-style=italic\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"em\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setItalic: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleItalic: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetItalic: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-i\": ()=>this.editor.commands.toggleItalic(),\n            \"Mod-I\": ()=>this.editor.commands.toggleItalic()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRjtBQUVuRjs7Q0FFQyxHQUNELE1BQU1JLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHVCQUF1QjtBQUM3Qjs7Q0FFQyxHQUNELE1BQU1DLHVCQUF1QjtBQUM3Qjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTUiw4Q0FBSUEsQ0FBQ1MsTUFBTSxDQUFDO0lBQ3ZCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO1lBQ1Q7WUFDQTtnQkFDSUEsS0FBSztnQkFDTEMsVUFBVUMsQ0FBQUEsT0FBUUEsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLEtBQUssWUFBWTtZQUMzRDtZQUNBO2dCQUNJRCxPQUFPO1lBQ1g7U0FDSDtJQUNMO0lBQ0FFLFlBQVcsRUFBRVAsY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFNWCw2REFBZUEsQ0FBQyxJQUFJLENBQUNtQixPQUFPLENBQUNSLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNsRjtJQUNBUztRQUNJLE9BQU87WUFDSEMsV0FBVyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUMxQixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDZCxJQUFJO2dCQUNyQztZQUNBZSxjQUFjLElBQU0sQ0FBQyxFQUFFRixRQUFRLEVBQUU7b0JBQzdCLE9BQU9BLFNBQVNHLFVBQVUsQ0FBQyxJQUFJLENBQUNoQixJQUFJO2dCQUN4QztZQUNBaUIsYUFBYSxJQUFNLENBQUMsRUFBRUosUUFBUSxFQUFFO29CQUM1QixPQUFPQSxTQUFTSyxTQUFTLENBQUMsSUFBSSxDQUFDbEIsSUFBSTtnQkFDdkM7UUFDSjtJQUNKO0lBQ0FtQjtRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsWUFBWTtZQUNoRCxTQUFTLElBQU0sSUFBSSxDQUFDSyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsWUFBWTtRQUNwRDtJQUNKO0lBQ0FNO1FBQ0ksT0FBTztZQUNIN0IsMkRBQWFBLENBQUM7Z0JBQ1Y4QixNQUFNNUI7Z0JBQ042QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtZQUNBL0IsMkRBQWFBLENBQUM7Z0JBQ1Y4QixNQUFNMUI7Z0JBQ04yQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7SUFDQUM7UUFDSSxPQUFPO1lBQ0gvQiwyREFBYUEsQ0FBQztnQkFDVjZCLE1BQU0zQjtnQkFDTjRCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1lBQ0E5QiwyREFBYUEsQ0FBQztnQkFDVjZCLE1BQU16QjtnQkFDTjBCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtBQUNKO0FBRWlILENBQ2pILGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvZGlzdC9pbmRleC5qcz8xMzc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxyXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhICppdGFsaWMqIG9uIGlucHV0LlxyXG4gKi9cclxuY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkLztcclxuLyoqXHJcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgKml0YWxpYyogb24gcGFzdGUuXHJcbiAqL1xyXG5jb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKS9nO1xyXG4vKipcclxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBpbnB1dC5cclxuICovXHJcbmNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKSQvO1xyXG4vKipcclxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBwYXN0ZS5cclxuICovXHJcbmNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nO1xyXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgaXRhbGljIHRleHQuXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3MvaXRhbGljXHJcbiAqL1xyXG5jb25zdCBJdGFsaWMgPSBNYXJrLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnaXRhbGljJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2VtJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAnaScsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogbm9kZSA9PiBub2RlLnN0eWxlLmZvbnRTdHlsZSAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmb250LXN0eWxlPWl0YWxpYycsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ2VtJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvZ2dsZUl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdNb2QtaSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxyXG4gICAgICAgICAgICAnTW9kLUknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBJdGFsaWMsIEl0YWxpYyBhcyBkZWZhdWx0LCBzdGFySW5wdXRSZWdleCwgc3RhclBhc3RlUmVnZXgsIHVuZGVyc2NvcmVJbnB1dFJlZ2V4LCB1bmRlcnNjb3JlUGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTWFyayIsIm1lcmdlQXR0cmlidXRlcyIsIm1hcmtJbnB1dFJ1bGUiLCJtYXJrUGFzdGVSdWxlIiwic3RhcklucHV0UmVnZXgiLCJzdGFyUGFzdGVSZWdleCIsInVuZGVyc2NvcmVJbnB1dFJlZ2V4IiwidW5kZXJzY29yZVBhc3RlUmVnZXgiLCJJdGFsaWMiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwicGFyc2VIVE1MIiwidGFnIiwiZ2V0QXR0cnMiLCJub2RlIiwic3R5bGUiLCJmb250U3R5bGUiLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0SXRhbGljIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlSXRhbGljIiwidG9nZ2xlTWFyayIsInVuc2V0SXRhbGljIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsInR5cGUiLCJhZGRQYXN0ZVJ1bGVzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   \"default\": () => (/* binding */ ListItem)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create list items.\r\n * @see https://www.tiptap.dev/api/nodes/list-item\r\n */ const ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"listItem\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: \"bulletList\",\n            orderedListTypeName: \"orderedList\"\n        };\n    },\n    content: \"paragraph block*\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"li\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            Tab: ()=>this.editor.commands.sinkListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFdBQVdGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDekJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1lBQ2pCQyxvQkFBb0I7WUFDcEJDLHFCQUFxQjtRQUN6QjtJQUNKO0lBQ0FDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTUwsNkRBQWVBLENBQUMsSUFBSSxDQUFDYSxPQUFPLENBQUNSLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNsRjtJQUNBUztRQUNJLE9BQU87WUFDSEMsT0FBTyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxJQUFJLENBQUNmLElBQUk7WUFDekRnQixLQUFLLElBQU0sSUFBSSxDQUFDSCxNQUFNLENBQUNDLFFBQVEsQ0FBQ0csWUFBWSxDQUFDLElBQUksQ0FBQ2pCLElBQUk7WUFDdEQsYUFBYSxJQUFNLElBQUksQ0FBQ2EsTUFBTSxDQUFDQyxRQUFRLENBQUNJLFlBQVksQ0FBQyxJQUFJLENBQUNsQixJQUFJO1FBQ2xFO0lBQ0o7QUFDSjtBQUV5QyxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL2Rpc3QvaW5kZXguanM/NWUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgbGlzdCBpdGVtcy5cclxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW1cclxuICovXHJcbmNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2xpc3RJdGVtJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcclxuICAgICAgICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcclxuICAgIGRlZmluaW5nOiB0cnVlLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2xpJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IExpc3RJdGVtLCBMaXN0SXRlbSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiTGlzdEl0ZW0iLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiYnVsbGV0TGlzdFR5cGVOYW1lIiwib3JkZXJlZExpc3RUeXBlTmFtZSIsImNvbnRlbnQiLCJkZWZpbmluZyIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJFbnRlciIsImVkaXRvciIsImNvbW1hbmRzIiwic3BsaXRMaXN0SXRlbSIsIlRhYiIsInNpbmtMaXN0SXRlbSIsImxpZnRMaXN0SXRlbSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   \"default\": () => (/* binding */ OrderedList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create list items.\r\n * @see https://www.tiptap.dev/api/nodes/list-item\r\n */ const ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"listItem\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: \"bulletList\",\n            orderedListTypeName: \"orderedList\"\n        };\n    },\n    content: \"paragraph block*\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"li\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            Tab: ()=>this.editor.commands.sinkListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n    }\n});\n/**\r\n * This extension allows you to create text styles. It is required by default\r\n * for the `textColor` and `backgroundColor` extensions.\r\n * @see https://www.tiptap.dev/api/marks/text-style\r\n */ const TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"textStyle\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"span\",\n                getAttrs: (element)=>{\n                    const hasStyles = element.hasAttribute(\"style\");\n                    if (!hasStyles) {\n                        return false;\n                    }\n                    return {};\n                }\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"span\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            removeEmptyTextStyle: ()=>({ state, commands })=>{\n                    const attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, this.type);\n                    const hasStyles = Object.entries(attributes).some(([, value])=>!!value);\n                    if (hasStyles) {\n                        return true;\n                    }\n                    return commands.unsetMark(this.name);\n                }\n        };\n    }\n});\n/**\r\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\r\n */ const inputRegex = /^(\\d+)\\.\\s$/;\n/**\r\n * This extension allows you to create ordered lists.\r\n * This requires the ListItem extension\r\n * @see https://www.tiptap.dev/api/nodes/ordered-list\r\n * @see https://www.tiptap.dev/api/nodes/list-item\r\n */ const OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"orderedList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    addAttributes () {\n        return {\n            start: {\n                default: 1,\n                parseHTML: (element)=>{\n                    return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n                }\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ol\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\n        return start === 1 ? [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart),\n            0\n        ] : [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleOrderedList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-7\": ()=>this.editor.commands.toggleOrderedList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type,\n            getAttributes: (match)=>({\n                    start: +match[1]\n                }),\n            joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1]\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: (match)=>({\n                        start: +match[1],\n                        ...this.editor.getAttributes(TextStyle.name)\n                    }),\n                joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1],\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRztBQUVqRzs7O0NBR0MsR0FDRCxNQUFNSyxXQUFXTCw4Q0FBSUEsQ0FBQ00sTUFBTSxDQUFDO0lBQ3pCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztZQUNqQkMsb0JBQW9CO1lBQ3BCQyxxQkFBcUI7UUFDekI7SUFDSjtJQUNBQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lDLEtBQUs7WUFDVDtTQUNIO0lBQ0w7SUFDQUMsWUFBVyxFQUFFUCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQU1SLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1IsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2xGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxPQUFPLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNDLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLElBQUksQ0FBQ2YsSUFBSTtZQUN6RGdCLEtBQUssSUFBTSxJQUFJLENBQUNILE1BQU0sQ0FBQ0MsUUFBUSxDQUFDRyxZQUFZLENBQUMsSUFBSSxDQUFDakIsSUFBSTtZQUN0RCxhQUFhLElBQU0sSUFBSSxDQUFDYSxNQUFNLENBQUNDLFFBQVEsQ0FBQ0ksWUFBWSxDQUFDLElBQUksQ0FBQ2xCLElBQUk7UUFDbEU7SUFDSjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1tQixZQUFZeEIsOENBQUlBLENBQUNJLE1BQU0sQ0FBQztJQUMxQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBSztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztnQkFDTFksVUFBVUMsQ0FBQUE7b0JBQ04sTUFBTUMsWUFBWUQsUUFBUUUsWUFBWSxDQUFDO29CQUN2QyxJ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eUQsTUFBTXBCO1lBQ05OLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZzQixlQUFlSyxDQUFBQSxRQUFVO29CQUFFZCxPQUFPLENBQUNjLEtBQUssQ0FBQyxFQUFFO2dCQUFDO1lBQzVDQyxlQUFlLENBQUNELE9BQU9FLE9BQVNBLEtBQUtDLFVBQVUsR0FBR0QsS0FBS0UsS0FBSyxDQUFDbEIsS0FBSyxLQUFLLENBQUNjLEtBQUssQ0FBQyxFQUFFO1FBQ3BGO1FBQ0EsSUFBSSxJQUFJLENBQUM3QyxPQUFPLENBQUMyQixTQUFTLElBQUksSUFBSSxDQUFDM0IsT0FBTyxDQUFDNEIsY0FBYyxFQUFFO1lBQ3ZEZSxZQUFZeEQsK0RBQWlCQSxDQUFDO2dCQUMxQnlELE1BQU1wQjtnQkFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7Z0JBQ2ZTLFdBQVcsSUFBSSxDQUFDM0IsT0FBTyxDQUFDMkIsU0FBUztnQkFDakNDLGdCQUFnQixJQUFJLENBQUM1QixPQUFPLENBQUM0QixjQUFjO2dCQUMzQ1ksZUFBZUssQ0FBQUEsUUFBVTt3QkFBRWQsT0FBTyxDQUFDYyxLQUFLLENBQUMsRUFBRTt3QkFBRSxHQUFHLElBQUksQ0FBQzFDLE1BQU0sQ0FBQ3FDLGFBQWEsQ0FBQy9CLFVBQVVuQixJQUFJLENBQUM7b0JBQUM7Z0JBQzFGd0QsZUFBZSxDQUFDRCxPQUFPRSxPQUFTQSxLQUFLQyxVQUFVLEdBQUdELEtBQUtFLEtBQUssQ0FBQ2xCLEtBQUssS0FBSyxDQUFDYyxLQUFLLENBQUMsRUFBRTtnQkFDaEYxQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUN2QjtRQUNKO1FBQ0EsT0FBTztZQUNId0M7U0FDSDtJQUNMO0FBQ0o7QUFFMkQsQ0FDM0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdC9kaXN0L2luZGV4LmpzPzNlZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCBNYXJrLCBnZXRNYXJrQXR0cmlidXRlcywgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgbGlzdCBpdGVtcy5cclxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW1cclxuICovXHJcbmNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2xpc3RJdGVtJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcclxuICAgICAgICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcclxuICAgIGRlZmluaW5nOiB0cnVlLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2xpJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbi8qKlxyXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0ZXh0IHN0eWxlcy4gSXQgaXMgcmVxdWlyZWQgYnkgZGVmYXVsdFxyXG4gKiBmb3IgdGhlIGB0ZXh0Q29sb3JgIGFuZCBgYmFja2dyb3VuZENvbG9yYCBleHRlbnNpb25zLlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3RleHQtc3R5bGVcclxuICovXHJcbmNvbnN0IFRleHRTdHlsZSA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICd0ZXh0U3R5bGUnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAnc3BhbicsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNTdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICByZXR1cm4gWydzcGFuJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnNvbWUoKFssIHZhbHVlXSkgPT4gISF2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG4vKipcclxuICogTWF0Y2hlcyBhbiBvcmRlcmVkIGxpc3QgdG8gYSAxLiBvbiBpbnB1dCAob3IgYW55IG51bWJlciBmb2xsb3dlZCBieSBhIGRvdCkuXHJcbiAqL1xyXG5jb25zdCBpbnB1dFJlZ2V4ID0gL14oXFxkKylcXC5cXHMkLztcclxuLyoqXHJcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIG9yZGVyZWQgbGlzdHMuXHJcbiAqIFRoaXMgcmVxdWlyZXMgdGhlIExpc3RJdGVtIGV4dGVuc2lvblxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL29yZGVyZWQtbGlzdFxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2xpc3QtaXRlbVxyXG4gKi9cclxuY29uc3QgT3JkZXJlZExpc3QgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnb3JkZXJlZExpc3QnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAga2VlcE1hcmtzOiBmYWxzZSxcclxuICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ3JvdXA6ICdibG9jayBsaXN0JyxcclxuICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2A7XHJcbiAgICB9LFxyXG4gICAgYWRkQXR0cmlidXRlcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDoge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMSxcclxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdzdGFydCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0YXJ0JykgfHwgJycsIDEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ29sJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGFydCwgLi4uYXR0cmlidXRlc1dpdGhvdXRTdGFydCB9ID0gSFRNTEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09PSAxXHJcbiAgICAgICAgICAgID8gWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXVxyXG4gICAgICAgICAgICA6IFsnb2wnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvZ2dsZU9yZGVyZWRMaXN0OiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtLm5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpKS5ydW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LTcnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVPcmRlcmVkTGlzdCgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcclxuICAgICAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0gfSksXHJcbiAgICAgICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxyXG4gICAgICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0sIC4uLnRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpIH0pLFxyXG4gICAgICAgICAgICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgaW5wdXRSdWxlLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgT3JkZXJlZExpc3QsIE9yZGVyZWRMaXN0IGFzIGRlZmF1bHQsIGlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJNYXJrIiwiZ2V0TWFya0F0dHJpYnV0ZXMiLCJ3cmFwcGluZ0lucHV0UnVsZSIsIkxpc3RJdGVtIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImJ1bGxldExpc3RUeXBlTmFtZSIsIm9yZGVyZWRMaXN0VHlwZU5hbWUiLCJjb250ZW50IiwiZGVmaW5pbmciLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiRW50ZXIiLCJlZGl0b3IiLCJjb21tYW5kcyIsInNwbGl0TGlzdEl0ZW0iLCJUYWIiLCJzaW5rTGlzdEl0ZW0iLCJsaWZ0TGlzdEl0ZW0iLCJUZXh0U3R5bGUiLCJnZXRBdHRycyIsImVsZW1lbnQiLCJoYXNTdHlsZXMiLCJoYXNBdHRyaWJ1dGUiLCJhZGRDb21tYW5kcyIsInJlbW92ZUVtcHR5VGV4dFN0eWxlIiwic3RhdGUiLCJhdHRyaWJ1dGVzIiwidHlwZSIsIk9iamVjdCIsImVudHJpZXMiLCJzb21lIiwidmFsdWUiLCJ1bnNldE1hcmsiLCJpbnB1dFJlZ2V4IiwiT3JkZXJlZExpc3QiLCJpdGVtVHlwZU5hbWUiLCJrZWVwTWFya3MiLCJrZWVwQXR0cmlidXRlcyIsImdyb3VwIiwiYWRkQXR0cmlidXRlcyIsInN0YXJ0IiwiZGVmYXVsdCIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwiYXR0cmlidXRlc1dpdGhvdXRTdGFydCIsInRvZ2dsZU9yZGVyZWRMaXN0IiwiY2hhaW4iLCJ0b2dnbGVMaXN0IiwidXBkYXRlQXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZXMiLCJydW4iLCJhZGRJbnB1dFJ1bGVzIiwiaW5wdXRSdWxlIiwiZmluZCIsIm1hdGNoIiwiam9pblByZWRpY2F0ZSIsIm5vZGUiLCJjaGlsZENvdW50IiwiYXR0cnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ Paragraph)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create paragraphs.\r\n * @see https://www.tiptap.dev/api/nodes/paragraph\r\n */ const Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"paragraph\",\n    priority: 1000,\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    content: \"inline*\",\n    parseHTML () {\n        return [\n            {\n                tag: \"p\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"p\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setParagraph: ()=>({ commands })=>{\n                    return commands.setNode(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-0\": ()=>this.editor.commands.setParagraph()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFlBQVlGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBSTtTQUNkO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQUtOLDZEQUFlQSxDQUFDLElBQUksQ0FBQ1ksT0FBTyxDQUFDTixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDakY7SUFDQU87UUFDSSxPQUFPO1lBQ0hDLGNBQWMsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLElBQUksQ0FBQ2IsSUFBSTtnQkFDckM7UUFDSjtJQUNKO0lBQ0FjO1FBQ0ksT0FBTztZQUNILGFBQWEsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0gsUUFBUSxDQUFDRCxZQUFZO1FBQ3hEO0lBQ0o7QUFDSjtBQUUyQyxDQUMzQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanM/OGJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgcGFyYWdyYXBocy5cclxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9wYXJhZ3JhcGhcclxuICovXHJcbmNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdwYXJhZ3JhcGgnLFxyXG4gICAgcHJpb3JpdHk6IDEwMDAsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGdyb3VwOiAnYmxvY2snLFxyXG4gICAgY29udGVudDogJ2lubGluZSonLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgdGFnOiAncCcgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1BbHQtMCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgUGFyYWdyYXBoLCBQYXJhZ3JhcGggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsIlBhcmFncmFwaCIsImNyZWF0ZSIsIm5hbWUiLCJwcmlvcml0eSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImdyb3VwIiwiY29udGVudCIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRQYXJhZ3JhcGgiLCJjb21tYW5kcyIsInNldE5vZGUiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ Strike),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * Matches a strike to a ~~strike~~ on input.\r\n */ const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\n/**\r\n * Matches a strike to a ~~strike~~ on paste.\r\n */ const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\n/**\r\n * This extension allows you to create strike text.\r\n * @see https://www.tiptap.dev/api/marks/strike\r\n */ const Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"strike\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"s\"\n            },\n            {\n                tag: \"del\"\n            },\n            {\n                tag: \"strike\"\n            },\n            {\n                style: \"text-decoration\",\n                consuming: false,\n                getAttrs: (style)=>style.includes(\"line-through\") ? {} : false\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"s\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setStrike: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleStrike: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetStrike: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-s\": ()=>this.editor.commands.toggleStrike()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxhQUFhO0FBQ25COztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTTiw4Q0FBSUEsQ0FBQ08sTUFBTSxDQUFDO0lBQ3ZCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO1lBQ1Q7WUFDQTtnQkFDSUEsS0FBSztZQUNUO1lBQ0E7Z0JBQ0lBLEtBQUs7WUFDVDtZQUNBO2dCQUNJQyxPQUFPO2dCQUNQQyxXQUFXO2dCQUNYQyxVQUFVRixDQUFBQSxRQUFVQSxNQUFNRyxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSTtZQUM5RDtTQUNIO0lBQ0w7SUFDQUMsWUFBVyxFQUFFUCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQUtULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2lCLE9BQU8sQ0FBQ1IsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2pGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxXQUFXLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzFCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNkLElBQUk7Z0JBQ3JDO1lBQ0FlLGNBQWMsSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2hCLElBQUk7Z0JBQ3hDO1lBQ0FpQixhQUFhLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzVCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUNsQixJQUFJO2dCQUN2QztRQUNKO0lBQ0o7SUFDQW1CO1FBQ0ksT0FBTztZQUNILGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxZQUFZO1FBQzFEO0lBQ0o7SUFDQU07UUFDSSxPQUFPO1lBQ0gzQiwyREFBYUEsQ0FBQztnQkFDVjRCLE1BQU0xQjtnQkFDTjJCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtJQUNBQztRQUNJLE9BQU87WUFDSDdCLDJEQUFhQSxDQUFDO2dCQUNWMkIsTUFBTXpCO2dCQUNOMEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0FBQ0o7QUFFNkQsQ0FDN0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9kaXN0L2luZGV4LmpzPzhlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXHJcbiAqIE1hdGNoZXMgYSBzdHJpa2UgdG8gYSB+fnN0cmlrZX5+IG9uIGlucHV0LlxyXG4gKi9cclxuY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykofn4oPyFcXHMrfn4pKCg/Oltefl0rKSl+fig/IVxccyt+fikpJC87XHJcbi8qKlxyXG4gKiBNYXRjaGVzIGEgc3RyaWtlIHRvIGEgfn5zdHJpa2V+fiBvbiBwYXN0ZS5cclxuICovXHJcbmNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nO1xyXG4vKipcclxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgc3RyaWtlIHRleHQuXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3Mvc3RyaWtlXHJcbiAqL1xyXG5jb25zdCBTdHJpa2UgPSBNYXJrLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnc3RyaWtlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ3MnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdkZWwnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdzdHJpa2UnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3RleHQtZGVjb3JhdGlvbicsXHJcbiAgICAgICAgICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IHN0eWxlID0+IChzdHlsZS5pbmNsdWRlcygnbGluZS10aHJvdWdoJykgPyB7fSA6IGZhbHNlKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsncycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b2dnbGVTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LXMnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdHJpa2UoKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IFN0cmlrZSwgU3RyaWtlIGFzIGRlZmF1bHQsIGlucHV0UmVnZXgsIHBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1hcmsiLCJtZXJnZUF0dHJpYnV0ZXMiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsImlucHV0UmVnZXgiLCJwYXN0ZVJlZ2V4IiwiU3RyaWtlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsInN0eWxlIiwiY29uc3VtaW5nIiwiZ2V0QXR0cnMiLCJpbmNsdWRlcyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRTdHJpa2UiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVTdHJpa2UiLCJ0b2dnbGVNYXJrIiwidW5zZXRTdHJpa2UiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImFkZFBhc3RlUnVsZXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text-style/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-text-style/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextStyle: () => (/* binding */ TextStyle),\n/* harmony export */   \"default\": () => (/* binding */ TextStyle)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create text styles. It is required by default\r\n * for the `textColor` and `backgroundColor` extensions.\r\n * @see https://www.tiptap.dev/api/marks/text-style\r\n */ const TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"textStyle\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"span\",\n                getAttrs: (element)=>{\n                    const hasStyles = element.hasAttribute(\"style\");\n                    if (!hasStyles) {\n                        return false;\n                    }\n                    return {};\n                }\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"span\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            removeEmptyTextStyle: ()=>({ state, commands })=>{\n                    const attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, this.type);\n                    const hasStyles = Object.entries(attributes).some(([, value])=>!!value);\n                    if (hasStyles) {\n                        return true;\n                    }\n                    return commands.unsetMark(this.name);\n                }\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RTtBQUV4RTs7OztDQUlDLEdBQ0QsTUFBTUcsWUFBWUgsOENBQUlBLENBQUNJLE1BQU0sQ0FBQztJQUMxQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztnQkFDTEMsVUFBVUMsQ0FBQUE7b0JBQ04sTUFBTUMsWUFBWUQsUUFBUUUsWUFBWSxDQUFDO29CQUN2QyxJQUFJLENBQUNELFdBQVc7d0JBQ1osT0FBTztvQkFDWDtvQkFDQSxPQUFPLENBQUM7Z0JBQ1o7WUFDSjtTQUNIO0lBQ0w7SUFDQUUsWUFBVyxFQUFFUCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQVFOLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2MsT0FBTyxDQUFDUixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDcEY7SUFDQVM7UUFDSSxPQUFPO1lBQ0hDLHNCQUFzQixJQUFNLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVDLE1BQU1DLGFBQWFsQiwrREFBaUJBLENBQUNnQixPQUFPLElBQUksQ0FBQ0csSUFBSTtvQkFDckQsTUFBTVQsWUFBWVUsT0FBT0MsT0FBTyxDQUFDSCxZQUFZSSxJQUFJLENBQUMsQ0FBQyxHQUFHQyxNQUFNLEdBQUssQ0FBQyxDQUFDQTtvQkFDbkUsSUFBSWIsV0FBVzt3QkFDWCxPQUFPO29CQUNYO29CQUNBLE9BQU9PLFNBQVNPLFNBQVMsQ0FBQyxJQUFJLENBQUNyQixJQUFJO2dCQUN2QztRQUNKO0lBQ0o7QUFDSjtBQUUyQyxDQUMzQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9kaXN0L2luZGV4LmpzP2ViMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxyXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0ZXh0IHN0eWxlcy4gSXQgaXMgcmVxdWlyZWQgYnkgZGVmYXVsdFxyXG4gKiBmb3IgdGhlIGB0ZXh0Q29sb3JgIGFuZCBgYmFja2dyb3VuZENvbG9yYCBleHRlbnNpb25zLlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3RleHQtc3R5bGVcclxuICovXHJcbmNvbnN0IFRleHRTdHlsZSA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICd0ZXh0U3R5bGUnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAnc3BhbicsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNTdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICByZXR1cm4gWydzcGFuJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnNvbWUoKFssIHZhbHVlXSkgPT4gISF2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBUZXh0U3R5bGUsIFRleHRTdHlsZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwiZ2V0TWFya0F0dHJpYnV0ZXMiLCJUZXh0U3R5bGUiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwicGFyc2VIVE1MIiwidGFnIiwiZ2V0QXR0cnMiLCJlbGVtZW50IiwiaGFzU3R5bGVzIiwiaGFzQXR0cmlidXRlIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJhZGRDb21tYW5kcyIsInJlbW92ZUVtcHR5VGV4dFN0eWxlIiwic3RhdGUiLCJjb21tYW5kcyIsImF0dHJpYnV0ZXMiLCJ0eXBlIiwiT2JqZWN0IiwiZW50cmllcyIsInNvbWUiLCJ2YWx1ZSIsInVuc2V0TWFyayIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text-style/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\r\n * This extension allows you to create text nodes.\r\n * @see https://www.tiptap.dev/api/nodes/text\r\n */ const Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"text\",\n    group: \"inline\"\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUVwQzs7O0NBR0MsR0FDRCxNQUFNQyxPQUFPRCw4Q0FBSUEsQ0FBQ0UsTUFBTSxDQUFDO0lBQ3JCQyxNQUFNO0lBQ05DLE9BQU87QUFDWDtBQUVpQyxDQUNqQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzPzllNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxyXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0ZXh0IG5vZGVzLlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RleHRcclxuICovXHJcbmNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAndGV4dCcsXHJcbiAgICBncm91cDogJ2lubGluZScsXHJcbn0pO1xuXG5leHBvcnQgeyBUZXh0LCBUZXh0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJUZXh0IiwiY3JlYXRlIiwibmFtZSIsImdyb3VwIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9CQUFvQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2NvbW1hbmRzL2Rpc3QvaW5kZXguanM/OTEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21tYW5kcy9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWNvbW1hbmRzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dropcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQkFBc0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanM/YmQzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBkcm9wY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvclwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz9jMGIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGdhcGN1cnNvci9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWdhcGN1cnNvclwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsbUJBQW1CO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vaGlzdG9yeS9kaXN0L2luZGV4LmpzPzE2NjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaGlzdG9yeS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWhpc3RvcnlcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/history/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9rZXltYXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrQkFBa0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9rZXltYXAvZGlzdC9pbmRleC5qcz80YmViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGtleW1hcC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWtleW1hcFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vbW9kZWwvZGlzdC9pbmRleC5qcz9hNWEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG1vZGVsL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSx1QkFBdUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzPzU0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2NoZW1hLWxpc3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zdGF0ZS9kaXN0L2luZGV4LmpzPzcyZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3RhdGUvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS90cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS90cmFuc2Zvcm0vZGlzdC9pbmRleC5qcz84YTRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRyYW5zZm9ybS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXRyYW5zZm9ybVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard),\n/* harmony export */   __serializeForClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__serializeForClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS92aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGdCQUFnQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL25vcy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3ZpZXcvZGlzdC9pbmRleC5qcz83NTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpZXcvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension),\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createDocument),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isActive),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.resolveFocusPosition),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textblockTypeInputRule),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-bubble-menu */ \"(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-floating-menu */ \"(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\");\n\n\n\n\n\n\nconst mergeRefs = (...refs)=>{\n    return (node)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(node);\n            } else if (ref) {\n                ref.current = node;\n            }\n        });\n    };\n};\nconst Portals = ({ renderers })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Object.entries(renderers).map(([key, renderer])=>{\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, key);\n    }));\n};\nclass PureEditorContent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.editorContentRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.initialized = false;\n        this.state = {\n            renderers: {}\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const { editor } = this.props;\n        if (editor && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(...editor.options.element.childNodes);\n            editor.setOptions({\n                element\n            });\n            editor.contentComponent = this;\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    maybeFlushSync(fn) {\n        // Avoid calling flushSync until the editor is initialized.\n        // Initialization happens during the componentDidMount or componentDidUpdate\n        // lifecycle methods, and React doesn't allow calling flushSync from inside\n        // a lifecycle method.\n        if (this.initialized) {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(fn);\n        } else {\n            fn();\n        }\n    }\n    setRenderer(id, renderer) {\n        this.maybeFlushSync(()=>{\n            this.setState(({ renderers })=>({\n                    renderers: {\n                        ...renderers,\n                        [id]: renderer\n                    }\n                }));\n        });\n    }\n    removeRenderer(id) {\n        this.maybeFlushSync(()=>{\n            this.setState(({ renderers })=>{\n                const nextRenderers = {\n                    ...renderers\n                };\n                delete nextRenderers[id];\n                return {\n                    renderers: nextRenderers\n                };\n            });\n        });\n    }\n    componentWillUnmount() {\n        const { editor } = this.props;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {}\n            });\n        }\n        editor.contentComponent = null;\n        if (!editor.options.element.firstChild) {\n            return;\n        }\n        const newElement = document.createElement(\"div\");\n        newElement.append(...editor.options.element.childNodes);\n        editor.setOptions({\n            element: newElement\n        });\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: mergeRefs(innerRef, this.editorContentRef),\n            ...rest\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portals, {\n            renderers: this.state.renderers\n        }));\n    }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return Math.floor(Math.random() * 0xFFFFFFFF).toString();\n    }, [\n        props.editor\n    ]);\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props\n    });\n});\nconst EditorContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\nclass Editor extends _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor {\n    constructor(){\n        super(...arguments);\n        this.contentComponent = null;\n    }\n}\n/**\r\n * This hook allows you to create an editor instance.\r\n * @param options The editor options\r\n * @param deps The dependencies to watch for changes\r\n * @returns The editor instance\r\n * @example const editor = useEditor({ extensions: [...] })\r\n */ const useEditor = (options = {}, deps = [])=>{\n    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const { onBeforeCreate, onBlur, onCreate, onDestroy, onFocus, onSelectionUpdate, onTransaction, onUpdate } = options;\n    const onBeforeCreateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onBeforeCreate);\n    const onBlurRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onBlur);\n    const onCreateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onCreate);\n    const onDestroyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDestroy);\n    const onFocusRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onFocus);\n    const onSelectionUpdateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onSelectionUpdate);\n    const onTransactionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onTransaction);\n    const onUpdateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onUpdate);\n    // This effect will handle updating the editor instance\n    // when the event handlers change.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!editorRef.current) {\n            return;\n        }\n        if (onBeforeCreate) {\n            editorRef.current.off(\"beforeCreate\", onBeforeCreateRef.current);\n            editorRef.current.on(\"beforeCreate\", onBeforeCreate);\n            onBeforeCreateRef.current = onBeforeCreate;\n        }\n        if (onBlur) {\n            editorRef.current.off(\"blur\", onBlurRef.current);\n            editorRef.current.on(\"blur\", onBlur);\n            onBlurRef.current = onBlur;\n        }\n        if (onCreate) {\n            editorRef.current.off(\"create\", onCreateRef.current);\n            editorRef.current.on(\"create\", onCreate);\n            onCreateRef.current = onCreate;\n        }\n        if (onDestroy) {\n            editorRef.current.off(\"destroy\", onDestroyRef.current);\n            editorRef.current.on(\"destroy\", onDestroy);\n            onDestroyRef.current = onDestroy;\n        }\n        if (onFocus) {\n            editorRef.current.off(\"focus\", onFocusRef.current);\n            editorRef.current.on(\"focus\", onFocus);\n            onFocusRef.current = onFocus;\n        }\n        if (onSelectionUpdate) {\n            editorRef.current.off(\"selectionUpdate\", onSelectionUpdateRef.current);\n            editorRef.current.on(\"selectionUpdate\", onSelectionUpdate);\n            onSelectionUpdateRef.current = onSelectionUpdate;\n        }\n        if (onTransaction) {\n            editorRef.current.off(\"transaction\", onTransactionRef.current);\n            editorRef.current.on(\"transaction\", onTransaction);\n            onTransactionRef.current = onTransaction;\n        }\n        if (onUpdate) {\n            editorRef.current.off(\"update\", onUpdateRef.current);\n            editorRef.current.on(\"update\", onUpdate);\n            onUpdateRef.current = onUpdate;\n        }\n    }, [\n        onBeforeCreate,\n        onBlur,\n        onCreate,\n        onDestroy,\n        onFocus,\n        onSelectionUpdate,\n        onTransaction,\n        onUpdate,\n        editorRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isMounted = true;\n        const editor = new Editor(options);\n        editorRef.current = editor;\n        editorRef.current.on(\"transaction\", ()=>{\n            requestAnimationFrame(()=>{\n                requestAnimationFrame(()=>{\n                    if (isMounted) {\n                        forceUpdate({});\n                    }\n                });\n            });\n        });\n        return ()=>{\n            isMounted = false;\n            editor.destroy();\n        };\n    }, deps);\n    return editorRef.current;\n};\nconst EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    editor: null\n});\nconst EditorConsumer = EditorContext.Consumer;\nconst useCurrentEditor = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\nconst EditorProvider = ({ children, slotAfter, slotBefore, ...editorOptions })=>{\n    const editor = useEditor(editorOptions);\n    if (!editor) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContext.Provider, {\n        value: {\n            editor\n        }\n    }, slotBefore, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorConsumer, null, ({ editor: currentEditor })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContent, {\n            editor: currentEditor\n        })), children, slotAfter);\n};\nconst BubbleMenu = (props)=>{\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = \"bubbleMenu\", editor, tippyOptions = {}, updateDelay, shouldShow = null } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn(\"BubbleMenu component is not rendered inside of an editor component or does not have editor prop.\");\n            return;\n        }\n        const plugin = (0,_tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__.BubbleMenuPlugin)({\n            updateDelay,\n            editor: menuEditor,\n            element,\n            pluginKey,\n            shouldShow,\n            tippyOptions\n        });\n        menuEditor.registerPlugin(plugin);\n        return ()=>menuEditor.unregisterPlugin(pluginKey);\n    }, [\n        props.editor,\n        currentEditor,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: setElement,\n        className: props.className,\n        style: {\n            visibility: \"hidden\"\n        }\n    }, props.children);\n};\nconst FloatingMenu = (props)=>{\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = \"floatingMenu\", editor, tippyOptions = {}, shouldShow = null } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn(\"FloatingMenu component is not rendered inside of an editor component or does not have editor prop.\");\n            return;\n        }\n        const plugin = (0,_tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__.FloatingMenuPlugin)({\n            pluginKey,\n            editor: menuEditor,\n            element,\n            tippyOptions,\n            shouldShow\n        });\n        menuEditor.registerPlugin(plugin);\n        return ()=>menuEditor.unregisterPlugin(pluginKey);\n    }, [\n        props.editor,\n        currentEditor,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: setElement,\n        className: props.className,\n        style: {\n            visibility: \"hidden\"\n        }\n    }, props.children);\n};\nconst ReactNodeViewContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    onDragStart: undefined\n});\nconst useReactNodeView = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\nconst NodeViewContent = (props)=>{\n    const Tag = props.as || \"div\";\n    const { nodeViewContentRef } = useReactNodeView();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n            whiteSpace: \"pre-wrap\",\n            ...props.style\n        }\n    });\n};\nconst NodeViewWrapper = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || \"div\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, {\n        ...props,\n        ref: ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart: onDragStart,\n        style: {\n            whiteSpace: \"normal\",\n            ...props.style\n        }\n    });\n});\n/**\r\n * Check if a component is a class component.\r\n * @param Component\r\n * @returns {boolean}\r\n */ function isClassComponent(Component) {\n    return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\n/**\r\n * Check if a component is a forward ref component.\r\n * @param Component\r\n * @returns {boolean}\r\n */ function isForwardRefComponent(Component) {\n    var _a;\n    return !!(typeof Component === \"object\" && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === \"Symbol(react.forward_ref)\");\n}\n/**\r\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\r\n * @example\r\n * new ReactRenderer(MyComponent, {\r\n *   editor,\r\n *   props: {\r\n *     foo: 'bar',\r\n *   },\r\n *   as: 'span',\r\n * })\r\n*/ class ReactRenderer {\n    constructor(component, { editor, props = {}, as = \"div\", className = \"\", attrs }){\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add(\"react-renderer\");\n        if (className) {\n            this.element.classList.add(...className.split(\" \"));\n        }\n        if (attrs) {\n            Object.keys(attrs).forEach((key)=>{\n                this.element.setAttribute(key, attrs[key]);\n            });\n        }\n        this.render();\n    }\n    render() {\n        var _a, _b;\n        const Component = this.component;\n        const props = this.props;\n        if (isClassComponent(Component) || isForwardRefComponent(Component)) {\n            props.ref = (ref)=>{\n                this.ref = ref;\n            };\n        }\n        this.reactElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n            ...props\n        });\n        (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.setRenderer(this.id, this);\n    }\n    updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props\n        };\n        this.render();\n    }\n    destroy() {\n        var _a, _b;\n        (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.removeRenderer(this.id);\n    }\n}\nclass ReactNodeView extends _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView {\n    mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            selected: false,\n            extension: this.extension,\n            getPos: ()=>this.getPos(),\n            updateAttributes: (attributes = {})=>this.updateAttributes(attributes),\n            deleteNode: ()=>this.deleteNode()\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string)=>{\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const ReactNodeViewProvider = (componentProps)=>{\n            const Component = this.component;\n            const onDragStart = this.onDragStart.bind(this);\n            const nodeViewContentRef = (element)=>{\n                if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                    element.appendChild(this.contentDOMElement);\n                }\n            };\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactNodeViewContext.Provider, {\n                value: {\n                    onDragStart,\n                    nodeViewContentRef\n                }\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n                ...componentProps\n            })));\n        };\n        ReactNodeViewProvider.displayName = \"ReactNodeView\";\n        if (this.node.isLeaf) {\n            this.contentDOMElement = null;\n        } else if (this.options.contentDOMElementTag) {\n            this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n        } else {\n            this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n        }\n        if (this.contentDOMElement) {\n            // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n            // With this fix it seems to work fine\n            // See: https://github.com/ueberdosis/tiptap/issues/1197\n            this.contentDOMElement.style.whiteSpace = \"inherit\";\n        }\n        let as = this.node.isInline ? \"span\" : \"div\";\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = \"\" } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim(),\n            attrs: this.options.attrs\n        });\n    }\n    get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n            throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n        }\n        return this.renderer.element;\n    }\n    get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    handleSelectionUpdate() {\n        const { from, to } = this.editor.state.selection;\n        if (from <= this.getPos() && to >= this.getPos() + this.node.nodeSize) {\n            if (this.renderer.props.selected) {\n                return;\n            }\n            this.selectNode();\n        } else {\n            if (!this.renderer.props.selected) {\n                return;\n            }\n            this.deselectNode();\n        }\n    }\n    update(node, decorations) {\n        const updateProps = (props)=>{\n            this.renderer.updateProps(props);\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === \"function\") {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            this.node = node;\n            this.decorations = decorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                updateProps: ()=>updateProps({\n                        node,\n                        decorations\n                    })\n            });\n        }\n        if (node === this.node && this.decorations === decorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        updateProps({\n            node,\n            decorations\n        });\n        return true;\n    }\n    selectNode() {\n        this.renderer.updateProps({\n            selected: true\n        });\n        this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n    }\n    deselectNode() {\n        this.renderer.updateProps({\n            selected: false\n        });\n        this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n    }\n    destroy() {\n        this.renderer.destroy();\n        this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n    }\n}\nfunction ReactNodeViewRenderer(component, options) {\n    return (props)=>{\n        // try to get the parent component\n        // this is important for vue devtools to show the component hierarchy correctly\n        // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNpQztBQUNsRDtBQUNZO0FBQy9CO0FBQ3dDO0FBRXJFLE1BQU1jLFlBQVksQ0FBQyxHQUFHQztJQUNsQixPQUFPLENBQUNDO1FBQ0pELEtBQUtFLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDVCxJQUFJLE9BQU9BLFFBQVEsWUFBWTtnQkFDM0JBLElBQUlGO1lBQ1IsT0FDSyxJQUFJRSxLQUFLO2dCQUNWQSxJQUFJQyxPQUFPLEdBQUdIO1lBQ2xCO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsTUFBTUksVUFBVSxDQUFDLEVBQUVDLFNBQVMsRUFBRTtJQUMxQixxQkFBUXBCLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU11QixPQUFPQyxPQUFPLENBQUNKLFdBQVdLLEdBQUcsQ0FBQyxDQUFDLENBQUNDLEtBQUtDLFNBQVM7UUFDNUYscUJBQU9wQixtREFBcUIsQ0FBQ29CLFNBQVNFLFlBQVksRUFBRUYsU0FBU0csT0FBTyxFQUFFSjtJQUMxRTtBQUNKO0FBQ0EsTUFBTUssMEJBQTBCL0IsNENBQWU7SUFDM0NpQyxZQUFZQyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsaUJBQUduQyw0Q0FBZTtRQUN2QyxJQUFJLENBQUNxQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVGxCLFdBQVcsQ0FBQztRQUNoQjtJQUNKO0lBQ0FtQixvQkFBb0I7UUFDaEIsSUFBSSxDQUFDQyxJQUFJO0lBQ2I7SUFDQUMscUJBQXFCO1FBQ2pCLElBQUksQ0FBQ0QsSUFBSTtJQUNiO0lBQ0FBLE9BQU87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UUFBUSxDQUFDRyxPQUFPLENBQUNzSCxTQUFTLENBQUNrRCxNQUFNLENBQUM7SUFDM0M7SUFDQWxHLFVBQVU7UUFDTixJQUFJLENBQUN6RSxRQUFRLENBQUN5RSxPQUFPO1FBQ3JCLElBQUksQ0FBQzFELE1BQU0sQ0FBQ3NELEdBQUcsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDbUYscUJBQXFCO1FBQzdELElBQUksQ0FBQ0wsaUJBQWlCLEdBQUc7SUFDN0I7QUFDSjtBQUNBLFNBQVN5QixzQkFBc0JyRCxTQUFTLEVBQUV2RyxPQUFPO0lBQzdDLE9BQU8sQ0FBQ1Q7UUFDSixrQ0FBa0M7UUFDbEMsK0VBQStFO1FBQy9FLHFFQUFxRTtRQUNyRSxJQUFJLENBQUNBLE1BQU1RLE1BQU0sQ0FBQ0UsZ0JBQWdCLEVBQUU7WUFDaEMsT0FBTyxDQUFDO1FBQ1o7UUFDQSxPQUFPLElBQUkrRyxjQUFjVCxXQUFXaEgsT0FBT1M7SUFDL0M7QUFDSjtBQUUwUSxDQUMxUSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3MvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzP2FiYmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnViYmxlTWVudVBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51JztcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00sIHsgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IEVkaXRvciBhcyBFZGl0b3IkMSwgTm9kZVZpZXcgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IEZsb2F0aW5nTWVudVBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWZsb2F0aW5nLW1lbnUnO1xuXG5jb25zdCBtZXJnZVJlZnMgPSAoLi4ucmVmcykgPT4ge1xyXG4gICAgcmV0dXJuIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZWYobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XHJcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IFBvcnRhbHMgPSAoeyByZW5kZXJlcnMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBPYmplY3QuZW50cmllcyhyZW5kZXJlcnMpLm1hcCgoW2tleSwgcmVuZGVyZXJdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChyZW5kZXJlci5yZWFjdEVsZW1lbnQsIHJlbmRlcmVyLmVsZW1lbnQsIGtleSk7XHJcbiAgICB9KSkpO1xyXG59O1xyXG5jbGFzcyBQdXJlRWRpdG9yQ29udGVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLmVkaXRvckNvbnRlbnRSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgcmVuZGVyZXJzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGlmIChlZGl0b3IgJiYgZWRpdG9yLm9wdGlvbnMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lZGl0b3JDb250ZW50UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKC4uLmVkaXRvci5vcHRpb25zLmVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGVkaXRvci5jcmVhdGVOb2RlVmlld3MoKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF5YmVGbHVzaFN5bmMoZm4pIHtcclxuICAgICAgICAvLyBBdm9pZCBjYWxsaW5nIGZsdXNoU3luYyB1bnRpbCB0aGUgZWRpdG9yIGlzIGluaXRpYWxpemVkLlxyXG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uIGhhcHBlbnMgZHVyaW5nIHRoZSBjb21wb25lbnREaWRNb3VudCBvciBjb21wb25lbnREaWRVcGRhdGVcclxuICAgICAgICAvLyBsaWZlY3ljbGUgbWV0aG9kcywgYW5kIFJlYWN0IGRvZXNuJ3QgYWxsb3cgY2FsbGluZyBmbHVzaFN5bmMgZnJvbSBpbnNpZGVcclxuICAgICAgICAvLyBhIGxpZmVjeWNsZSBtZXRob2QuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgZmx1c2hTeW5jKGZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0UmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5tYXliZUZsdXNoU3luYygoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHsgcmVuZGVyZXJzIH0pID0+ICh7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5yZW5kZXJlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgW2lkXTogcmVuZGVyZXIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVSZW5kZXJlcihpZCkge1xyXG4gICAgICAgIHRoaXMubWF5YmVGbHVzaFN5bmMoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKCh7IHJlbmRlcmVycyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVuZGVyZXJzID0geyAuLi5yZW5kZXJlcnMgfTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXh0UmVuZGVyZXJzW2lkXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlbmRlcmVyczogbmV4dFJlbmRlcmVycyB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGlmICghZWRpdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIGVkaXRvci52aWV3LnNldFByb3BzKHtcclxuICAgICAgICAgICAgICAgIG5vZGVWaWV3czoge30sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFlZGl0b3Iub3B0aW9ucy5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbmV3RWxlbWVudC5hcHBlbmQoLi4uZWRpdG9yLm9wdGlvbnMuZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG5ld0VsZW1lbnQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeyBlZGl0b3IsIGlubmVyUmVmLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogbWVyZ2VSZWZzKGlubmVyUmVmLCB0aGlzLmVkaXRvckNvbnRlbnRSZWYpLCAuLi5yZXN0IH0pLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbHMsIHsgcmVuZGVyZXJzOiB0aGlzLnN0YXRlLnJlbmRlcmVycyB9KSkpO1xyXG4gICAgfVxyXG59XHJcbi8vIEVkaXRvckNvbnRlbnQgc2hvdWxkIGJlIHJlLWNyZWF0ZWQgd2hlbmV2ZXIgdGhlIEVkaXRvciBpbnN0YW5jZSBjaGFuZ2VzXHJcbmNvbnN0IEVkaXRvckNvbnRlbnRXaXRoS2V5ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xyXG4gICAgY29uc3Qga2V5ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpLnRvU3RyaW5nKCk7XHJcbiAgICB9LCBbcHJvcHMuZWRpdG9yXSk7XHJcbiAgICAvLyBDYW4ndCB1c2UgSlNYIGhlcmUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCB0aGUgdHlwZSBkZWZpbml0aW9uIG9mIFZ1ZSdzIEpTWCwgc28gdXNlIGNyZWF0ZUVsZW1lbnRcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFB1cmVFZGl0b3JDb250ZW50LCB7XHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIGlubmVyUmVmOiByZWYsXHJcbiAgICAgICAgLi4ucHJvcHMsXHJcbiAgICB9KTtcclxufSk7XHJcbmNvbnN0IEVkaXRvckNvbnRlbnQgPSBSZWFjdC5tZW1vKEVkaXRvckNvbnRlbnRXaXRoS2V5KTtcblxuY2xhc3MgRWRpdG9yIGV4dGVuZHMgRWRpdG9yJDEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGhvb2sgYWxsb3dzIHlvdSB0byBjcmVhdGUgYW4gZWRpdG9yIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgZWRpdG9yIG9wdGlvbnNcclxuICogQHBhcmFtIGRlcHMgVGhlIGRlcGVuZGVuY2llcyB0byB3YXRjaCBmb3IgY2hhbmdlc1xyXG4gKiBAcmV0dXJucyBUaGUgZWRpdG9yIGluc3RhbmNlXHJcbiAqIEBleGFtcGxlIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcih7IGV4dGVuc2lvbnM6IFsuLi5dIH0pXHJcbiAqL1xyXG5jb25zdCB1c2VFZGl0b3IgPSAob3B0aW9ucyA9IHt9LCBkZXBzID0gW10pID0+IHtcclxuICAgIGNvbnN0IGVkaXRvclJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHt9KTtcclxuICAgIGNvbnN0IHsgb25CZWZvcmVDcmVhdGUsIG9uQmx1ciwgb25DcmVhdGUsIG9uRGVzdHJveSwgb25Gb2N1cywgb25TZWxlY3Rpb25VcGRhdGUsIG9uVHJhbnNhY3Rpb24sIG9uVXBkYXRlLCB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IG9uQmVmb3JlQ3JlYXRlUmVmID0gdXNlUmVmKG9uQmVmb3JlQ3JlYXRlKTtcclxuICAgIGNvbnN0IG9uQmx1clJlZiA9IHVzZVJlZihvbkJsdXIpO1xyXG4gICAgY29uc3Qgb25DcmVhdGVSZWYgPSB1c2VSZWYob25DcmVhdGUpO1xyXG4gICAgY29uc3Qgb25EZXN0cm95UmVmID0gdXNlUmVmKG9uRGVzdHJveSk7XHJcbiAgICBjb25zdCBvbkZvY3VzUmVmID0gdXNlUmVmKG9uRm9jdXMpO1xyXG4gICAgY29uc3Qgb25TZWxlY3Rpb25VcGRhdGVSZWYgPSB1c2VSZWYob25TZWxlY3Rpb25VcGRhdGUpO1xyXG4gICAgY29uc3Qgb25UcmFuc2FjdGlvblJlZiA9IHVzZVJlZihvblRyYW5zYWN0aW9uKTtcclxuICAgIGNvbnN0IG9uVXBkYXRlUmVmID0gdXNlUmVmKG9uVXBkYXRlKTtcclxuICAgIC8vIFRoaXMgZWZmZWN0IHdpbGwgaGFuZGxlIHVwZGF0aW5nIHRoZSBlZGl0b3IgaW5zdGFuY2VcclxuICAgIC8vIHdoZW4gdGhlIGV2ZW50IGhhbmRsZXJzIGNoYW5nZS5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFlZGl0b3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vZmYoJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vbignYmVmb3JlQ3JlYXRlJywgb25CZWZvcmVDcmVhdGUpO1xyXG4gICAgICAgICAgICBvbkJlZm9yZUNyZWF0ZVJlZi5jdXJyZW50ID0gb25CZWZvcmVDcmVhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbkJsdXIpIHtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub2ZmKCdibHVyJywgb25CbHVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vbignYmx1cicsIG9uQmx1cik7XHJcbiAgICAgICAgICAgIG9uQmx1clJlZi5jdXJyZW50ID0gb25CbHVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25DcmVhdGUpIHtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub2ZmKCdjcmVhdGUnLCBvbkNyZWF0ZVJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub24oJ2NyZWF0ZScsIG9uQ3JlYXRlKTtcclxuICAgICAgICAgICAgb25DcmVhdGVSZWYuY3VycmVudCA9IG9uQ3JlYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGVkaXRvclJlZi5jdXJyZW50Lm9mZignZGVzdHJveScsIG9uRGVzdHJveVJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub24oJ2Rlc3Ryb3knLCBvbkRlc3Ryb3kpO1xyXG4gICAgICAgICAgICBvbkRlc3Ryb3lSZWYuY3VycmVudCA9IG9uRGVzdHJveTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uRm9jdXMpIHtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub2ZmKCdmb2N1cycsIG9uRm9jdXNSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgIGVkaXRvclJlZi5jdXJyZW50Lm9uKCdmb2N1cycsIG9uRm9jdXMpO1xyXG4gICAgICAgICAgICBvbkZvY3VzUmVmLmN1cnJlbnQgPSBvbkZvY3VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25TZWxlY3Rpb25VcGRhdGUpIHtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub2ZmKCdzZWxlY3Rpb25VcGRhdGUnLCBvblNlbGVjdGlvblVwZGF0ZVJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICAgICAgb25TZWxlY3Rpb25VcGRhdGVSZWYuY3VycmVudCA9IG9uU2VsZWN0aW9uVXBkYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25UcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vZmYoJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvblJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgZWRpdG9yUmVmLmN1cnJlbnQub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb25SZWYuY3VycmVudCA9IG9uVHJhbnNhY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvblVwZGF0ZSkge1xyXG4gICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vZmYoJ3VwZGF0ZScsIG9uVXBkYXRlUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vbigndXBkYXRlJywgb25VcGRhdGUpO1xyXG4gICAgICAgICAgICBvblVwZGF0ZVJlZi5jdXJyZW50ID0gb25VcGRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW29uQmVmb3JlQ3JlYXRlLCBvbkJsdXIsIG9uQ3JlYXRlLCBvbkRlc3Ryb3ksIG9uRm9jdXMsIG9uU2VsZWN0aW9uVXBkYXRlLCBvblRyYW5zYWN0aW9uLCBvblVwZGF0ZSwgZWRpdG9yUmVmLmN1cnJlbnRdKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgZWRpdG9yID0gbmV3IEVkaXRvcihvcHRpb25zKTtcclxuICAgICAgICBlZGl0b3JSZWYuY3VycmVudCA9IGVkaXRvcjtcclxuICAgICAgICBlZGl0b3JSZWYuY3VycmVudC5vbigndHJhbnNhY3Rpb24nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoe30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpc01vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZWRpdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgZGVwcyk7XHJcbiAgICByZXR1cm4gZWRpdG9yUmVmLmN1cnJlbnQ7XHJcbn07XG5cbmNvbnN0IEVkaXRvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcclxuICAgIGVkaXRvcjogbnVsbCxcclxufSk7XHJcbmNvbnN0IEVkaXRvckNvbnN1bWVyID0gRWRpdG9yQ29udGV4dC5Db25zdW1lcjtcclxuY29uc3QgdXNlQ3VycmVudEVkaXRvciA9ICgpID0+IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XHJcbmNvbnN0IEVkaXRvclByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIHNsb3RBZnRlciwgc2xvdEJlZm9yZSwgLi4uZWRpdG9yT3B0aW9ucyB9KSA9PiB7XHJcbiAgICBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoZWRpdG9yT3B0aW9ucyk7XHJcbiAgICBpZiAoIWVkaXRvcikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgZWRpdG9yIH0gfSxcclxuICAgICAgICBzbG90QmVmb3JlLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29uc3VtZXIsIG51bGwsICh7IGVkaXRvcjogY3VycmVudEVkaXRvciB9KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0b3JDb250ZW50LCB7IGVkaXRvcjogY3VycmVudEVkaXRvciB9KSkpLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIHNsb3RBZnRlcikpO1xyXG59O1xuXG5jb25zdCBCdWJibGVNZW51ID0gKHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCBbZWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0gPSB1c2VDdXJyZW50RWRpdG9yKCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IHByb3BzLmVkaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRGVzdHJveWVkKSB8fCAoY3VycmVudEVkaXRvciA9PT0gbnVsbCB8fCBjdXJyZW50RWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RWRpdG9yLmlzRGVzdHJveWVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgcGx1Z2luS2V5ID0gJ2J1YmJsZU1lbnUnLCBlZGl0b3IsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcclxuICAgICAgICBjb25zdCBtZW51RWRpdG9yID0gZWRpdG9yIHx8IGN1cnJlbnRFZGl0b3I7XHJcbiAgICAgICAgaWYgKCFtZW51RWRpdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQnViYmxlTWVudSBjb21wb25lbnQgaXMgbm90IHJlbmRlcmVkIGluc2lkZSBvZiBhbiBlZGl0b3IgY29tcG9uZW50IG9yIGRvZXMgbm90IGhhdmUgZWRpdG9yIHByb3AuJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGx1Z2luID0gQnViYmxlTWVudVBsdWdpbih7XHJcbiAgICAgICAgICAgIHVwZGF0ZURlbGF5LFxyXG4gICAgICAgICAgICBlZGl0b3I6IG1lbnVFZGl0b3IsXHJcbiAgICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICAgIHBsdWdpbktleSxcclxuICAgICAgICAgICAgc2hvdWxkU2hvdyxcclxuICAgICAgICAgICAgdGlwcHlPcHRpb25zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1lbnVFZGl0b3IucmVnaXN0ZXJQbHVnaW4ocGx1Z2luKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gbWVudUVkaXRvci51bnJlZ2lzdGVyUGx1Z2luKHBsdWdpbktleSk7XHJcbiAgICB9LCBbcHJvcHMuZWRpdG9yLCBjdXJyZW50RWRpdG9yLCBlbGVtZW50XSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHNldEVsZW1lbnQsIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XHJcbn07XG5cbmNvbnN0IEZsb2F0aW5nTWVudSA9IChwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB7IGVkaXRvcjogY3VycmVudEVkaXRvciB9ID0gdXNlQ3VycmVudEVkaXRvcigpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2EgPSBwcm9wcy5lZGl0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rlc3Ryb3llZCkgfHwgKGN1cnJlbnRFZGl0b3IgPT09IG51bGwgfHwgY3VycmVudEVkaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHBsdWdpbktleSA9ICdmbG9hdGluZ01lbnUnLCBlZGl0b3IsIHRpcHB5T3B0aW9ucyA9IHt9LCBzaG91bGRTaG93ID0gbnVsbCwgfSA9IHByb3BzO1xyXG4gICAgICAgIGNvbnN0IG1lbnVFZGl0b3IgPSBlZGl0b3IgfHwgY3VycmVudEVkaXRvcjtcclxuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZ01lbnUgY29tcG9uZW50IGlzIG5vdCByZW5kZXJlZCBpbnNpZGUgb2YgYW4gZWRpdG9yIGNvbXBvbmVudCBvciBkb2VzIG5vdCBoYXZlIGVkaXRvciBwcm9wLicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IEZsb2F0aW5nTWVudVBsdWdpbih7XHJcbiAgICAgICAgICAgIHBsdWdpbktleSxcclxuICAgICAgICAgICAgZWRpdG9yOiBtZW51RWRpdG9yLFxyXG4gICAgICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgICAgICB0aXBweU9wdGlvbnMsXHJcbiAgICAgICAgICAgIHNob3VsZFNob3csXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWVudUVkaXRvci5yZWdpc3RlclBsdWdpbihwbHVnaW4pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBtZW51RWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luS2V5KTtcclxuICAgIH0sIFtcclxuICAgICAgICBwcm9wcy5lZGl0b3IsXHJcbiAgICAgICAgY3VycmVudEVkaXRvcixcclxuICAgICAgICBlbGVtZW50LFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHNldEVsZW1lbnQsIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XHJcbn07XG5cbmNvbnN0IFJlYWN0Tm9kZVZpZXdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XHJcbiAgICBvbkRyYWdTdGFydDogdW5kZWZpbmVkLFxyXG59KTtcclxuY29uc3QgdXNlUmVhY3ROb2RlVmlldyA9ICgpID0+IHVzZUNvbnRleHQoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG5jb25zdCBOb2RlVmlld0NvbnRlbnQgPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCBUYWcgPSBwcm9wcy5hcyB8fCAnZGl2JztcclxuICAgIGNvbnN0IHsgbm9kZVZpZXdDb250ZW50UmVmIH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCB7IC4uLnByb3BzLCByZWY6IG5vZGVWaWV3Q29udGVudFJlZiwgXCJkYXRhLW5vZGUtdmlldy1jb250ZW50XCI6IFwiXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXHJcbiAgICAgICAgICAgIC4uLnByb3BzLnN0eWxlLFxyXG4gICAgICAgIH0gfSkpO1xyXG59O1xuXG5jb25zdCBOb2RlVmlld1dyYXBwZXIgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XHJcbiAgICBjb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XHJcbiAgICBjb25zdCBUYWcgPSBwcm9wcy5hcyB8fCAnZGl2JztcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHsgLi4ucHJvcHMsIHJlZjogcmVmLCBcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIjogXCJcIiwgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LCBzdHlsZToge1xyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm9ybWFsJyxcclxuICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXHJcbiAgICAgICAgfSB9KSk7XHJcbn0pO1xuXG4vKipcclxuICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgYSBjbGFzcyBjb21wb25lbnQuXHJcbiAqIEBwYXJhbSBDb21wb25lbnRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuICEhKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAmJiBDb21wb25lbnQucHJvdG90eXBlXHJcbiAgICAgICAgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgYSBmb3J3YXJkIHJlZiBjb21wb25lbnQuXHJcbiAqIEBwYXJhbSBDb21wb25lbnRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcG9uZW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCdcclxuICAgICAgICAmJiAoKF9hID0gQ29tcG9uZW50LiQkdHlwZW9mKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgPT09ICdTeW1ib2wocmVhY3QuZm9yd2FyZF9yZWYpJyk7XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBSZWFjdFJlbmRlcmVyIGNsYXNzLiBJdCdzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyBpbnNpZGUgdGhlIGVkaXRvci5cclxuICogQGV4YW1wbGVcclxuICogbmV3IFJlYWN0UmVuZGVyZXIoTXlDb21wb25lbnQsIHtcclxuICogICBlZGl0b3IsXHJcbiAqICAgcHJvcHM6IHtcclxuICogICAgIGZvbzogJ2JhcicsXHJcbiAqICAgfSxcclxuICogICBhczogJ3NwYW4nLFxyXG4gKiB9KVxyXG4qL1xyXG5jbGFzcyBSZWFjdFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gJ2RpdicsIGNsYXNzTmFtZSA9ICcnLCBhdHRycywgfSkge1xyXG4gICAgICAgIHRoaXMucmVmID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhGRkZGRkZGRikudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhcyk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3JlYWN0LXJlbmRlcmVyJyk7XHJcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWUuc3BsaXQoJyAnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdHRycykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICBpZiAoaXNDbGFzc0NvbXBvbmVudChDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnJlZiA9IChyZWYpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmID0gcmVmO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlYWN0RWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IC4uLnByb3BzIH0pO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZWRpdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudENvbXBvbmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFJlbmRlcmVyKHRoaXMuaWQsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJvcHMocHJvcHMgPSB7fSkge1xyXG4gICAgICAgIHRoaXMucHJvcHMgPSB7XHJcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcHMsXHJcbiAgICAgICAgICAgIC4uLnByb3BzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVkaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnRDb21wb25lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmVSZW5kZXJlcih0aGlzLmlkKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSZWFjdE5vZGVWaWV3IGV4dGVuZHMgTm9kZVZpZXcge1xyXG4gICAgbW91bnQoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgIG5vZGU6IHRoaXMubm9kZSxcclxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiB0aGlzLmV4dGVuc2lvbixcclxuICAgICAgICAgICAgZ2V0UG9zOiAoKSA9PiB0aGlzLmdldFBvcygpLFxyXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cmlidXRlcyA9IHt9KSA9PiB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXHJcbiAgICAgICAgICAgIGRlbGV0ZU5vZGU6ICgpID0+IHRoaXMuZGVsZXRlTm9kZSgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5kaXNwbGF5TmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXBpdGFsaXplRmlyc3RDaGFyID0gKHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lID0gY2FwaXRhbGl6ZUZpcnN0Q2hhcih0aGlzLmV4dGVuc2lvbi5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgUmVhY3ROb2RlVmlld1Byb3ZpZGVyID0gY29tcG9uZW50UHJvcHMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgY29uc3Qgb25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3Q29udGVudFJlZiA9IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGhpcy5jb250ZW50RE9NRWxlbWVudCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IHRoaXMuY29udGVudERPTUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IG9uRHJhZ1N0YXJ0LCBub2RlVmlld0NvbnRlbnRSZWYgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IC4uLmNvbXBvbmVudFByb3BzIH0pKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3ROb2RlVmlld1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gJ1JlYWN0Tm9kZVZpZXcnO1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29udGVudERPTUVsZW1lbnRUYWcpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnRET01FbGVtZW50VGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubm9kZS5pc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIHRoZSB3aGl0ZVNwYWNlIHByb3AgaXMgbm90IGluaGVyaXRlZCBwcm9wZXJseSBpbiBDaHJvbWUgYW5kIFNhZmFyaVxyXG4gICAgICAgICAgICAvLyBXaXRoIHRoaXMgZml4IGl0IHNlZW1zIHRvIHdvcmsgZmluZVxyXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTE5N1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnaW5oZXJpdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhcyA9IHRoaXMubm9kZS5pc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXMpIHtcclxuICAgICAgICAgICAgYXMgPSB0aGlzLm9wdGlvbnMuYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gJycgfSA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSA9IHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoUmVhY3ROb2RlVmlld1Byb3ZpZGVyLCB7XHJcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgIHByb3BzLFxyXG4gICAgICAgICAgICBhcyxcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBgbm9kZS0ke3RoaXMubm9kZS50eXBlLm5hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpLFxyXG4gICAgICAgICAgICBhdHRyczogdGhpcy5vcHRpb25zLmF0dHJzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRvbSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZFxyXG4gICAgICAgICAgICAmJiAhKChfYSA9IHRoaXMucmVuZGVyZXIuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc0F0dHJpYnV0ZSgnZGF0YS1ub2RlLXZpZXctd3JhcHBlcicpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGVudERPTSgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVTZWxlY3Rpb25VcGRhdGUoKSB7XHJcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuZ2V0UG9zKCkgJiYgdG8gPj0gdGhpcy5nZXRQb3MoKSArIHRoaXMubm9kZS5ub2RlU2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5wcm9wcy5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE5vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB1cGRhdGVQcm9wcyA9IChwcm9wcykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHByb3BzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZERlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBvbGROb2RlLFxyXG4gICAgICAgICAgICAgICAgb2xkRGVjb3JhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgbmV3RGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHM6ICgpID0+IHVwZGF0ZVByb3BzKHsgbm9kZSwgZGVjb3JhdGlvbnMgfSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5ub2RlICYmIHRoaXMuZGVjb3JhdGlvbnMgPT09IGRlY29yYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcclxuICAgICAgICB1cGRhdGVQcm9wcyh7IG5vZGUsIGRlY29yYXRpb25zIH0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2VsZWN0Tm9kZSgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScpO1xyXG4gICAgfVxyXG4gICAgZGVzZWxlY3ROb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoe1xyXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBSZWFjdE5vZGVWaWV3UmVuZGVyZXIoY29tcG9uZW50LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gKHByb3BzKSA9PiB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcGFyZW50IGNvbXBvbmVudFxyXG4gICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IGZvciB2dWUgZGV2dG9vbHMgdG8gc2hvdyB0aGUgY29tcG9uZW50IGhpZXJhcmNoeSBjb3JyZWN0bHlcclxuICAgICAgICAvLyBtYXliZSBpdOKAmXMgYHVuZGVmaW5lZGAgYmVjYXVzZSA8ZWRpdG9yLWNvbnRlbnQ+IGlzbuKAmXQgcmVuZGVyZWQgeWV0XHJcbiAgICAgICAgaWYgKCFwcm9wcy5lZGl0b3IuY29udGVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVhY3ROb2RlVmlldyhjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcclxuICAgIH07XHJcbn1cblxuZXhwb3J0IHsgQnViYmxlTWVudSwgRWRpdG9yLCBFZGl0b3JDb25zdW1lciwgRWRpdG9yQ29udGVudCwgRWRpdG9yQ29udGV4dCwgRWRpdG9yUHJvdmlkZXIsIEZsb2F0aW5nTWVudSwgTm9kZVZpZXdDb250ZW50LCBOb2RlVmlld1dyYXBwZXIsIFB1cmVFZGl0b3JDb250ZW50LCBSZWFjdE5vZGVWaWV3Q29udGV4dCwgUmVhY3ROb2RlVmlld1JlbmRlcmVyLCBSZWFjdFJlbmRlcmVyLCB1c2VDdXJyZW50RWRpdG9yLCB1c2VFZGl0b3IsIHVzZVJlYWN0Tm9kZVZpZXcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJ1YmJsZU1lbnVQbHVnaW4iLCJSZWFjdCIsImZvcndhcmRSZWYiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiUmVhY3RET00iLCJmbHVzaFN5bmMiLCJFZGl0b3IiLCJFZGl0b3IkMSIsIk5vZGVWaWV3IiwiRmxvYXRpbmdNZW51UGx1Z2luIiwibWVyZ2VSZWZzIiwicmVmcyIsIm5vZGUiLCJmb3JFYWNoIiwicmVmIiwiY3VycmVudCIsIlBvcnRhbHMiLCJyZW5kZXJlcnMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwia2V5IiwicmVuZGVyZXIiLCJjcmVhdGVQb3J0YWwiLCJyZWFjdEVsZW1lbnQiLCJlbGVtZW50IiwiUHVyZUVkaXRvckNvbnRlbnQiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiZWRpdG9yQ29udGVudFJlZiIsImNyZWF0ZVJlZiIsImluaXRpYWxpemVkIiwic3RhdGUiLCJjb21wb25lbnREaWRNb3VudCIsImluaXQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJlZGl0b3IiLCJvcHRpb25zIiwiY29udGVudENvbXBvbmVudCIsImFwcGVuZCIsImNoaWxkTm9kZXMiLCJzZXRPcHRpb25zIiwiY3JlYXRlTm9kZVZpZXdzIiwibWF5YmVGbHVzaFN5bmMiLCJmbiIsInNldFJlbmRlcmVyIiwiaWQiLCJzZXRTdGF0ZSIsInJlbW92ZVJlbmRlcmVyIiwibmV4dFJlbmRlcmVycyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiaXNEZXN0cm95ZWQiLCJ2aWV3Iiwic2V0UHJvcHMiLCJub2RlVmlld3MiLCJmaXJzdENoaWxkIiwibmV3RWxlbWVudCIsImRvY3VtZW50IiwicmVuZGVyIiwiaW5uZXJSZWYiLCJyZXN0IiwiRWRpdG9yQ29udGVudFdpdGhLZXkiLCJ1c2VNZW1vIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJFZGl0b3JDb250ZW50IiwibWVtbyIsImFyZ3VtZW50cyIsInVzZUVkaXRvciIsImRlcHMiLCJlZGl0b3JSZWYiLCJmb3JjZVVwZGF0ZSIsIm9uQmVmb3JlQ3JlYXRlIiwib25CbHVyIiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbkZvY3VzIiwib25TZWxlY3Rpb25VcGRhdGUiLCJvblRyYW5zYWN0aW9uIiwib25VcGRhdGUiLCJvbkJlZm9yZUNyZWF0ZVJlZiIsIm9uQmx1clJlZiIsIm9uQ3JlYXRlUmVmIiwib25EZXN0cm95UmVmIiwib25Gb2N1c1JlZiIsIm9uU2VsZWN0aW9uVXBkYXRlUmVmIiwib25UcmFuc2FjdGlvblJlZiIsIm9uVXBkYXRlUmVmIiwib2ZmIiwib24iLCJpc01vdW50ZWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkZXN0cm95IiwiRWRpdG9yQ29udGV4dCIsIkVkaXRvckNvbnN1bWVyIiwiQ29uc3VtZXIiLCJ1c2VDdXJyZW50RWRpdG9yIiwiRWRpdG9yUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNsb3RBZnRlciIsInNsb3RCZWZvcmUiLCJlZGl0b3JPcHRpb25zIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImN1cnJlbnRFZGl0b3IiLCJCdWJibGVNZW51Iiwic2V0RWxlbWVudCIsIl9hIiwicGx1Z2luS2V5IiwidGlwcHlPcHRpb25zIiwidXBkYXRlRGVsYXkiLCJzaG91bGRTaG93IiwibWVudUVkaXRvciIsImNvbnNvbGUiLCJ3YXJuIiwicGx1Z2luIiwicmVnaXN0ZXJQbHVnaW4iLCJ1bnJlZ2lzdGVyUGx1Z2luIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiRmxvYXRpbmdNZW51IiwiUmVhY3ROb2RlVmlld0NvbnRleHQiLCJvbkRyYWdTdGFydCIsInVuZGVmaW5lZCIsInVzZVJlYWN0Tm9kZVZpZXciLCJOb2RlVmlld0NvbnRlbnQiLCJUYWciLCJhcyIsIm5vZGVWaWV3Q29udGVudFJlZiIsIndoaXRlU3BhY2UiLCJOb2RlVmlld1dyYXBwZXIiLCJpc0NsYXNzQ29tcG9uZW50IiwicHJvdG90eXBlIiwiaXNSZWFjdENvbXBvbmVudCIsImlzRm9yd2FyZFJlZkNvbXBvbmVudCIsIiQkdHlwZW9mIiwiUmVhY3RSZW5kZXJlciIsImNvbXBvbmVudCIsImF0dHJzIiwiY2xhc3NMaXN0IiwiYWRkIiwic3BsaXQiLCJrZXlzIiwic2V0QXR0cmlidXRlIiwiX2IiLCJ1cGRhdGVQcm9wcyIsIlJlYWN0Tm9kZVZpZXciLCJtb3VudCIsImRlY29yYXRpb25zIiwic2VsZWN0ZWQiLCJleHRlbnNpb24iLCJnZXRQb3MiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImRlbGV0ZU5vZGUiLCJkaXNwbGF5TmFtZSIsImNhcGl0YWxpemVGaXJzdENoYXIiLCJzdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0cmluZyIsIm5hbWUiLCJSZWFjdE5vZGVWaWV3UHJvdmlkZXIiLCJjb21wb25lbnRQcm9wcyIsImJpbmQiLCJjb250ZW50RE9NRWxlbWVudCIsImFwcGVuZENoaWxkIiwiaXNMZWFmIiwiY29udGVudERPTUVsZW1lbnRUYWciLCJpc0lubGluZSIsImhhbmRsZVNlbGVjdGlvblVwZGF0ZSIsInR5cGUiLCJ0cmltIiwiZG9tIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJoYXNBdHRyaWJ1dGUiLCJFcnJvciIsImNvbnRlbnRET00iLCJmcm9tIiwidG8iLCJzZWxlY3Rpb24iLCJub2RlU2l6ZSIsInNlbGVjdE5vZGUiLCJkZXNlbGVjdE5vZGUiLCJ1cGRhdGUiLCJvbGROb2RlIiwib2xkRGVjb3JhdGlvbnMiLCJuZXdOb2RlIiwibmV3RGVjb3JhdGlvbnMiLCJyZW1vdmUiLCJSZWFjdE5vZGVWaWV3UmVuZGVyZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ StarterKit)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ \"(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ \"(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\");\n/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ \"(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * The starter kit is a collection of essential editor extensions.\r\n *\r\n * It’s a good starting point for building your own editor.\r\n */ const StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({\n    name: \"starterKit\",\n    addExtensions () {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n        const extensions = [];\n        if (this.options.blockquote !== false) {\n            extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));\n        }\n        if (this.options.bold !== false) {\n            extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));\n        }\n        if (this.options.bulletList !== false) {\n            extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));\n        }\n        if (this.options.code !== false) {\n            extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));\n        }\n        if (this.options.codeBlock !== false) {\n            extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));\n        }\n        if (this.options.document !== false) {\n            extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));\n        }\n        if (this.options.dropcursor !== false) {\n            extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));\n        }\n        if (this.options.gapcursor !== false) {\n            extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));\n        }\n        if (this.options.hardBreak !== false) {\n            extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));\n        }\n        if (this.options.heading !== false) {\n            extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));\n        }\n        if (this.options.history !== false) {\n            extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));\n        }\n        if (this.options.horizontalRule !== false) {\n            extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));\n        }\n        if (this.options.italic !== false) {\n            extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));\n        }\n        if (this.options.listItem !== false) {\n            extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));\n        }\n        if (this.options.orderedList !== false) {\n            extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));\n        }\n        if (this.options.paragraph !== false) {\n            extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));\n        }\n        if (this.options.strike !== false) {\n            extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));\n        }\n        if (this.options.text !== false) {\n            extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));\n        }\n        return extensions;\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNpQjtBQUNaO0FBQ2E7QUFDYjtBQUNXO0FBQ0g7QUFDSTtBQUNGO0FBQ0M7QUFDTDtBQUNBO0FBQ2U7QUFDakI7QUFDSztBQUNNO0FBQ0w7QUFDTjtBQUNKO0FBRTlDOzs7O0NBSUMsR0FDRCxNQUFNbUIsYUFBYW5CLG9EQUFTQSxDQUFDb0IsTUFBTSxDQUFDO0lBQ2hDQyxNQUFNO0lBQ05DO1FBQ0ksSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDeEUsTUFBTUMsYUFBYSxFQUFFO1FBQ3JCLElBQUksSUFBSSxDQUFDQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxPQUFPO1lBQ25DRixXQUFXRyxJQUFJLENBQUMzQyxvRUFBVUEsQ0FBQzRDLFNBQVMsQ0FBQyxDQUFDdEIsS0FBSyxJQUFJLENBQUNtQixPQUFPLE1BQU0sUUFBUW5CLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR29CLFVBQVU7UUFDL0c7UUFDQSxJQUFJLElBQUksQ0FBQ0QsT0FBTyxDQUFDSSxJQUFJLEtBQUssT0FBTztZQUM3QkwsV0FBV0csSUFBSSxDQUFDMUMsd0RBQUlBLENBQUMyQyxTQUFTLENBQUMsQ0FBQ3JCLEtBQUssSUFBSSxDQUFDa0IsT0FBTyxNQUFNLFFBQVFsQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzQixJQUFJO1FBQ25HO1FBQ0EsSUFBSSxJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssVUFBVSxLQUFLLE9BQU87WUFDbkNOLFdBQVdHLElBQUksQ0FBQ3pDLHFFQUFVQSxDQUFDMEMsU0FBUyxDQUFDLENBQUNwQixLQUFLLElBQUksQ0FB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LE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHc0IsSUFBSTtRQUNuRztRQUNBLE9BQU9yQjtJQUNYO0FBQ0o7QUFFNkMsQ0FDN0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3RhcnRlci1raXQvZGlzdC9pbmRleC5qcz85ZGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBCbG9ja3F1b3RlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZSc7XG5pbXBvcnQgeyBCb2xkIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYm9sZCc7XG5pbXBvcnQgeyBCdWxsZXRMaXN0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QnO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUnO1xuaW1wb3J0IHsgQ29kZUJsb2NrIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jayc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50JztcbmltcG9ydCB7IERyb3BjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yJztcbmltcG9ydCB7IEdhcGN1cnNvciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvcic7XG5pbXBvcnQgeyBIYXJkQnJlYWsgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrJztcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nJztcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5JztcbmltcG9ydCB7IEhvcml6b250YWxSdWxlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlJztcbmltcG9ydCB7IEl0YWxpYyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYyc7XG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbSc7XG5pbXBvcnQgeyBPcmRlcmVkTGlzdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdCc7XG5pbXBvcnQgeyBQYXJhZ3JhcGggfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgnO1xuaW1wb3J0IHsgU3RyaWtlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlJztcbmltcG9ydCB7IFRleHQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi10ZXh0JztcblxuLyoqXHJcbiAqIFRoZSBzdGFydGVyIGtpdCBpcyBhIGNvbGxlY3Rpb24gb2YgZXNzZW50aWFsIGVkaXRvciBleHRlbnNpb25zLlxyXG4gKlxyXG4gKiBJdOKAmXMgYSBnb29kIHN0YXJ0aW5nIHBvaW50IGZvciBidWlsZGluZyB5b3VyIG93biBlZGl0b3IuXHJcbiAqL1xyXG5jb25zdCBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnc3RhcnRlcktpdCcsXHJcbiAgICBhZGRFeHRlbnNpb25zKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90O1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJsb2NrcXVvdGUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChCbG9ja3F1b3RlLmNvbmZpZ3VyZSgoX2EgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ibG9ja3F1b3RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9sZCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJvbGQuY29uZmlndXJlKChfYiA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJvbGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUoKF9jID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYnVsbGV0TGlzdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvZGUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlLmNvbmZpZ3VyZSgoX2QgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZUJsb2NrICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQ29kZUJsb2NrLmNvbmZpZ3VyZSgoX2UgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jb2RlQmxvY2spKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb2N1bWVudCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSgoX2YgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5kb2N1bWVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChEcm9wY3Vyc29yLmNvbmZpZ3VyZSgoX2cgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5kcm9wY3Vyc29yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goR2FwY3Vyc29yLmNvbmZpZ3VyZSgoX2ggPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5nYXBjdXJzb3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXJkQnJlYWsgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKChfaiA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmhhcmRCcmVhaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRpbmcgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChIZWFkaW5nLmNvbmZpZ3VyZSgoX2sgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5oZWFkaW5nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlzdG9yeSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhpc3RvcnkuY29uZmlndXJlKChfbCA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmhpc3RvcnkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3Jpem9udGFsUnVsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSgoX20gPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5ob3Jpem9udGFsUnVsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLml0YWxpYyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEl0YWxpYy5jb25maWd1cmUoKF9vID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28uaXRhbGljKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0SXRlbS5jb25maWd1cmUoKF9wID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3AubGlzdEl0ZW0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSgoX3EgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcS5vcmRlcmVkTGlzdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFncmFwaCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKFBhcmFncmFwaC5jb25maWd1cmUoKF9yID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3IucGFyYWdyYXBoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWtlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goU3RyaWtlLmNvbmZpZ3VyZSgoX3MgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcy5zdHJpa2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUoKF90ID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3QudGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucztcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBTdGFydGVyS2l0LCBTdGFydGVyS2l0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsIkJsb2NrcXVvdGUiLCJCb2xkIiwiQnVsbGV0TGlzdCIsIkNvZGUiLCJDb2RlQmxvY2siLCJEb2N1bWVudCIsIkRyb3BjdXJzb3IiLCJHYXBjdXJzb3IiLCJIYXJkQnJlYWsiLCJIZWFkaW5nIiwiSGlzdG9yeSIsIkhvcml6b250YWxSdWxlIiwiSXRhbGljIiwiTGlzdEl0ZW0iLCJPcmRlcmVkTGlzdCIsIlBhcmFncmFwaCIsIlN0cmlrZSIsIlRleHQiLCJTdGFydGVyS2l0IiwiY3JlYXRlIiwibmFtZSIsImFkZEV4dGVuc2lvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbyIsIl9wIiwiX3EiLCJfciIsIl9zIiwiX3QiLCJleHRlbnNpb25zIiwib3B0aW9ucyIsImJsb2NrcXVvdGUiLCJwdXNoIiwiY29uZmlndXJlIiwiYm9sZCIsImJ1bGxldExpc3QiLCJjb2RlIiwiY29kZUJsb2NrIiwiZG9jdW1lbnQiLCJkcm9wY3Vyc29yIiwiZ2FwY3Vyc29yIiwiaGFyZEJyZWFrIiwiaGVhZGluZyIsImhpc3RvcnkiLCJob3Jpem9udGFsUnVsZSIsIml0YWxpYyIsImxpc3RJdGVtIiwib3JkZXJlZExpc3QiLCJwYXJhZ3JhcGgiLCJzdHJpa2UiLCJ0ZXh0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ })

};
;