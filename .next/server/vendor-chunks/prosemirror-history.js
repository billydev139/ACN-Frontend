"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-history";
exports.ids = ["vendor-chunks/prosemirror-history"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* binding */ closeHistory),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoNoScroll: () => (/* binding */ redoNoScroll),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoNoScroll: () => (/* binding */ undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ \"(ssr)/./node_modules/rope-sequence/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount){\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0) return null;\n        let end = this.items.length;\n        for(;; end--){\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i)=>{\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map) remap.appendMap(map, mapFrom);\n            } else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return {\n            remaining: remaining,\n            transform,\n            selection: selection\n        };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for(let i = 0; i < transform.steps.length; i++){\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i) newItems.pop();\n                else oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems) lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;\n        this.items.forEach((item, i)=>{\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0) return this;\n        return new Branch(this.items.append(array.map((map)=>new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount) return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach((item)=>{\n            if (item.selection) eventCount--;\n        }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach((item)=>{\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null) return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection) eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            } else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for(let i = rebasedCount; i < newUntil; i++)newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach((item)=>{\n            if (!item.step) count++;\n        });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i)=>{\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection) events++;\n            } else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map) remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection) events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem)) items[last] = merged;\n                    else items.push(newItem);\n                }\n            } else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i)=>{\n        if (item.selection && n-- == 0) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(// The (forward) step map for this item.\n    map, // The inverted step\n    step, // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset){\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step) return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition){\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr) return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    } else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);\n        else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    } else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    } else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges) return false;\n    if (!transform.docChanged) return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end)=>{\n        for(let i = 0; i < prevRanges.length; i += 2)if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to)=>result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges) return null;\n    let result = [];\n    for(let i = 0; i < ranges.length; i += 2){\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to) result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop) return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, {\n        redo,\n        historyState: newHist\n    });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for(let i = 0; i < plugins.length; i++)if (plugins[i].spec.historyPreserveItems) {\n            cachedPreserveItems = true;\n            break;\n        }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/ function closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"history\");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/ function history(config = {}) {\n    config = {\n        depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500\n    };\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: historyKey,\n        state: {\n            init () {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply (tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput (view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command) return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch)=>{\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0) return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr) dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/ const undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/ const redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/ const undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/ const redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/ function undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/ function redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ087QUFDTTtBQUV0RCxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YsbUVBQW1FO0FBQ25FLG9FQUFvRTtBQUNwRSxzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLHFCQUFxQjtBQUNyQixFQUFFO0FBQ0YscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkMsTUFBTUksa0JBQWtCO0FBQ3hCLE1BQU1DO0lBQ0ZDLFlBQVlDLEtBQUssRUFBRUMsVUFBVSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtJQUN0QjtJQUNBLDZEQUE2RDtJQUM3RCwyQkFBMkI7SUFDM0JDLFNBQVNDLEtBQUssRUFBRUMsYUFBYSxFQUFFO1FBQzNCLElBQUksSUFBSSxDQUFDSCxVQUFVLElBQUksR0FDbkIsT0FBTztRQUNYLElBQUlJLE1BQU0sSUFBSSxDQUFDTCxLQUFLLENBQUNNLE1BQU07UUFDM0IsT0FBUUQsTUFBTztZQUNYLElBQUlFLE9BQU8sSUFBSSxDQUFDUCxLQUFLLENBQUNRLEdBQUcsQ0FBQ0gsTUFBTTtZQUNoQyxJQUFJRSxLQUFLRSxTQUFTLEVBQUU7Z0JBQ2hCLEVBQUVKO2dCQUNGO1lBQ0o7UUFDSjtRQUNBLElBQUlLLE9BQU9DO1FBQ1gsSUFBSVAsZUFBZTtZQUNmTSxRQUFRLElBQUksQ0FBQ0UsU0FBUyxDQUFDUCxLQUFLLElBQUksQ0FBQ0wsS0FBSyxDQUFDTSxNQUFNO1lBQzdDSyxVQUFVRCxNQUFNRyxJQUFJLENBQUNQLE1BQU07UUFDL0I7UUFDQSxJQUFJUSxZQUFZWCxNQUFNWSxFQUFFO1FBQ3hCLElBQUlOLFdB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QUFJLEVBQUU0QyxNQUFNO0lBQzlCLE9BQU8sQ0FBQzFJLE9BQU93STtRQUNYLElBQUlWLE9BQU9wQyxXQUFXaUQsUUFBUSxDQUFDM0k7UUFDL0IsSUFBSSxDQUFDOEgsUUFBUSxDQUFDaEMsT0FBT2dDLEtBQUs3QyxNQUFNLEdBQUc2QyxLQUFLOUMsSUFBSSxFQUFFbEYsVUFBVSxJQUFJLEdBQ3hELE9BQU87UUFDWCxJQUFJMEksVUFBVTtZQUNWLElBQUk1SCxLQUFLa0csZ0JBQWdCZ0IsTUFBTTlILE9BQU84RjtZQUN0QyxJQUFJbEYsSUFDQTRILFNBQVNFLFNBQVM5SCxHQUFHZ0ksY0FBYyxLQUFLaEk7UUFDaEQ7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBOztBQUVBLEdBQ0EsTUFBTTBILE9BQU9HLGFBQWEsT0FBTztBQUNqQzs7QUFFQSxHQUNBLE1BQU0zQyxPQUFPMkMsYUFBYSxNQUFNO0FBQ2hDOzs7QUFHQSxHQUNBLE1BQU1JLGVBQWVKLGFBQWEsT0FBTztBQUN6Qzs7O0FBR0EsR0FDQSxNQUFNSyxlQUFlTCxhQUFhLE1BQU07QUFDeEM7O0FBRUEsR0FDQSxTQUFTTSxVQUFVL0ksS0FBSztJQUNwQixJQUFJOEgsT0FBT3BDLFdBQVdpRCxRQUFRLENBQUMzSTtJQUMvQixPQUFPOEgsT0FBT0EsS0FBSzlDLElBQUksQ0FBQ2xGLFVBQVUsR0FBRztBQUN6QztBQUNBOztBQUVBLEdBQ0EsU0FBU2tKLFVBQVVoSixLQUFLO0lBQ3BCLElBQUk4SCxPQUFPcEMsV0FBV2lELFFBQVEsQ0FBQzNJO0lBQy9CLE9BQU84SCxPQUFPQSxLQUFLN0MsTUFBTSxDQUFDbkYsVUFBVSxHQUFHO0FBQzNDO0FBRStGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWhpc3RvcnkvZGlzdC9pbmRleC5qcz85ZDk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSb3BlU2VxdWVuY2UgZnJvbSAncm9wZS1zZXF1ZW5jZSc7XG5pbXBvcnQgeyBNYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFBsdWdpbktleSwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBQcm9zZU1pcnJvcidzIGhpc3RvcnkgaXNuJ3Qgc2ltcGx5IGEgd2F5IHRvIHJvbGwgYmFjayB0byBhIHByZXZpb3VzXG4vLyBzdGF0ZSwgYmVjYXVzZSBQcm9zZU1pcnJvciBzdXBwb3J0cyBhcHBseWluZyBjaGFuZ2VzIHdpdGhvdXQgYWRkaW5nXG4vLyB0aGVtIHRvIHRoZSBoaXN0b3J5IChmb3IgZXhhbXBsZSBkdXJpbmcgY29sbGFib3JhdGlvbikuXG4vL1xuLy8gVG8gdGhpcyBlbmQsIGVhY2ggJ0JyYW5jaCcgKG9uZSBmb3IgdGhlIHVuZG8gaGlzdG9yeSBhbmQgb25lIGZvclxuLy8gdGhlIHJlZG8gaGlzdG9yeSkga2VlcHMgYW4gYXJyYXkgb2YgJ0l0ZW1zJywgd2hpY2ggY2FuIG9wdGlvbmFsbHlcbi8vIGhvbGQgYSBzdGVwIChhbiBhY3R1YWwgdW5kb2FibGUgY2hhbmdlKSwgYW5kIGFsd2F5cyBob2xkIGEgcG9zaXRpb25cbi8vIG1hcCAod2hpY2ggaXMgbmVlZGVkIHRvIG1vdmUgY2hhbmdlcyBiZWxvdyB0aGVtIHRvIGFwcGx5IHRvIHRoZVxuLy8gY3VycmVudCBkb2N1bWVudCkuXG4vL1xuLy8gQW4gaXRlbSB0aGF0IGhhcyBib3RoIGEgc3RlcCBhbmQgYSBzZWxlY3Rpb24gYm9va21hcmsgaXMgdGhlIHN0YXJ0XG4vLyBvZiBhbiAnZXZlbnQnIOKAlCBhIGdyb3VwIG9mIGNoYW5nZXMgdGhhdCB3aWxsIGJlIHVuZG9uZSBvciByZWRvbmUgYXRcbi8vIG9uY2UuIChJdCBzdG9yZXMgb25seSB0aGUgYm9va21hcmssIHNpbmNlIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgdG9cbi8vIHByb3ZpZGUgYSBkb2N1bWVudCB1bnRpbCB0aGUgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IGFwcGxpZWQsIHdoaWNoXG4vLyBpcyB1c2VmdWwgd2hlbiBjb21wcmVzc2luZy4pXG4vLyBVc2VkIHRvIHNjaGVkdWxlIGhpc3RvcnkgY29tcHJlc3Npb25cbmNvbnN0IG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcbmNsYXNzIEJyYW5jaCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICAgIH1cbiAgICAvLyBQb3AgdGhlIGxhdGVzdCBldmVudCBvZmYgdGhlIGJyYW5jaCdzIGhpc3RvcnkgYW5kIGFwcGx5IGl0XG4gICAgLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG4gICAgcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7OyBlbmQtLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1hcCwgbWFwRnJvbTtcbiAgICAgICAgaWYgKHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgICBsZXQgc2VsZWN0aW9uLCByZW1haW5pbmc7XG4gICAgICAgIGxldCBhZGRBZnRlciA9IFtdLCBhZGRCZWZvcmUgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFkZEFmdGVyLmxlbmd0aCArIGFkZEJlZm9yZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm1heWJlU3RlcChpdGVtLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcmVtYXAgPyBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpIDogaXRlbS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4geyByZW1haW5pbmc6IHJlbWFpbmluZywgdHJhbnNmb3JtLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbiAgICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdLCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICBsZXQgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLCBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHRyYW5zZm9ybS5zdGVwc1tpXS5pbnZlcnQodHJhbnNmb3JtLmRvY3NbaV0pO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpXG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcbiAgICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKG9sZEl0ZW1zLmFwcGVuZChuZXdJdGVtcyksIGV2ZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IG1hcHMgPSBuZXcgTWFwcGluZztcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbVxuICAgICAgICAgICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfVxuICAgIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuYXBwZW5kKGFycmF5Lm1hcChtYXAgPT4gbmV3IEl0ZW0obWFwKSkpLCB0aGlzLmV2ZW50Q291bnQpO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbiAgICAvLyB0byBrbm93IGFib3V0IHRob3NlLCBzbyB0aGF0IGl0IGNhbiBhZGp1c3QgdGhlIHN0ZXBzIHRoYXQgd2VyZVxuICAgIC8vIHJlYmFzZWQgb24gdG9wIG9mIHRoZSByZW1vdGUgY2hhbmdlcywgYW5kIGluY2x1ZGUgdGhlIHBvc2l0aW9uXG4gICAgLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbiAgICByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRDb3VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmViYXNlZEl0ZW1zID0gW10sIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgICBsZXQgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgICAgICAgbGV0IG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGV2ZW50Q291bnQtLTsgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgaVJlYmFzZWQgPSByZWJhc2VkQ291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICAgICAgbGV0IG1hcCA9IG1hcHBpbmcubWFwc1twb3NdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV3TWFwcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmViYXNlZENvdW50OyBpIDwgbmV3VW50aWw7IGkrKylcbiAgICAgICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgICBsZXQgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICAgIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIH1cbiAgICBlbXB0eUl0ZW1Db3VudCgpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoIWl0ZW0uc3RlcClcbiAgICAgICAgICAgIGNvdW50Kys7IH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4gICAgLy8gaXRlbXMpIG91dC4gRHVyaW5nIGNvbGxhYm9yYXRpb24sIHRoZXNlIG5hdHVyYWxseSBhY2N1bXVsYXRlXG4gICAgLy8gYmVjYXVzZSBlYWNoIHJlbW90ZSBjaGFuZ2UgYWRkcyBvbmUuIFRoZSBgdXB0b2AgYXJndW1lbnQgaXMgdXNlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4gICAgLy8gYmVjYXVzZSBgcmViYXNlZGAgcmVsaWVzIG9uIGEgY2xlYW4sIHVudG91Y2hlZCBzZXQgb2YgaXRlbXMgaW5cbiAgICAvLyBvcmRlciB0byBhc3NvY2lhdGUgb2xkIGl0ZW1zIHdpdGggcmViYXNlZCBzdGVwcy5cbiAgICBjb21wcmVzcyh1cHRvID0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zID0gW10sIGV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgSXRlbShtYXAuaW52ZXJ0KCksIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZCwgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tsYXN0XSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbn1cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICAgIGxldCBjdXRQb2ludDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICAgICAgICBjdXRQb2ludCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuY2xhc3MgSXRlbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIChmb3J3YXJkKSBzdGVwIG1hcCBmb3IgdGhpcyBpdGVtLlxuICAgIG1hcCwgXG4gICAgLy8gVGhlIGludmVydGVkIHN0ZXBcbiAgICBzdGVwLCBcbiAgICAvLyBJZiB0aGlzIGlzIG5vbi1udWxsLCB0aGlzIGl0ZW0gaXMgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAsIGFuZFxuICAgIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAgIC8vIHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdGhlIGZpcnN0IHN0ZXAgd2FzIGFwcGxpZWQpXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvLyBJZiB0aGlzIGl0ZW0gaXMgdGhlIGludmVyc2Ugb2YgYSBwcmV2aW91cyBtYXBwaW5nIG9uIHRoZSBzdGFjayxcbiAgICAvLyB0aGlzIHBvaW50cyBhdCB0aGUgaW52ZXJzZSdzIG9mZnNldFxuICAgIG1pcnJvck9mZnNldCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGVwICYmIG90aGVyLnN0ZXAgJiYgIW90aGVyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSwgcHJldkNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldkNvbXBvc2l0aW9uID0gcHJldkNvbXBvc2l0aW9uO1xuICAgIH1cbn1cbmNvbnN0IERFUFRIX09WRVJGTE9XID0gMjA7XG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICAgIGxldCBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLCByZWJhc2VkO1xuICAgIGlmIChoaXN0b3J5VHIpXG4gICAgICAgIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICAgIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpXG4gICAgICAgIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDAsIC0xKTtcbiAgICBsZXQgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkpIHtcbiAgICAgICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICAgICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHRyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8XG4gICAgICAgICAgICAoIWFwcGVuZGVkICYmIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uICE9IGNvbXBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgKGhpc3RvcnkucHJldlRpbWUgPCAodHIudGltZSB8fCAwKSAtIG9wdGlvbnMubmV3R3JvdXBEZWxheSB8fCAhaXNBZGphY2VudFRvKHRyLCBoaXN0b3J5LnByZXZSYW5nZXMpKSk7XG4gICAgICAgIGxldCBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBuZXdHcm91cCA/IHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpIDogdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBCcmFuY2guZW1wdHksIHByZXZSYW5nZXMsIHRyLnRpbWUsIGNvbXBvc2l0aW9uID09IG51bGwgPyBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGNvbGxhYiBtb2R1bGUgdG8gdGVsbCB0aGUgaGlzdG9yeSB0aGF0IHNvbWUgb2YgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0FkamFjZW50VG8odHJhbnNmb3JtLCBwcmV2UmFuZ2VzKSB7XG4gICAgaWYgKCFwcmV2UmFuZ2VzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFkamFjZW50ID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJhbmdlcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkamFjZW50O1xufVxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgZnJvbSwgdG8pID0+IHJlc3VsdC5wdXNoKGZyb20sIHRvKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlcyhyYW5nZXMsIG1hcHBpbmcpIHtcbiAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSwgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgICAgIGlmIChmcm9tIDw9IHRvKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbHkgdGhlIGxhdGVzdCBldmVudCBmcm9tIG9uZSBicmFuY2ggdG8gdGhlIGRvY3VtZW50IGFuZCBzaGlmdCB0aGUgZXZlbnRcbi8vIG9udG8gdGhlIG90aGVyIGJyYW5jaC5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgcmVkbykge1xuICAgIGxldCBwcmVzZXJ2ZUl0ZW1zID0gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpO1xuICAgIGxldCBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgICBsZXQgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICAgIGlmICghcG9wKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2VsZWN0aW9uID0gcG9wLnNlbGVjdGlvbi5yZXNvbHZlKHBvcC50cmFuc2Zvcm0uZG9jKTtcbiAgICBsZXQgYWRkZWQgPSAocmVkbyA/IGhpc3RvcnkuZG9uZSA6IGhpc3RvcnkudW5kb25lKS5hZGRUcmFuc2Zvcm0ocG9wLnRyYW5zZm9ybSwgc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCksIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBsZXQgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCwgLTEpO1xuICAgIHJldHVybiBwb3AudHJhbnNmb3JtLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNldE1ldGEoaGlzdG9yeUtleSwgeyByZWRvLCBoaXN0b3J5U3RhdGU6IG5ld0hpc3QgfSk7XG59XG5sZXQgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlLCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG4vLyBDaGVjayB3aGV0aGVyIGFueSBwbHVnaW4gaW4gdGhlIGdpdmVuIHN0YXRlIGhhcyBhXG4vLyBgaGlzdG9yeVByZXNlcnZlSXRlbXNgIHByb3BlcnR5IGluIGl0cyBzcGVjLCBpbiB3aGljaCBjYXNlIHdlIG11c3Rcbi8vIHByZXNlcnZlIHN0ZXBzIGV4YWN0bHkgYXMgdGhleSBjYW1lIGluLCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4vLyByZWJhc2VkLlxuZnVuY3Rpb24gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpIHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFByZXNlcnZlSXRlbXM7XG59XG4vKipcblNldCBhIGZsYWcgb24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgc3RlcHNcbmZyb20gYmVpbmcgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgaGlzdG9yeSBldmVudCAoc28gdGhhdCB0aGV5XG5yZXF1aXJlIGEgc2VwYXJhdGUgdW5kbyBjb21tYW5kIHRvIHVuZG8pLlxuKi9cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICAgIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5jb25zdCBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG5jb25zdCBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiY2xvc2VIaXN0b3J5XCIpO1xuLyoqXG5SZXR1cm5zIGEgcGx1Z2luIHRoYXQgZW5hYmxlcyB0aGUgdW5kbyBoaXN0b3J5IGZvciBhbiBlZGl0b3IuIFRoZVxucGx1Z2luIHdpbGwgdHJhY2sgdW5kbyBhbmQgcmVkbyBzdGFja3MsIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlXG5bYHVuZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKSBhbmQgW2ByZWRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkucmVkbykgY29tbWFuZHMuXG5cbllvdSBjYW4gc2V0IGFuIGBcImFkZFRvSGlzdG9yeVwiYCBbbWV0YWRhdGFcbnByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0TWV0YSkgb2YgYGZhbHNlYCBvbiBhIHRyYW5zYWN0aW9uXG50byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcm9sbGVkIGJhY2sgYnkgdW5kby5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnID0geyBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwIH07XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IGhpc3RvcnlLZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKEJyYW5jaC5lbXB0eSwgQnJhbmNoLmVtcHR5LCBudWxsLCAwLCAtMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIGhpc3QsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRDb21tYW5kKHJlZG8sIHNjcm9sbCkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIGlmICghaGlzdCB8fCAocmVkbyA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lKS5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCByZWRvKTtcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzY3JvbGwgPyB0ci5zY3JvbGxJbnRvVmlldygpIDogdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHVuZG9lcyB0aGUgbGFzdCBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCB1bmRvID0gYnVpbGRDb21tYW5kKGZhbHNlLCB0cnVlKTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCByZWRvID0gYnVpbGRDb21tYW5kKHRydWUsIHRydWUpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLiBEb24ndCBzY3JvbGwgdGhlXG5zZWxlY3Rpb24gaW50byB2aWV3LlxuKi9cbmNvbnN0IHVuZG9Ob1Njcm9sbCA9IGJ1aWxkQ29tbWFuZChmYWxzZSwgZmFsc2UpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZS4gRG9uJ3RcbnNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlldy5cbiovXG5jb25zdCByZWRvTm9TY3JvbGwgPSBidWlsZENvbW1hbmQodHJ1ZSwgZmFsc2UpO1xuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnQgeyBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgcmVkb05vU2Nyb2xsLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9Ob1Njcm9sbCB9O1xuIl0sIm5hbWVzIjpbIlJvcGVTZXF1ZW5jZSIsIk1hcHBpbmciLCJQbHVnaW5LZXkiLCJQbHVnaW4iLCJtYXhfZW1wdHlfaXRlbXMiLCJCcmFuY2giLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwiZXZlbnRDb3VudCIsInBvcEV2ZW50Iiwic3RhdGUiLCJwcmVzZXJ2ZUl0ZW1zIiwiZW5kIiwibGVuZ3RoIiwibmV4dCIsImdldCIsInNlbGVjdGlvbiIsInJlbWFwIiwibWFwRnJvbSIsInJlbWFwcGluZyIsIm1hcHMiLCJ0cmFuc2Zvcm0iLCJ0ciIsInJlbWFpbmluZyIsImFkZEFmdGVyIiwiYWRkQmVmb3JlIiwiZm9yRWFjaCIsIml0ZW0iLCJpIiwic3RlcCIsInB1c2giLCJJdGVtIiwibWFwIiwic2xpY2UiLCJtYXliZVN0ZXAiLCJkb2MiLCJtYXBwaW5nIiwidW5kZWZpbmVkIiwiYXBwZW5kTWFwIiwiYXBwZW5kIiwicmV2ZXJzZSIsImNvbmNhdCIsImFkZFRyYW5zZm9ybSIsImhpc3RPcHRpb25zIiwibmV3SXRlbXMiLCJvbGRJdGVtcyIsImxhc3RJdGVtIiwic3RlcHMiLCJpbnZlcnQiLCJkb2NzIiwibWVyZ2VkIiwibWVyZ2UiLCJwb3AiLCJvdmVyZmxvdyIsImRlcHRoIiwiREVQVEhfT1ZFUkZMT1ciLCJjdXRPZmZFdmVudHMiLCJmcm9tIiwidG8iLCJtaXJyb3JQb3MiLCJtaXJyb3JPZmZzZXQiLCJhZGRNYXBzIiwiYXJyYXkiLCJyZWJhc2VkIiwicmViYXNlZFRyYW5zZm9ybSIsInJlYmFzZWRDb3VudCIsInJlYmFzZWRJdGVtcyIsInN0YXJ0IiwiTWF0aCIsIm1heCIsIm5ld1VudGlsIiwiaVJlYmFzZWQiLCJwb3MiLCJnZXRNaXJyb3IiLCJtaW4iLCJuZXdNYXBzIiwiYnJhbmNoIiwiZW1wdHlJdGVtQ291bnQiLCJjb21wcmVzcyIsImNvdW50IiwidXB0byIsImV2ZW50cyIsImdldE1hcCIsIm5ld0l0ZW0iLCJsYXN0IiwiZW1wdHkiLCJuIiwiY3V0UG9pbnQiLCJvdGhlciIsIkhpc3RvcnlTdGF0ZSIsImRvbmUiLCJ1bmRvbmUiLCJwcmV2UmFuZ2VzIiwicHJldlRpbWUiLCJwcmV2Q29tcG9zaXRpb24iLCJhcHBseVRyYW5zYWN0aW9uIiwiaGlzdG9yeSIsIm9wdGlvbnMiLCJoaXN0b3J5VHIiLCJnZXRNZXRhIiwiaGlzdG9yeUtleSIsImhpc3RvcnlTdGF0ZSIsImNsb3NlSGlzdG9yeUtleSIsImFwcGVuZGVkIiwicmVkbyIsIm11c3RQcmVzZXJ2ZUl0ZW1zIiwicmFuZ2VzRm9yIiwiY29tcG9zaXRpb24iLCJuZXdHcm91cCIsInRpbWUiLCJuZXdHcm91cERlbGF5IiwiaXNBZGphY2VudFRvIiwibWFwUmFuZ2VzIiwiZ2V0Qm9va21hcmsiLCJkb2NDaGFuZ2VkIiwiYWRqYWNlbnQiLCJyZXN1bHQiLCJfZnJvbSIsIl90byIsInJhbmdlcyIsImhpc3RUcmFuc2FjdGlvbiIsInNwZWMiLCJjb25maWciLCJyZXNvbHZlIiwiYWRkZWQiLCJuZXdIaXN0Iiwic2V0U2VsZWN0aW9uIiwic2V0TWV0YSIsImNhY2hlZFByZXNlcnZlSXRlbXMiLCJjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyIsInBsdWdpbnMiLCJoaXN0b3J5UHJlc2VydmVJdGVtcyIsImNsb3NlSGlzdG9yeSIsImtleSIsImluaXQiLCJhcHBseSIsImhpc3QiLCJwcm9wcyIsImhhbmRsZURPTUV2ZW50cyIsImJlZm9yZWlucHV0IiwidmlldyIsImUiLCJpbnB1dFR5cGUiLCJjb21tYW5kIiwidW5kbyIsInByZXZlbnREZWZhdWx0IiwiZGlzcGF0Y2giLCJidWlsZENvbW1hbmQiLCJzY3JvbGwiLCJnZXRTdGF0ZSIsInNjcm9sbEludG9WaWV3IiwidW5kb05vU2Nyb2xsIiwicmVkb05vU2Nyb2xsIiwidW5kb0RlcHRoIiwicmVkb0RlcHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-history/dist/index.js\n");

/***/ })

};
;