"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tippy.js";
exports.ids = ["vendor-chunks/tippy.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animateFill: () => (/* binding */ animateFill),\n/* harmony export */   createSingleton: () => (/* binding */ createSingleton),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   delegate: () => (/* binding */ delegate),\n/* harmony export */   followCursor: () => (/* binding */ followCursor),\n/* harmony export */   hideAll: () => (/* binding */ hideAll),\n/* harmony export */   inlinePositioning: () => (/* binding */ inlinePositioning),\n/* harmony export */   roundArrow: () => (/* binding */ ROUND_ARROW),\n/* harmony export */   sticky: () => (/* binding */ sticky)\n/* harmony export */ });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/popper.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/**!\n* tippy.js v6.3.7\n* (c) 2017-2021 atomiks\n* MIT License\n*/ \nvar ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n    passive: true,\n    capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {\n    return document.body;\n};\nfunction hasOwnProperty(obj, key) {\n    return ({}).hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index, defaultValue) {\n    if (Array.isArray(value)) {\n        var v = value[index];\n        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n    }\n    return value;\n}\nfunction isType(value, type) {\n    var str = ({}).toString.call(value);\n    return str.indexOf(\"[object\") === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n    return typeof value === \"function\" ? value.apply(void 0, args) : value;\n}\nfunction debounce(fn, ms) {\n    // Avoid wrapping in `setTimeout` if ms is 0 anyway\n    if (ms === 0) {\n        return fn;\n    }\n    var timeout;\n    return function(arg) {\n        clearTimeout(timeout);\n        timeout = setTimeout(function() {\n            fn(arg);\n        }, ms);\n    };\n}\nfunction removeProperties(obj, keys) {\n    var clone = Object.assign({}, obj);\n    keys.forEach(function(key) {\n        delete clone[key];\n    });\n    return clone;\n}\nfunction splitBySpaces(value) {\n    return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n    return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n    if (arr.indexOf(value) === -1) {\n        arr.push(value);\n    }\n}\nfunction unique(arr) {\n    return arr.filter(function(item, index) {\n        return arr.indexOf(item) === index;\n    });\n}\nfunction getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction arrayFrom(value) {\n    return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n    return Object.keys(obj).reduce(function(acc, key) {\n        if (obj[key] !== undefined) {\n            acc[key] = obj[key];\n        }\n        return acc;\n    }, {});\n}\nfunction div() {\n    return document.createElement(\"div\");\n}\nfunction isElement(value) {\n    return [\n        \"Element\",\n        \"Fragment\"\n    ].some(function(type) {\n        return isType(value, type);\n    });\n}\nfunction isNodeList(value) {\n    return isType(value, \"NodeList\");\n}\nfunction isMouseEvent(value) {\n    return isType(value, \"MouseEvent\");\n}\nfunction isReferenceElement(value) {\n    return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n    if (isElement(value)) {\n        return [\n            value\n        ];\n    }\n    if (isNodeList(value)) {\n        return arrayFrom(value);\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n    els.forEach(function(el) {\n        if (el) {\n            el.style.transitionDuration = value + \"ms\";\n        }\n    });\n}\nfunction setVisibilityState(els, state) {\n    els.forEach(function(el) {\n        if (el) {\n            el.setAttribute(\"data-state\", state);\n        }\n    });\n}\nfunction getOwnerDocument(elementOrElements) {\n    var _element$ownerDocumen;\n    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body\n    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n    var clientX = event.clientX, clientY = event.clientY;\n    return popperTreeData.every(function(_ref) {\n        var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;\n        var interactiveBorder = props.interactiveBorder;\n        var basePlacement = getBasePlacement(popperState.placement);\n        var offsetData = popperState.modifiersData.offset;\n        if (!offsetData) {\n            return true;\n        }\n        var topDistance = basePlacement === \"bottom\" ? offsetData.top.y : 0;\n        var bottomDistance = basePlacement === \"top\" ? offsetData.bottom.y : 0;\n        var leftDistance = basePlacement === \"right\" ? offsetData.left.x : 0;\n        var rightDistance = basePlacement === \"left\" ? offsetData.right.x : 0;\n        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n    });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n    var method = action + \"EventListener\"; // some browsers apparently support `transition` (unprefixed) but only fire\n    // `webkitTransitionEnd`...\n    [\n        \"transitionend\",\n        \"webkitTransitionEnd\"\n    ].forEach(function(event) {\n        box[method](event, listener);\n    });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */ function actualContains(parent, child) {\n    var target = child;\n    while(target){\n        var _target$getRootNode;\n        if (parent.contains(target)) {\n            return true;\n        }\n        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n    }\n    return false;\n}\nvar currentInput = {\n    isTouch: false\n};\nvar lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */ function onDocumentTouchStart() {\n    if (currentInput.isTouch) {\n        return;\n    }\n    currentInput.isTouch = true;\n    if (window.performance) {\n        document.addEventListener(\"mousemove\", onDocumentMouseMove);\n    }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */ function onDocumentMouseMove() {\n    var now = performance.now();\n    if (now - lastMouseMoveTime < 20) {\n        currentInput.isTouch = false;\n        document.removeEventListener(\"mousemove\", onDocumentMouseMove);\n    }\n    lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */ function onWindowBlur() {\n    var activeElement = document.activeElement;\n    if (isReferenceElement(activeElement)) {\n        var instance = activeElement._tippy;\n        if (activeElement.blur && !instance.state.isVisible) {\n            activeElement.blur();\n        }\n    }\n}\nfunction bindGlobalEventListeners() {\n    document.addEventListener(\"touchstart\", onDocumentTouchStart, TOUCH_OPTIONS);\n    window.addEventListener(\"blur\", onWindowBlur);\n}\nvar isBrowser =  false && 0;\nvar isIE11 = isBrowser ? !!window.msCrypto : false;\nfunction createMemoryLeakWarning(method) {\n    var txt = method === \"destroy\" ? \"n already-\" : \" \";\n    return [\n        method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\",\n        \"indicates a potential memory leak.\"\n    ].join(\" \");\n}\nfunction clean(value) {\n    var spacesAndTabs = /[ \\t]{2,}/g;\n    var lineStartWithSpaces = /^[ \\t]*/gm;\n    return value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\n}\nfunction getDevMessage(message) {\n    return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77‍ This is a development-only message. It will be removed in production.\\n  \");\n}\nfunction getFormattedMessage(message) {\n    return [\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.3em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #a6a095;\"\n    ];\n} // Assume warnings and errors never have the same message\nvar visitedMessages;\nif (true) {\n    resetVisitedMessages();\n}\nfunction resetVisitedMessages() {\n    visitedMessages = new Set();\n}\nfunction warnWhen(condition, message) {\n    if (condition && !visitedMessages.has(message)) {\n        var _console;\n        visitedMessages.add(message);\n        (_console = console).warn.apply(_console, getFormattedMessage(message));\n    }\n}\nfunction errorWhen(condition, message) {\n    if (condition && !visitedMessages.has(message)) {\n        var _console2;\n        visitedMessages.add(message);\n        (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n    }\n}\nfunction validateTargets(targets) {\n    var didPassFalsyValue = !targets;\n    var didPassPlainObject = Object.prototype.toString.call(targets) === \"[object Object]\" && !targets.addEventListener;\n    errorWhen(didPassFalsyValue, [\n        \"tippy() was passed\",\n        \"`\" + String(targets) + \"`\",\n        \"as its targets (first) argument. Valid types are: String, Element,\",\n        \"Element[], or NodeList.\"\n    ].join(\" \"));\n    errorWhen(didPassPlainObject, [\n        \"tippy() was passed a plain object which is not supported as an argument\",\n        \"for virtual positioning. Use props.getReferenceClientRect instead.\"\n    ].join(\" \"));\n}\nvar pluginProps = {\n    animateFill: false,\n    followCursor: false,\n    inlinePositioning: false,\n    sticky: false\n};\nvar renderProps = {\n    allowHTML: false,\n    animation: \"fade\",\n    arrow: true,\n    content: \"\",\n    inertia: false,\n    maxWidth: 350,\n    role: \"tooltip\",\n    theme: \"\",\n    zIndex: 9999\n};\nvar defaultProps = Object.assign({\n    appendTo: TIPPY_DEFAULT_APPEND_TO,\n    aria: {\n        content: \"auto\",\n        expanded: \"auto\"\n    },\n    delay: 0,\n    duration: [\n        300,\n        250\n    ],\n    getReferenceClientRect: null,\n    hideOnClick: true,\n    ignoreAttributes: false,\n    interactive: false,\n    interactiveBorder: 2,\n    interactiveDebounce: 0,\n    moveTransition: \"\",\n    offset: [\n        0,\n        10\n    ],\n    onAfterUpdate: function onAfterUpdate() {},\n    onBeforeUpdate: function onBeforeUpdate() {},\n    onCreate: function onCreate() {},\n    onDestroy: function onDestroy() {},\n    onHidden: function onHidden() {},\n    onHide: function onHide() {},\n    onMount: function onMount() {},\n    onShow: function onShow() {},\n    onShown: function onShown() {},\n    onTrigger: function onTrigger() {},\n    onUntrigger: function onUntrigger() {},\n    onClickOutside: function onClickOutside() {},\n    placement: \"top\",\n    plugins: [],\n    popperOptions: {},\n    render: null,\n    showOnCreate: false,\n    touch: true,\n    trigger: \"mouseenter focus\",\n    triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps(partialProps) {\n    /* istanbul ignore else */ if (true) {\n        validateProps(partialProps, []);\n    }\n    var keys = Object.keys(partialProps);\n    keys.forEach(function(key) {\n        defaultProps[key] = partialProps[key];\n    });\n};\nfunction getExtendedPassedProps(passedProps) {\n    var plugins = passedProps.plugins || [];\n    var pluginProps = plugins.reduce(function(acc, plugin) {\n        var name = plugin.name, defaultValue = plugin.defaultValue;\n        if (name) {\n            var _name;\n            acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n        }\n        return acc;\n    }, {});\n    return Object.assign({}, passedProps, pluginProps);\n}\nfunction getDataAttributeProps(reference, plugins) {\n    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n        plugins: plugins\n    }))) : defaultKeys;\n    var props = propKeys.reduce(function(acc, key) {\n        var valueAsString = (reference.getAttribute(\"data-tippy-\" + key) || \"\").trim();\n        if (!valueAsString) {\n            return acc;\n        }\n        if (key === \"content\") {\n            acc[key] = valueAsString;\n        } else {\n            try {\n                acc[key] = JSON.parse(valueAsString);\n            } catch (e) {\n                acc[key] = valueAsString;\n            }\n        }\n        return acc;\n    }, {});\n    return props;\n}\nfunction evaluateProps(reference, props) {\n    var out = Object.assign({}, props, {\n        content: invokeWithArgsOrReturn(props.content, [\n            reference\n        ])\n    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));\n    out.aria = Object.assign({}, defaultProps.aria, out.aria);\n    out.aria = {\n        expanded: out.aria.expanded === \"auto\" ? props.interactive : out.aria.expanded,\n        content: out.aria.content === \"auto\" ? props.interactive ? null : \"describedby\" : out.aria.content\n    };\n    return out;\n}\nfunction validateProps(partialProps, plugins) {\n    if (partialProps === void 0) {\n        partialProps = {};\n    }\n    if (plugins === void 0) {\n        plugins = [];\n    }\n    var keys = Object.keys(partialProps);\n    keys.forEach(function(prop) {\n        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`\n        if (didPassUnknownProp) {\n            didPassUnknownProp = plugins.filter(function(plugin) {\n                return plugin.name === prop;\n            }).length === 0;\n        }\n        warnWhen(didPassUnknownProp, [\n            \"`\" + prop + \"`\",\n            \"is not a valid prop. You may have spelled it incorrectly, or if it's\",\n            \"a plugin, forgot to pass it in an array as props.plugins.\",\n            \"\\n\\n\",\n            \"All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n\",\n            \"Plugins: https://atomiks.github.io/tippyjs/v6/plugins/\"\n        ].join(\" \"));\n    });\n}\nvar innerHTML = function innerHTML() {\n    return \"innerHTML\";\n};\nfunction dangerouslySetInnerHTML(element, html) {\n    element[innerHTML()] = html;\n}\nfunction createArrowElement(value) {\n    var arrow = div();\n    if (value === true) {\n        arrow.className = ARROW_CLASS;\n    } else {\n        arrow.className = SVG_ARROW_CLASS;\n        if (isElement(value)) {\n            arrow.appendChild(value);\n        } else {\n            dangerouslySetInnerHTML(arrow, value);\n        }\n    }\n    return arrow;\n}\nfunction setContent(content, props) {\n    if (isElement(props.content)) {\n        dangerouslySetInnerHTML(content, \"\");\n        content.appendChild(props.content);\n    } else if (typeof props.content !== \"function\") {\n        if (props.allowHTML) {\n            dangerouslySetInnerHTML(content, props.content);\n        } else {\n            content.textContent = props.content;\n        }\n    }\n}\nfunction getChildren(popper) {\n    var box = popper.firstElementChild;\n    var boxChildren = arrayFrom(box.children);\n    return {\n        box: box,\n        content: boxChildren.find(function(node) {\n            return node.classList.contains(CONTENT_CLASS);\n        }),\n        arrow: boxChildren.find(function(node) {\n            return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n        }),\n        backdrop: boxChildren.find(function(node) {\n            return node.classList.contains(BACKDROP_CLASS);\n        })\n    };\n}\nfunction render(instance) {\n    var popper = div();\n    var box = div();\n    box.className = BOX_CLASS;\n    box.setAttribute(\"data-state\", \"hidden\");\n    box.setAttribute(\"tabindex\", \"-1\");\n    var content = div();\n    content.className = CONTENT_CLASS;\n    content.setAttribute(\"data-state\", \"hidden\");\n    setContent(content, instance.props);\n    popper.appendChild(box);\n    box.appendChild(content);\n    onUpdate(instance.props, instance.props);\n    function onUpdate(prevProps, nextProps) {\n        var _getChildren = getChildren(popper), box = _getChildren.box, content = _getChildren.content, arrow = _getChildren.arrow;\n        if (nextProps.theme) {\n            box.setAttribute(\"data-theme\", nextProps.theme);\n        } else {\n            box.removeAttribute(\"data-theme\");\n        }\n        if (typeof nextProps.animation === \"string\") {\n            box.setAttribute(\"data-animation\", nextProps.animation);\n        } else {\n            box.removeAttribute(\"data-animation\");\n        }\n        if (nextProps.inertia) {\n            box.setAttribute(\"data-inertia\", \"\");\n        } else {\n            box.removeAttribute(\"data-inertia\");\n        }\n        box.style.maxWidth = typeof nextProps.maxWidth === \"number\" ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n        if (nextProps.role) {\n            box.setAttribute(\"role\", nextProps.role);\n        } else {\n            box.removeAttribute(\"role\");\n        }\n        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n            setContent(content, instance.props);\n        }\n        if (nextProps.arrow) {\n            if (!arrow) {\n                box.appendChild(createArrowElement(nextProps.arrow));\n            } else if (prevProps.arrow !== nextProps.arrow) {\n                box.removeChild(arrow);\n                box.appendChild(createArrowElement(nextProps.arrow));\n            }\n        } else if (arrow) {\n            box.removeChild(arrow);\n        }\n    }\n    return {\n        popper: popper,\n        onUpdate: onUpdate\n    };\n} // Runtime check to identify if the render function is the default one; this\n// way we can apply default CSS transitions logic and it can be tree-shaken away\nrender.$$tippy = true;\nvar idCounter = 1;\nvar mouseMoveListeners = []; // Used by `hideAll()`\nvar mountedInstances = [];\nfunction createTippy(reference, passedProps) {\n    var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================\n    // 🔒 Private members\n    // ===========================================================================\n    var showTimeout;\n    var hideTimeout;\n    var scheduleHideAnimationFrame;\n    var isVisibleFromClick = false;\n    var didHideDueToDocumentMouseDown = false;\n    var didTouchMove = false;\n    var ignoreOnFirstUpdate = false;\n    var lastTriggerEvent;\n    var currentTransitionEndListener;\n    var onFirstUpdate;\n    var listeners = [];\n    var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n    var currentTarget; // ===========================================================================\n    // 🔑 Public members\n    // ===========================================================================\n    var id = idCounter++;\n    var popperInstance = null;\n    var plugins = unique(props.plugins);\n    var state = {\n        // Is the instance currently enabled?\n        isEnabled: true,\n        // Is the tippy currently showing and not transitioning out?\n        isVisible: false,\n        // Has the instance been destroyed?\n        isDestroyed: false,\n        // Is the tippy currently mounted to the DOM?\n        isMounted: false,\n        // Has the tippy finished transitioning in?\n        isShown: false\n    };\n    var instance = {\n        // properties\n        id: id,\n        reference: reference,\n        popper: div(),\n        popperInstance: popperInstance,\n        props: props,\n        state: state,\n        plugins: plugins,\n        // methods\n        clearDelayTimeouts: clearDelayTimeouts,\n        setProps: setProps,\n        setContent: setContent,\n        show: show,\n        hide: hide,\n        hideWithInteractivity: hideWithInteractivity,\n        enable: enable,\n        disable: disable,\n        unmount: unmount,\n        destroy: destroy\n    }; // TODO: Investigate why this early return causes a TDZ error in the tests —\n    // it doesn't seem to happen in the browser\n    /* istanbul ignore if */ if (!props.render) {\n        if (true) {\n            errorWhen(true, \"render() function has not been supplied.\");\n        }\n        return instance;\n    } // ===========================================================================\n    // Initial mutations\n    // ===========================================================================\n    var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;\n    popper.setAttribute(\"data-tippy-root\", \"\");\n    popper.id = \"tippy-\" + instance.id;\n    instance.popper = popper;\n    reference._tippy = instance;\n    popper._tippy = instance;\n    var pluginsHooks = plugins.map(function(plugin) {\n        return plugin.fn(instance);\n    });\n    var hasAriaExpanded = reference.hasAttribute(\"aria-expanded\");\n    addListeners();\n    handleAriaExpandedAttribute();\n    handleStyles();\n    invokeHook(\"onCreate\", [\n        instance\n    ]);\n    if (props.showOnCreate) {\n        scheduleShow();\n    } // Prevent a tippy with a delay from hiding if the cursor left then returned\n    // before it started hiding\n    popper.addEventListener(\"mouseenter\", function() {\n        if (instance.props.interactive && instance.state.isVisible) {\n            instance.clearDelayTimeouts();\n        }\n    });\n    popper.addEventListener(\"mouseleave\", function() {\n        if (instance.props.interactive && instance.props.trigger.indexOf(\"mouseenter\") >= 0) {\n            getDocument().addEventListener(\"mousemove\", debouncedOnMouseMove);\n        }\n    });\n    return instance; // ===========================================================================\n    // 🔒 Private methods\n    // ===========================================================================\n    function getNormalizedTouchSettings() {\n        var touch = instance.props.touch;\n        return Array.isArray(touch) ? touch : [\n            touch,\n            0\n        ];\n    }\n    function getIsCustomTouchBehavior() {\n        return getNormalizedTouchSettings()[0] === \"hold\";\n    }\n    function getIsDefaultRenderFn() {\n        var _instance$props$rende;\n        // @ts-ignore\n        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n    }\n    function getCurrentTarget() {\n        return currentTarget || reference;\n    }\n    function getDocument() {\n        var parent = getCurrentTarget().parentNode;\n        return parent ? getOwnerDocument(parent) : document;\n    }\n    function getDefaultTemplateChildren() {\n        return getChildren(popper);\n    }\n    function getDelay(isShow) {\n        // For touch or keyboard input, force `0` delay for UX reasons\n        // Also if the instance is mounted but not visible (transitioning out),\n        // ignore delay\n        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === \"focus\") {\n            return 0;\n        }\n        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n    }\n    function handleStyles(fromHide) {\n        if (fromHide === void 0) {\n            fromHide = false;\n        }\n        popper.style.pointerEvents = instance.props.interactive && !fromHide ? \"\" : \"none\";\n        popper.style.zIndex = \"\" + instance.props.zIndex;\n    }\n    function invokeHook(hook, args, shouldInvokePropsHook) {\n        if (shouldInvokePropsHook === void 0) {\n            shouldInvokePropsHook = true;\n        }\n        pluginsHooks.forEach(function(pluginHooks) {\n            if (pluginHooks[hook]) {\n                pluginHooks[hook].apply(pluginHooks, args);\n            }\n        });\n        if (shouldInvokePropsHook) {\n            var _instance$props;\n            (_instance$props = instance.props)[hook].apply(_instance$props, args);\n        }\n    }\n    function handleAriaContentAttribute() {\n        var aria = instance.props.aria;\n        if (!aria.content) {\n            return;\n        }\n        var attr = \"aria-\" + aria.content;\n        var id = popper.id;\n        var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n        nodes.forEach(function(node) {\n            var currentValue = node.getAttribute(attr);\n            if (instance.state.isVisible) {\n                node.setAttribute(attr, currentValue ? currentValue + \" \" + id : id);\n            } else {\n                var nextValue = currentValue && currentValue.replace(id, \"\").trim();\n                if (nextValue) {\n                    node.setAttribute(attr, nextValue);\n                } else {\n                    node.removeAttribute(attr);\n                }\n            }\n        });\n    }\n    function handleAriaExpandedAttribute() {\n        if (hasAriaExpanded || !instance.props.aria.expanded) {\n            return;\n        }\n        var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n        nodes.forEach(function(node) {\n            if (instance.props.interactive) {\n                node.setAttribute(\"aria-expanded\", instance.state.isVisible && node === getCurrentTarget() ? \"true\" : \"false\");\n            } else {\n                node.removeAttribute(\"aria-expanded\");\n            }\n        });\n    }\n    function cleanupInteractiveMouseListeners() {\n        getDocument().removeEventListener(\"mousemove\", debouncedOnMouseMove);\n        mouseMoveListeners = mouseMoveListeners.filter(function(listener) {\n            return listener !== debouncedOnMouseMove;\n        });\n    }\n    function onDocumentPress(event) {\n        // Moved finger to scroll instead of an intentional tap outside\n        if (currentInput.isTouch) {\n            if (didTouchMove || event.type === \"mousedown\") {\n                return;\n            }\n        }\n        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper\n        if (instance.props.interactive && actualContains(popper, actualTarget)) {\n            return;\n        } // Clicked on the event listeners target\n        if (normalizeToArray(instance.props.triggerTarget || reference).some(function(el) {\n            return actualContains(el, actualTarget);\n        })) {\n            if (currentInput.isTouch) {\n                return;\n            }\n            if (instance.state.isVisible && instance.props.trigger.indexOf(\"click\") >= 0) {\n                return;\n            }\n        } else {\n            invokeHook(\"onClickOutside\", [\n                instance,\n                event\n            ]);\n        }\n        if (instance.props.hideOnClick === true) {\n            instance.clearDelayTimeouts();\n            instance.hide(); // `mousedown` event is fired right before `focus` if pressing the\n            // currentTarget. This lets a tippy with `focus` trigger know that it\n            // should not show\n            didHideDueToDocumentMouseDown = true;\n            setTimeout(function() {\n                didHideDueToDocumentMouseDown = false;\n            }); // The listener gets added in `scheduleShow()`, but this may be hiding it\n            // before it shows, and hide()'s early bail-out behavior can prevent it\n            // from being cleaned up\n            if (!instance.state.isMounted) {\n                removeDocumentPress();\n            }\n        }\n    }\n    function onTouchMove() {\n        didTouchMove = true;\n    }\n    function onTouchStart() {\n        didTouchMove = false;\n    }\n    function addDocumentPress() {\n        var doc = getDocument();\n        doc.addEventListener(\"mousedown\", onDocumentPress, true);\n        doc.addEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n        doc.addEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n        doc.addEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n    }\n    function removeDocumentPress() {\n        var doc = getDocument();\n        doc.removeEventListener(\"mousedown\", onDocumentPress, true);\n        doc.removeEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n        doc.removeEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n        doc.removeEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n    }\n    function onTransitionedOut(duration, callback) {\n        onTransitionEnd(duration, function() {\n            if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n                callback();\n            }\n        });\n    }\n    function onTransitionedIn(duration, callback) {\n        onTransitionEnd(duration, callback);\n    }\n    function onTransitionEnd(duration, callback) {\n        var box = getDefaultTemplateChildren().box;\n        function listener(event) {\n            if (event.target === box) {\n                updateTransitionEndListener(box, \"remove\", listener);\n                callback();\n            }\n        } // Make callback synchronous if duration is 0\n        // `transitionend` won't fire otherwise\n        if (duration === 0) {\n            return callback();\n        }\n        updateTransitionEndListener(box, \"remove\", currentTransitionEndListener);\n        updateTransitionEndListener(box, \"add\", listener);\n        currentTransitionEndListener = listener;\n    }\n    function on(eventType, handler, options) {\n        if (options === void 0) {\n            options = false;\n        }\n        var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n        nodes.forEach(function(node) {\n            node.addEventListener(eventType, handler, options);\n            listeners.push({\n                node: node,\n                eventType: eventType,\n                handler: handler,\n                options: options\n            });\n        });\n    }\n    function addListeners() {\n        if (getIsCustomTouchBehavior()) {\n            on(\"touchstart\", onTrigger, {\n                passive: true\n            });\n            on(\"touchend\", onMouseLeave, {\n                passive: true\n            });\n        }\n        splitBySpaces(instance.props.trigger).forEach(function(eventType) {\n            if (eventType === \"manual\") {\n                return;\n            }\n            on(eventType, onTrigger);\n            switch(eventType){\n                case \"mouseenter\":\n                    on(\"mouseleave\", onMouseLeave);\n                    break;\n                case \"focus\":\n                    on(isIE11 ? \"focusout\" : \"blur\", onBlurOrFocusOut);\n                    break;\n                case \"focusin\":\n                    on(\"focusout\", onBlurOrFocusOut);\n                    break;\n            }\n        });\n    }\n    function removeListeners() {\n        listeners.forEach(function(_ref) {\n            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;\n            node.removeEventListener(eventType, handler, options);\n        });\n        listeners = [];\n    }\n    function onTrigger(event) {\n        var _lastTriggerEvent;\n        var shouldScheduleClickHide = false;\n        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n            return;\n        }\n        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === \"focus\";\n        lastTriggerEvent = event;\n        currentTarget = event.currentTarget;\n        handleAriaExpandedAttribute();\n        if (!instance.state.isVisible && isMouseEvent(event)) {\n            // If scrolling, `mouseenter` events can be fired if the cursor lands\n            // over a new target, but `mousemove` events don't get fired. This\n            // causes interactive tooltips to get stuck open until the cursor is\n            // moved\n            mouseMoveListeners.forEach(function(listener) {\n                return listener(event);\n            });\n        } // Toggle show/hide when clicking click-triggered tooltips\n        if (event.type === \"click\" && (instance.props.trigger.indexOf(\"mouseenter\") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n            shouldScheduleClickHide = true;\n        } else {\n            scheduleShow(event);\n        }\n        if (event.type === \"click\") {\n            isVisibleFromClick = !shouldScheduleClickHide;\n        }\n        if (shouldScheduleClickHide && !wasFocused) {\n            scheduleHide(event);\n        }\n    }\n    function onMouseMove(event) {\n        var target = event.target;\n        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);\n        if (event.type === \"mousemove\" && isCursorOverReferenceOrPopper) {\n            return;\n        }\n        var popperTreeData = getNestedPopperTree().concat(popper).map(function(popper) {\n            var _instance$popperInsta;\n            var instance = popper._tippy;\n            var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n            if (state) {\n                return {\n                    popperRect: popper.getBoundingClientRect(),\n                    popperState: state,\n                    props: props\n                };\n            }\n            return null;\n        }).filter(Boolean);\n        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n            cleanupInteractiveMouseListeners();\n            scheduleHide(event);\n        }\n    }\n    function onMouseLeave(event) {\n        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf(\"click\") >= 0 && isVisibleFromClick;\n        if (shouldBail) {\n            return;\n        }\n        if (instance.props.interactive) {\n            instance.hideWithInteractivity(event);\n            return;\n        }\n        scheduleHide(event);\n    }\n    function onBlurOrFocusOut(event) {\n        if (instance.props.trigger.indexOf(\"focusin\") < 0 && event.target !== getCurrentTarget()) {\n            return;\n        } // If focus was moved to within the popper\n        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n            return;\n        }\n        scheduleHide(event);\n    }\n    function isEventListenerStopped(event) {\n        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf(\"touch\") >= 0 : false;\n    }\n    function createPopperInstance() {\n        destroyPopperInstance();\n        var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;\n        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;\n        var computedReference = getReferenceClientRect ? {\n            getBoundingClientRect: getReferenceClientRect,\n            contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n        } : reference;\n        var tippyModifier = {\n            name: \"$$tippy\",\n            enabled: true,\n            phase: \"beforeWrite\",\n            requires: [\n                \"computeStyles\"\n            ],\n            fn: function fn(_ref2) {\n                var state = _ref2.state;\n                if (getIsDefaultRenderFn()) {\n                    var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;\n                    [\n                        \"placement\",\n                        \"reference-hidden\",\n                        \"escaped\"\n                    ].forEach(function(attr) {\n                        if (attr === \"placement\") {\n                            box.setAttribute(\"data-placement\", state.placement);\n                        } else {\n                            if (state.attributes.popper[\"data-popper-\" + attr]) {\n                                box.setAttribute(\"data-\" + attr, \"\");\n                            } else {\n                                box.removeAttribute(\"data-\" + attr);\n                            }\n                        }\n                    });\n                    state.attributes.popper = {};\n                }\n            }\n        };\n        var modifiers = [\n            {\n                name: \"offset\",\n                options: {\n                    offset: offset\n                }\n            },\n            {\n                name: \"preventOverflow\",\n                options: {\n                    padding: {\n                        top: 2,\n                        bottom: 2,\n                        left: 5,\n                        right: 5\n                    }\n                }\n            },\n            {\n                name: \"flip\",\n                options: {\n                    padding: 5\n                }\n            },\n            {\n                name: \"computeStyles\",\n                options: {\n                    adaptive: !moveTransition\n                }\n            },\n            tippyModifier\n        ];\n        if (getIsDefaultRenderFn() && arrow) {\n            modifiers.push({\n                name: \"arrow\",\n                options: {\n                    element: arrow,\n                    padding: 3\n                }\n            });\n        }\n        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n        instance.popperInstance = (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {\n            placement: placement,\n            onFirstUpdate: onFirstUpdate,\n            modifiers: modifiers\n        }));\n    }\n    function destroyPopperInstance() {\n        if (instance.popperInstance) {\n            instance.popperInstance.destroy();\n            instance.popperInstance = null;\n        }\n    }\n    function mount() {\n        var appendTo = instance.props.appendTo;\n        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so\n        // it's directly after the reference element so the elements inside the\n        // tippy can be tabbed to\n        // If there are clipping issues, the user can specify a different appendTo\n        // and ensure focus management is handled correctly manually\n        var node = getCurrentTarget();\n        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === \"parent\") {\n            parentNode = node.parentNode;\n        } else {\n            parentNode = invokeWithArgsOrReturn(appendTo, [\n                node\n            ]);\n        } // The popper element needs to exist on the DOM before its position can be\n        // updated as Popper needs to read its dimensions\n        if (!parentNode.contains(popper)) {\n            parentNode.appendChild(popper);\n        }\n        instance.state.isMounted = true;\n        createPopperInstance();\n        /* istanbul ignore else */ if (true) {\n            // Accessibility check\n            warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, [\n                \"Interactive tippy element may not be accessible via keyboard\",\n                \"navigation because it is not directly after the reference element\",\n                \"in the DOM source order.\",\n                \"\\n\\n\",\n                \"Using a wrapper <div> or <span> tag around the reference element\",\n                \"solves this by creating a new parentNode context.\",\n                \"\\n\\n\",\n                \"Specifying `appendTo: document.body` silences this warning, but it\",\n                \"assumes you are using a focus management solution to handle\",\n                \"keyboard navigation.\",\n                \"\\n\\n\",\n                \"See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity\"\n            ].join(\" \"));\n        }\n    }\n    function getNestedPopperTree() {\n        return arrayFrom(popper.querySelectorAll(\"[data-tippy-root]\"));\n    }\n    function scheduleShow(event) {\n        instance.clearDelayTimeouts();\n        if (event) {\n            invokeHook(\"onTrigger\", [\n                instance,\n                event\n            ]);\n        }\n        addDocumentPress();\n        var delay = getDelay(true);\n        var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];\n        if (currentInput.isTouch && touchValue === \"hold\" && touchDelay) {\n            delay = touchDelay;\n        }\n        if (delay) {\n            showTimeout = setTimeout(function() {\n                instance.show();\n            }, delay);\n        } else {\n            instance.show();\n        }\n    }\n    function scheduleHide(event) {\n        instance.clearDelayTimeouts();\n        invokeHook(\"onUntrigger\", [\n            instance,\n            event\n        ]);\n        if (!instance.state.isVisible) {\n            removeDocumentPress();\n            return;\n        } // For interactive tippies, scheduleHide is added to a document.body handler\n        // from onMouseLeave so must intercept scheduled hides from mousemove/leave\n        // events when trigger contains mouseenter and click, and the tip is\n        // currently shown as a result of a click.\n        if (instance.props.trigger.indexOf(\"mouseenter\") >= 0 && instance.props.trigger.indexOf(\"click\") >= 0 && [\n            \"mouseleave\",\n            \"mousemove\"\n        ].indexOf(event.type) >= 0 && isVisibleFromClick) {\n            return;\n        }\n        var delay = getDelay(false);\n        if (delay) {\n            hideTimeout = setTimeout(function() {\n                if (instance.state.isVisible) {\n                    instance.hide();\n                }\n            }, delay);\n        } else {\n            // Fixes a `transitionend` problem when it fires 1 frame too\n            // late sometimes, we don't want hide() to be called.\n            scheduleHideAnimationFrame = requestAnimationFrame(function() {\n                instance.hide();\n            });\n        }\n    } // ===========================================================================\n    // 🔑 Public methods\n    // ===========================================================================\n    function enable() {\n        instance.state.isEnabled = true;\n    }\n    function disable() {\n        // Disabling the instance should also hide it\n        // https://github.com/atomiks/tippy.js-react/issues/106\n        instance.hide();\n        instance.state.isEnabled = false;\n    }\n    function clearDelayTimeouts() {\n        clearTimeout(showTimeout);\n        clearTimeout(hideTimeout);\n        cancelAnimationFrame(scheduleHideAnimationFrame);\n    }\n    function setProps(partialProps) {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"setProps\"));\n        }\n        if (instance.state.isDestroyed) {\n            return;\n        }\n        invokeHook(\"onBeforeUpdate\", [\n            instance,\n            partialProps\n        ]);\n        removeListeners();\n        var prevProps = instance.props;\n        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n            ignoreAttributes: true\n        }));\n        instance.props = nextProps;\n        addListeners();\n        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n            cleanupInteractiveMouseListeners();\n            debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);\n        } // Ensure stale aria-expanded attributes are removed\n        if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n            normalizeToArray(prevProps.triggerTarget).forEach(function(node) {\n                node.removeAttribute(\"aria-expanded\");\n            });\n        } else if (nextProps.triggerTarget) {\n            reference.removeAttribute(\"aria-expanded\");\n        }\n        handleAriaExpandedAttribute();\n        handleStyles();\n        if (onUpdate) {\n            onUpdate(prevProps, nextProps);\n        }\n        if (instance.popperInstance) {\n            createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,\n            // and the nested ones get re-rendered first.\n            // https://github.com/atomiks/tippyjs-react/issues/177\n            // TODO: find a cleaner / more efficient solution(!)\n            getNestedPopperTree().forEach(function(nestedPopper) {\n                // React (and other UI libs likely) requires a rAF wrapper as it flushes\n                // its work in one\n                requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n            });\n        }\n        invokeHook(\"onAfterUpdate\", [\n            instance,\n            partialProps\n        ]);\n    }\n    function setContent(content) {\n        instance.setProps({\n            content: content\n        });\n    }\n    function show() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"show\"));\n        } // Early bail-out\n        var isAlreadyVisible = instance.state.isVisible;\n        var isDestroyed = instance.state.isDestroyed;\n        var isDisabled = !instance.state.isEnabled;\n        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n            return;\n        } // Normalize `disabled` behavior across browsers.\n        // Firefox allows events on disabled elements, but Chrome doesn't.\n        // Using a wrapper element (i.e. <span>) is recommended.\n        if (getCurrentTarget().hasAttribute(\"disabled\")) {\n            return;\n        }\n        invokeHook(\"onShow\", [\n            instance\n        ], false);\n        if (instance.props.onShow(instance) === false) {\n            return;\n        }\n        instance.state.isVisible = true;\n        if (getIsDefaultRenderFn()) {\n            popper.style.visibility = \"visible\";\n        }\n        handleStyles();\n        addDocumentPress();\n        if (!instance.state.isMounted) {\n            popper.style.transition = \"none\";\n        } // If flipping to the opposite side after hiding at least once, the\n        // animation will use the wrong placement without resetting the duration\n        if (getIsDefaultRenderFn()) {\n            var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;\n            setTransitionDuration([\n                box,\n                content\n            ], 0);\n        }\n        onFirstUpdate = function onFirstUpdate() {\n            var _instance$popperInsta2;\n            if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n                return;\n            }\n            ignoreOnFirstUpdate = true; // reflow\n            void popper.offsetHeight;\n            popper.style.transition = instance.props.moveTransition;\n            if (getIsDefaultRenderFn() && instance.props.animation) {\n                var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;\n                setTransitionDuration([\n                    _box,\n                    _content\n                ], duration);\n                setVisibilityState([\n                    _box,\n                    _content\n                ], \"visible\");\n            }\n            handleAriaContentAttribute();\n            handleAriaExpandedAttribute();\n            pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the\n            // popper has been positioned for the first time\n            (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n            invokeHook(\"onMount\", [\n                instance\n            ]);\n            if (instance.props.animation && getIsDefaultRenderFn()) {\n                onTransitionedIn(duration, function() {\n                    instance.state.isShown = true;\n                    invokeHook(\"onShown\", [\n                        instance\n                    ]);\n                });\n            }\n        };\n        mount();\n    }\n    function hide() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hide\"));\n        } // Early bail-out\n        var isAlreadyHidden = !instance.state.isVisible;\n        var isDestroyed = instance.state.isDestroyed;\n        var isDisabled = !instance.state.isEnabled;\n        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n        if (isAlreadyHidden || isDestroyed || isDisabled) {\n            return;\n        }\n        invokeHook(\"onHide\", [\n            instance\n        ], false);\n        if (instance.props.onHide(instance) === false) {\n            return;\n        }\n        instance.state.isVisible = false;\n        instance.state.isShown = false;\n        ignoreOnFirstUpdate = false;\n        isVisibleFromClick = false;\n        if (getIsDefaultRenderFn()) {\n            popper.style.visibility = \"hidden\";\n        }\n        cleanupInteractiveMouseListeners();\n        removeDocumentPress();\n        handleStyles(true);\n        if (getIsDefaultRenderFn()) {\n            var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;\n            if (instance.props.animation) {\n                setTransitionDuration([\n                    box,\n                    content\n                ], duration);\n                setVisibilityState([\n                    box,\n                    content\n                ], \"hidden\");\n            }\n        }\n        handleAriaContentAttribute();\n        handleAriaExpandedAttribute();\n        if (instance.props.animation) {\n            if (getIsDefaultRenderFn()) {\n                onTransitionedOut(duration, instance.unmount);\n            }\n        } else {\n            instance.unmount();\n        }\n    }\n    function hideWithInteractivity(event) {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hideWithInteractivity\"));\n        }\n        getDocument().addEventListener(\"mousemove\", debouncedOnMouseMove);\n        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n        debouncedOnMouseMove(event);\n    }\n    function unmount() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"unmount\"));\n        }\n        if (instance.state.isVisible) {\n            instance.hide();\n        }\n        if (!instance.state.isMounted) {\n            return;\n        }\n        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper\n        // tree by default. This seems mainly for interactive tippies, but we should\n        // find a workaround if possible\n        getNestedPopperTree().forEach(function(nestedPopper) {\n            nestedPopper._tippy.unmount();\n        });\n        if (popper.parentNode) {\n            popper.parentNode.removeChild(popper);\n        }\n        mountedInstances = mountedInstances.filter(function(i) {\n            return i !== instance;\n        });\n        instance.state.isMounted = false;\n        invokeHook(\"onHidden\", [\n            instance\n        ]);\n    }\n    function destroy() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"destroy\"));\n        }\n        if (instance.state.isDestroyed) {\n            return;\n        }\n        instance.clearDelayTimeouts();\n        instance.unmount();\n        removeListeners();\n        delete reference._tippy;\n        instance.state.isDestroyed = true;\n        invokeHook(\"onDestroy\", [\n            instance\n        ]);\n    }\n}\nfunction tippy(targets, optionalProps) {\n    if (optionalProps === void 0) {\n        optionalProps = {};\n    }\n    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n    /* istanbul ignore else */ if (true) {\n        validateTargets(targets);\n        validateProps(optionalProps, plugins);\n    }\n    bindGlobalEventListeners();\n    var passedProps = Object.assign({}, optionalProps, {\n        plugins: plugins\n    });\n    var elements = getArrayOfElements(targets);\n    /* istanbul ignore else */ if (true) {\n        var isSingleContentElement = isElement(passedProps.content);\n        var isMoreThanOneReferenceElement = elements.length > 1;\n        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, [\n            \"tippy() was passed an Element as the `content` prop, but more than\",\n            \"one tippy instance was created by this invocation. This means the\",\n            \"content element will only be appended to the last tippy instance.\",\n            \"\\n\\n\",\n            \"Instead, pass the .innerHTML of the element, or use a function that\",\n            \"returns a cloned version of the element instead.\",\n            \"\\n\\n\",\n            \"1) content: element.innerHTML\\n\",\n            \"2) content: () => element.cloneNode(true)\"\n        ].join(\" \"));\n    }\n    var instances = elements.reduce(function(acc, reference) {\n        var instance = reference && createTippy(reference, passedProps);\n        if (instance) {\n            acc.push(instance);\n        }\n        return acc;\n    }, []);\n    return isElement(targets) ? instances[0] : instances;\n}\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar hideAll = function hideAll(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, excludedReferenceOrInstance = _ref.exclude, duration = _ref.duration;\n    mountedInstances.forEach(function(instance) {\n        var isExcluded = false;\n        if (excludedReferenceOrInstance) {\n            isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;\n        }\n        if (!isExcluded) {\n            var originalDuration = instance.props.duration;\n            instance.setProps({\n                duration: duration\n            });\n            instance.hide();\n            if (!instance.state.isDestroyed) {\n                instance.setProps({\n                    duration: originalDuration\n                });\n            }\n        }\n    });\n};\n// every time the popper is destroyed (i.e. a new target), removing the styles\n// and causing transitions to break for singletons when the console is open, but\n// most notably for non-transform styles being used, `gpuAcceleration: false`.\nvar applyStylesModifier = Object.assign({}, _popperjs_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    effect: function effect(_ref) {\n        var state = _ref.state;\n        var initialStyles = {\n            popper: {\n                position: state.options.strategy,\n                left: \"0\",\n                top: \"0\",\n                margin: \"0\"\n            },\n            arrow: {\n                position: \"absolute\"\n            },\n            reference: {}\n        };\n        Object.assign(state.elements.popper.style, initialStyles.popper);\n        state.styles = initialStyles;\n        if (state.elements.arrow) {\n            Object.assign(state.elements.arrow.style, initialStyles.arrow);\n        } // intentionally return no cleanup function\n    // return () => { ... }\n    }\n});\nvar createSingleton = function createSingleton(tippyInstances, optionalProps) {\n    var _optionalProps$popper;\n    if (optionalProps === void 0) {\n        optionalProps = {};\n    }\n    /* istanbul ignore else */ if (true) {\n        errorWhen(!Array.isArray(tippyInstances), [\n            \"The first argument passed to createSingleton() must be an array of\",\n            \"tippy instances. The passed value was\",\n            String(tippyInstances)\n        ].join(\" \"));\n    }\n    var individualInstances = tippyInstances;\n    var references = [];\n    var triggerTargets = [];\n    var currentTarget;\n    var overrides = optionalProps.overrides;\n    var interceptSetPropsCleanups = [];\n    var shownOnCreate = false;\n    function setTriggerTargets() {\n        triggerTargets = individualInstances.map(function(instance) {\n            return normalizeToArray(instance.props.triggerTarget || instance.reference);\n        }).reduce(function(acc, item) {\n            return acc.concat(item);\n        }, []);\n    }\n    function setReferences() {\n        references = individualInstances.map(function(instance) {\n            return instance.reference;\n        });\n    }\n    function enableInstances(isEnabled) {\n        individualInstances.forEach(function(instance) {\n            if (isEnabled) {\n                instance.enable();\n            } else {\n                instance.disable();\n            }\n        });\n    }\n    function interceptSetProps(singleton) {\n        return individualInstances.map(function(instance) {\n            var originalSetProps = instance.setProps;\n            instance.setProps = function(props) {\n                originalSetProps(props);\n                if (instance.reference === currentTarget) {\n                    singleton.setProps(props);\n                }\n            };\n            return function() {\n                instance.setProps = originalSetProps;\n            };\n        });\n    } // have to pass singleton, as it maybe undefined on first call\n    function prepareInstance(singleton, target) {\n        var index = triggerTargets.indexOf(target); // bail-out\n        if (target === currentTarget) {\n            return;\n        }\n        currentTarget = target;\n        var overrideProps = (overrides || []).concat(\"content\").reduce(function(acc, prop) {\n            acc[prop] = individualInstances[index].props[prop];\n            return acc;\n        }, {});\n        singleton.setProps(Object.assign({}, overrideProps, {\n            getReferenceClientRect: typeof overrideProps.getReferenceClientRect === \"function\" ? overrideProps.getReferenceClientRect : function() {\n                var _references$index;\n                return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();\n            }\n        }));\n    }\n    enableInstances(false);\n    setReferences();\n    setTriggerTargets();\n    var plugin = {\n        fn: function fn() {\n            return {\n                onDestroy: function onDestroy() {\n                    enableInstances(true);\n                },\n                onHidden: function onHidden() {\n                    currentTarget = null;\n                },\n                onClickOutside: function onClickOutside(instance) {\n                    if (instance.props.showOnCreate && !shownOnCreate) {\n                        shownOnCreate = true;\n                        currentTarget = null;\n                    }\n                },\n                onShow: function onShow(instance) {\n                    if (instance.props.showOnCreate && !shownOnCreate) {\n                        shownOnCreate = true;\n                        prepareInstance(instance, references[0]);\n                    }\n                },\n                onTrigger: function onTrigger(instance, event) {\n                    prepareInstance(instance, event.currentTarget);\n                }\n            };\n        }\n    };\n    var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, [\n        \"overrides\"\n    ]), {\n        plugins: [\n            plugin\n        ].concat(optionalProps.plugins || []),\n        triggerTarget: triggerTargets,\n        popperOptions: Object.assign({}, optionalProps.popperOptions, {\n            modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [\n                applyStylesModifier\n            ])\n        })\n    }));\n    var originalShow = singleton.show;\n    singleton.show = function(target) {\n        originalShow(); // first time, showOnCreate or programmatic call with no params\n        // default to showing first instance\n        if (!currentTarget && target == null) {\n            return prepareInstance(singleton, references[0]);\n        } // triggered from event (do nothing as prepareInstance already called by onTrigger)\n        // programmatic call with no params when already visible (do nothing again)\n        if (currentTarget && target == null) {\n            return;\n        } // target is index of instance\n        if (typeof target === \"number\") {\n            return references[target] && prepareInstance(singleton, references[target]);\n        } // target is a child tippy instance\n        if (individualInstances.indexOf(target) >= 0) {\n            var ref = target.reference;\n            return prepareInstance(singleton, ref);\n        } // target is a ReferenceElement\n        if (references.indexOf(target) >= 0) {\n            return prepareInstance(singleton, target);\n        }\n    };\n    singleton.showNext = function() {\n        var first = references[0];\n        if (!currentTarget) {\n            return singleton.show(0);\n        }\n        var index = references.indexOf(currentTarget);\n        singleton.show(references[index + 1] || first);\n    };\n    singleton.showPrevious = function() {\n        var last = references[references.length - 1];\n        if (!currentTarget) {\n            return singleton.show(last);\n        }\n        var index = references.indexOf(currentTarget);\n        var target = references[index - 1] || last;\n        singleton.show(target);\n    };\n    var originalSetProps = singleton.setProps;\n    singleton.setProps = function(props) {\n        overrides = props.overrides || overrides;\n        originalSetProps(props);\n    };\n    singleton.setInstances = function(nextInstances) {\n        enableInstances(true);\n        interceptSetPropsCleanups.forEach(function(fn) {\n            return fn();\n        });\n        individualInstances = nextInstances;\n        enableInstances(false);\n        setReferences();\n        setTriggerTargets();\n        interceptSetPropsCleanups = interceptSetProps(singleton);\n        singleton.setProps({\n            triggerTarget: triggerTargets\n        });\n    };\n    interceptSetPropsCleanups = interceptSetProps(singleton);\n    return singleton;\n};\nvar BUBBLING_EVENTS_MAP = {\n    mouseover: \"mouseenter\",\n    focusin: \"focus\",\n    click: \"click\"\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */ function delegate(targets, props) {\n    /* istanbul ignore else */ if (true) {\n        errorWhen(!(props && props.target), [\n            \"You must specity a `target` prop indicating a CSS selector string matching\",\n            \"the target elements that should receive a tippy.\"\n        ].join(\" \"));\n    }\n    var listeners = [];\n    var childTippyInstances = [];\n    var disabled = false;\n    var target = props.target;\n    var nativeProps = removeProperties(props, [\n        \"target\"\n    ]);\n    var parentProps = Object.assign({}, nativeProps, {\n        trigger: \"manual\",\n        touch: false\n    });\n    var childProps = Object.assign({\n        touch: defaultProps.touch\n    }, nativeProps, {\n        showOnCreate: true\n    });\n    var returnValue = tippy(targets, parentProps);\n    var normalizedReturnValue = normalizeToArray(returnValue);\n    function onTrigger(event) {\n        if (!event.target || disabled) {\n            return;\n        }\n        var targetNode = event.target.closest(target);\n        if (!targetNode) {\n            return;\n        } // Get relevant trigger with fallbacks:\n        // 1. Check `data-tippy-trigger` attribute on target node\n        // 2. Fallback to `trigger` passed to `delegate()`\n        // 3. Fallback to `defaultProps.trigger`\n        var trigger = targetNode.getAttribute(\"data-tippy-trigger\") || props.trigger || defaultProps.trigger; // @ts-ignore\n        if (targetNode._tippy) {\n            return;\n        }\n        if (event.type === \"touchstart\" && typeof childProps.touch === \"boolean\") {\n            return;\n        }\n        if (event.type !== \"touchstart\" && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {\n            return;\n        }\n        var instance = tippy(targetNode, childProps);\n        if (instance) {\n            childTippyInstances = childTippyInstances.concat(instance);\n        }\n    }\n    function on(node, eventType, handler, options) {\n        if (options === void 0) {\n            options = false;\n        }\n        node.addEventListener(eventType, handler, options);\n        listeners.push({\n            node: node,\n            eventType: eventType,\n            handler: handler,\n            options: options\n        });\n    }\n    function addEventListeners(instance) {\n        var reference = instance.reference;\n        on(reference, \"touchstart\", onTrigger, TOUCH_OPTIONS);\n        on(reference, \"mouseover\", onTrigger);\n        on(reference, \"focusin\", onTrigger);\n        on(reference, \"click\", onTrigger);\n    }\n    function removeEventListeners() {\n        listeners.forEach(function(_ref) {\n            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;\n            node.removeEventListener(eventType, handler, options);\n        });\n        listeners = [];\n    }\n    function applyMutations(instance) {\n        var originalDestroy = instance.destroy;\n        var originalEnable = instance.enable;\n        var originalDisable = instance.disable;\n        instance.destroy = function(shouldDestroyChildInstances) {\n            if (shouldDestroyChildInstances === void 0) {\n                shouldDestroyChildInstances = true;\n            }\n            if (shouldDestroyChildInstances) {\n                childTippyInstances.forEach(function(instance) {\n                    instance.destroy();\n                });\n            }\n            childTippyInstances = [];\n            removeEventListeners();\n            originalDestroy();\n        };\n        instance.enable = function() {\n            originalEnable();\n            childTippyInstances.forEach(function(instance) {\n                return instance.enable();\n            });\n            disabled = false;\n        };\n        instance.disable = function() {\n            originalDisable();\n            childTippyInstances.forEach(function(instance) {\n                return instance.disable();\n            });\n            disabled = true;\n        };\n        addEventListeners(instance);\n    }\n    normalizedReturnValue.forEach(applyMutations);\n    return returnValue;\n}\nvar animateFill = {\n    name: \"animateFill\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var _instance$props$rende;\n        // @ts-ignore\n        if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {\n            if (true) {\n                errorWhen(instance.props.animateFill, \"The `animateFill` plugin requires the default render function.\");\n            }\n            return {};\n        }\n        var _getChildren = getChildren(instance.popper), box = _getChildren.box, content = _getChildren.content;\n        var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n        return {\n            onCreate: function onCreate() {\n                if (backdrop) {\n                    box.insertBefore(backdrop, box.firstElementChild);\n                    box.setAttribute(\"data-animatefill\", \"\");\n                    box.style.overflow = \"hidden\";\n                    instance.setProps({\n                        arrow: false,\n                        animation: \"shift-away\"\n                    });\n                }\n            },\n            onMount: function onMount() {\n                if (backdrop) {\n                    var transitionDuration = box.style.transitionDuration;\n                    var duration = Number(transitionDuration.replace(\"ms\", \"\")); // The content should fade in after the backdrop has mostly filled the\n                    // tooltip element. `clip-path` is the other alternative but is not\n                    // well-supported and is buggy on some devices.\n                    content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n                    backdrop.style.transitionDuration = transitionDuration;\n                    setVisibilityState([\n                        backdrop\n                    ], \"visible\");\n                }\n            },\n            onShow: function onShow() {\n                if (backdrop) {\n                    backdrop.style.transitionDuration = \"0ms\";\n                }\n            },\n            onHide: function onHide() {\n                if (backdrop) {\n                    setVisibilityState([\n                        backdrop\n                    ], \"hidden\");\n                }\n            }\n        };\n    }\n};\nfunction createBackdropElement() {\n    var backdrop = div();\n    backdrop.className = BACKDROP_CLASS;\n    setVisibilityState([\n        backdrop\n    ], \"hidden\");\n    return backdrop;\n}\nvar mouseCoords = {\n    clientX: 0,\n    clientY: 0\n};\nvar activeInstances = [];\nfunction storeMouseCoords(_ref) {\n    var clientX = _ref.clientX, clientY = _ref.clientY;\n    mouseCoords = {\n        clientX: clientX,\n        clientY: clientY\n    };\n}\nfunction addMouseCoordsListener(doc) {\n    doc.addEventListener(\"mousemove\", storeMouseCoords);\n}\nfunction removeMouseCoordsListener(doc) {\n    doc.removeEventListener(\"mousemove\", storeMouseCoords);\n}\nvar followCursor = {\n    name: \"followCursor\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var reference = instance.reference;\n        var doc = getOwnerDocument(instance.props.triggerTarget || reference);\n        var isInternalUpdate = false;\n        var wasFocusEvent = false;\n        var isUnmounted = true;\n        var prevProps = instance.props;\n        function getIsInitialBehavior() {\n            return instance.props.followCursor === \"initial\" && instance.state.isVisible;\n        }\n        function addListener() {\n            doc.addEventListener(\"mousemove\", onMouseMove);\n        }\n        function removeListener() {\n            doc.removeEventListener(\"mousemove\", onMouseMove);\n        }\n        function unsetGetReferenceClientRect() {\n            isInternalUpdate = true;\n            instance.setProps({\n                getReferenceClientRect: null\n            });\n            isInternalUpdate = false;\n        }\n        function onMouseMove(event) {\n            // If the instance is interactive, avoid updating the position unless it's\n            // over the reference element\n            var isCursorOverReference = event.target ? reference.contains(event.target) : true;\n            var followCursor = instance.props.followCursor;\n            var clientX = event.clientX, clientY = event.clientY;\n            var rect = reference.getBoundingClientRect();\n            var relativeX = clientX - rect.left;\n            var relativeY = clientY - rect.top;\n            if (isCursorOverReference || !instance.props.interactive) {\n                instance.setProps({\n                    // @ts-ignore - unneeded DOMRect properties\n                    getReferenceClientRect: function getReferenceClientRect() {\n                        var rect = reference.getBoundingClientRect();\n                        var x = clientX;\n                        var y = clientY;\n                        if (followCursor === \"initial\") {\n                            x = rect.left + relativeX;\n                            y = rect.top + relativeY;\n                        }\n                        var top = followCursor === \"horizontal\" ? rect.top : y;\n                        var right = followCursor === \"vertical\" ? rect.right : x;\n                        var bottom = followCursor === \"horizontal\" ? rect.bottom : y;\n                        var left = followCursor === \"vertical\" ? rect.left : x;\n                        return {\n                            width: right - left,\n                            height: bottom - top,\n                            top: top,\n                            right: right,\n                            bottom: bottom,\n                            left: left\n                        };\n                    }\n                });\n            }\n        }\n        function create() {\n            if (instance.props.followCursor) {\n                activeInstances.push({\n                    instance: instance,\n                    doc: doc\n                });\n                addMouseCoordsListener(doc);\n            }\n        }\n        function destroy() {\n            activeInstances = activeInstances.filter(function(data) {\n                return data.instance !== instance;\n            });\n            if (activeInstances.filter(function(data) {\n                return data.doc === doc;\n            }).length === 0) {\n                removeMouseCoordsListener(doc);\n            }\n        }\n        return {\n            onCreate: create,\n            onDestroy: destroy,\n            onBeforeUpdate: function onBeforeUpdate() {\n                prevProps = instance.props;\n            },\n            onAfterUpdate: function onAfterUpdate(_, _ref2) {\n                var followCursor = _ref2.followCursor;\n                if (isInternalUpdate) {\n                    return;\n                }\n                if (followCursor !== undefined && prevProps.followCursor !== followCursor) {\n                    destroy();\n                    if (followCursor) {\n                        create();\n                        if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {\n                            addListener();\n                        }\n                    } else {\n                        removeListener();\n                        unsetGetReferenceClientRect();\n                    }\n                }\n            },\n            onMount: function onMount() {\n                if (instance.props.followCursor && !wasFocusEvent) {\n                    if (isUnmounted) {\n                        onMouseMove(mouseCoords);\n                        isUnmounted = false;\n                    }\n                    if (!getIsInitialBehavior()) {\n                        addListener();\n                    }\n                }\n            },\n            onTrigger: function onTrigger(_, event) {\n                if (isMouseEvent(event)) {\n                    mouseCoords = {\n                        clientX: event.clientX,\n                        clientY: event.clientY\n                    };\n                }\n                wasFocusEvent = event.type === \"focus\";\n            },\n            onHidden: function onHidden() {\n                if (instance.props.followCursor) {\n                    unsetGetReferenceClientRect();\n                    removeListener();\n                    isUnmounted = true;\n                }\n            }\n        };\n    }\n};\nfunction getProps(props, modifier) {\n    var _props$popperOptions;\n    return {\n        popperOptions: Object.assign({}, props.popperOptions, {\n            modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function(_ref) {\n                var name = _ref.name;\n                return name !== modifier.name;\n            }), [\n                modifier\n            ])\n        })\n    };\n}\nvar inlinePositioning = {\n    name: \"inlinePositioning\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var reference = instance.reference;\n        function isEnabled() {\n            return !!instance.props.inlinePositioning;\n        }\n        var placement;\n        var cursorRectIndex = -1;\n        var isInternalUpdate = false;\n        var triedPlacements = [];\n        var modifier = {\n            name: \"tippyInlinePositioning\",\n            enabled: true,\n            phase: \"afterWrite\",\n            fn: function fn(_ref2) {\n                var state = _ref2.state;\n                if (isEnabled()) {\n                    if (triedPlacements.indexOf(state.placement) !== -1) {\n                        triedPlacements = [];\n                    }\n                    if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {\n                        triedPlacements.push(state.placement);\n                        instance.setProps({\n                            // @ts-ignore - unneeded DOMRect properties\n                            getReferenceClientRect: function getReferenceClientRect() {\n                                return _getReferenceClientRect(state.placement);\n                            }\n                        });\n                    }\n                    placement = state.placement;\n                }\n            }\n        };\n        function _getReferenceClientRect(placement) {\n            return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);\n        }\n        function setInternalProps(partialProps) {\n            isInternalUpdate = true;\n            instance.setProps(partialProps);\n            isInternalUpdate = false;\n        }\n        function addModifier() {\n            if (!isInternalUpdate) {\n                setInternalProps(getProps(instance.props, modifier));\n            }\n        }\n        return {\n            onCreate: addModifier,\n            onAfterUpdate: addModifier,\n            onTrigger: function onTrigger(_, event) {\n                if (isMouseEvent(event)) {\n                    var rects = arrayFrom(instance.reference.getClientRects());\n                    var cursorRect = rects.find(function(rect) {\n                        return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;\n                    });\n                    var index = rects.indexOf(cursorRect);\n                    cursorRectIndex = index > -1 ? index : cursorRectIndex;\n                }\n            },\n            onHidden: function onHidden() {\n                cursorRectIndex = -1;\n            }\n        };\n    }\n};\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {\n    // Not an inline element, or placement is not yet known\n    if (clientRects.length < 2 || currentBasePlacement === null) {\n        return boundingRect;\n    } // There are two rects and they are disjoined\n    if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {\n        return clientRects[cursorRectIndex] || boundingRect;\n    }\n    switch(currentBasePlacement){\n        case \"top\":\n        case \"bottom\":\n            {\n                var firstRect = clientRects[0];\n                var lastRect = clientRects[clientRects.length - 1];\n                var isTop = currentBasePlacement === \"top\";\n                var top = firstRect.top;\n                var bottom = lastRect.bottom;\n                var left = isTop ? firstRect.left : lastRect.left;\n                var right = isTop ? firstRect.right : lastRect.right;\n                var width = right - left;\n                var height = bottom - top;\n                return {\n                    top: top,\n                    bottom: bottom,\n                    left: left,\n                    right: right,\n                    width: width,\n                    height: height\n                };\n            }\n        case \"left\":\n        case \"right\":\n            {\n                var minLeft = Math.min.apply(Math, clientRects.map(function(rects) {\n                    return rects.left;\n                }));\n                var maxRight = Math.max.apply(Math, clientRects.map(function(rects) {\n                    return rects.right;\n                }));\n                var measureRects = clientRects.filter(function(rect) {\n                    return currentBasePlacement === \"left\" ? rect.left === minLeft : rect.right === maxRight;\n                });\n                var _top = measureRects[0].top;\n                var _bottom = measureRects[measureRects.length - 1].bottom;\n                var _left = minLeft;\n                var _right = maxRight;\n                var _width = _right - _left;\n                var _height = _bottom - _top;\n                return {\n                    top: _top,\n                    bottom: _bottom,\n                    left: _left,\n                    right: _right,\n                    width: _width,\n                    height: _height\n                };\n            }\n        default:\n            {\n                return boundingRect;\n            }\n    }\n}\nvar sticky = {\n    name: \"sticky\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var reference = instance.reference, popper = instance.popper;\n        function getReference() {\n            return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;\n        }\n        function shouldCheck(value) {\n            return instance.props.sticky === true || instance.props.sticky === value;\n        }\n        var prevRefRect = null;\n        var prevPopRect = null;\n        function updatePosition() {\n            var currentRefRect = shouldCheck(\"reference\") ? getReference().getBoundingClientRect() : null;\n            var currentPopRect = shouldCheck(\"popper\") ? popper.getBoundingClientRect() : null;\n            if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n                if (instance.popperInstance) {\n                    instance.popperInstance.update();\n                }\n            }\n            prevRefRect = currentRefRect;\n            prevPopRect = currentPopRect;\n            if (instance.state.isMounted) {\n                requestAnimationFrame(updatePosition);\n            }\n        }\n        return {\n            onMount: function onMount() {\n                if (instance.props.sticky) {\n                    updatePosition();\n                }\n            }\n        };\n    }\n};\nfunction areRectsDifferent(rectA, rectB) {\n    if (rectA && rectB) {\n        return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n    }\n    return true;\n}\ntippy.setDefaultProps({\n    render: render\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tippy);\n //# sourceMappingURL=tippy.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUlBLEdBQzJEO0FBRTNELElBQUlFLGNBQWM7QUFDbEIsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxnQkFBZ0I7QUFDcEIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLGdCQUFnQjtJQUNsQkMsU0FBUztJQUNUQyxTQUFTO0FBQ1g7QUFDQSxJQUFJQywwQkFBMEIsU0FBU0E7SUFDckMsT0FBT0MsU0FBU0MsSUFBSTtBQUN0QjtBQUVBLFNBQVNDLGVBQWVDLEdBQUcsRUFBRUMsR0FBRztJQUM5QixPQUFPLEVBQUMsR0FBRUYsY0FBYyxDQUFDRyxJQUFJLENBQUNGLEtBQUtDO0FBQ3JDO0FBQ0EsU0FBU0Usd0JBQXdCQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsWUFBWTtJQUN6RCxJQUFJQyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7UUFDeEIsSUFBSUssSUFBSUwsS0FBSyxDQUFDQyxNQUFNO1FBQ3BCLE9BQU9JLEtBQUssT0FBT0YsTUFBTUMsT0FBTyxDQUFDRixnQkFBZ0JBLFlBQVksQ0FBQ0QsTUFBTSxHQUFHQyxlQUFlRztJQUN4RjtJQUVBLE9BQU9MO0FBQ1Q7QUFDQSxTQUFTTSxPQUFPTixLQUFLLEVBQUVPLElBQUk7SUFDekIsSUFBSUMsTUFBTSxFQUFDLEdBQUVDLFFBQVEsQ0FBQ1gsSUFBSSxDQUFDRTtJQUMzQixPQUFPUSxJQUFJRSxPQUFPLENBQUMsZUFBZSxLQUFLRixJQUFJRSxPQUFPLENBQUNILE9BQU8sT0FBTyxDQUFDO0FBQ3BFO0FBQ0EsU0FBU0ksdUJBQXVCWCxLQUFLLEVBQUVZLElBQUk7SUFDekMsT0FBTyxPQUFPWixVQUFVLGFBQWFBLE1BQU1hLEtBQUssQ0FBQyxLQUFLLEdBQUdELFFBQVFaO0FBQ25FO0FBQ0EsU0FBU2MsU0FB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QUFNNWEsSUFBSSxLQUFLNmEsTUFBTTdhLElBQUk7SUFDN0g7SUFFQSxPQUFPO0FBQ1Q7QUFFQXdTLE1BQU1sTCxlQUFlLENBQUM7SUFDcEJOLFFBQVFBO0FBQ1Y7QUFFQSxpRUFBZXdMLEtBQUtBLEVBQUM7QUFDMEcsQ0FDL0gscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm9zLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuZXNtLmpzPzFjYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIVxuKiB0aXBweS5qcyB2Ni4zLjdcbiogKGMpIDIwMTctMjAyMSBhdG9taWtzXG4qIE1JVCBMaWNlbnNlXG4qL1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyLCBhcHBseVN0eWxlcyB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcblxudmFyIFJPVU5EX0FSUk9XID0gJzxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0wIDZzMS43OTYtLjAxMyA0LjY3LTMuNjE1QzUuODUxLjkgNi45My4wMDYgOCAwYzEuMDctLjAwNiAyLjE0OC44ODcgMy4zNDMgMi4zODVDMTQuMjMzIDYuMDA1IDE2IDYgMTYgNkgwelwiPjwvc3ZnPic7XG52YXIgQk9YX0NMQVNTID0gXCJ0aXBweS1ib3hcIjtcbnZhciBDT05URU5UX0NMQVNTID0gXCJ0aXBweS1jb250ZW50XCI7XG52YXIgQkFDS0RST1BfQ0xBU1MgPSBcInRpcHB5LWJhY2tkcm9wXCI7XG52YXIgQVJST1dfQ0xBU1MgPSBcInRpcHB5LWFycm93XCI7XG52YXIgU1ZHX0FSUk9XX0NMQVNTID0gXCJ0aXBweS1zdmctYXJyb3dcIjtcbnZhciBUT1VDSF9PUFRJT05TID0ge1xuICBwYXNzaXZlOiB0cnVlLFxuICBjYXB0dXJlOiB0cnVlXG59O1xudmFyIFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPID0gZnVuY3Rpb24gVElQUFlfREVGQVVMVF9BUFBFTkRfVE8oKSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBrZXkpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4odmFsdWUsIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHYgPSB2YWx1ZVtpbmRleF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZVtpbmRleF0gOiBkZWZhdWx0VmFsdWUgOiB2O1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKCdbb2JqZWN0JykgPT09IDAgJiYgc3RyLmluZGV4T2YodHlwZSArIFwiXVwiKSA+IC0xO1xufVxuZnVuY3Rpb24gaW52b2tlV2l0aEFyZ3NPclJldHVybih2YWx1ZSwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIG1zKSB7XG4gIC8vIEF2b2lkIHdyYXBwaW5nIGluIGBzZXRUaW1lb3V0YCBpZiBtcyBpcyAwIGFueXdheVxuICBpZiAobXMgPT09IDApIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZm4oYXJnKTtcbiAgICB9LCBtcyk7XG4gIH07XG59XG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzKG9iaiwga2V5cykge1xuICB2YXIgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSBjbG9uZVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufVxuZnVuY3Rpb24gc3BsaXRCeVNwYWNlcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBbXS5jb25jYXQodmFsdWUpO1xufVxuZnVuY3Rpb24gcHVzaElmVW5pcXVlKGFyciwgdmFsdWUpIHtcbiAgaWYgKGFyci5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBhcnJheUZyb20odmFsdWUpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodmFsdWUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkUHJvcHMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWNjW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGRpdigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBbJ0VsZW1lbnQnLCAnRnJhZ21lbnQnXS5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgdHlwZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnTm9kZUxpc3QnKTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnTW91c2VFdmVudCcpO1xufVxuZnVuY3Rpb24gaXNSZWZlcmVuY2VFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fdGlwcHkgJiYgdmFsdWUuX3RpcHB5LnJlZmVyZW5jZSA9PT0gdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlPZkVsZW1lbnRzKHZhbHVlKSB7XG4gIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIFt2YWx1ZV07XG4gIH1cblxuICBpZiAoaXNOb2RlTGlzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkR1cmF0aW9uKGVscywgdmFsdWUpIHtcbiAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB2YWx1ZSArIFwibXNcIjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmlzaWJpbGl0eVN0YXRlKGVscywgc3RhdGUpIHtcbiAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCBzdGF0ZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnQoZWxlbWVudE9yRWxlbWVudHMpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgX25vcm1hbGl6ZVRvQXJyYXkgPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRPckVsZW1lbnRzKSxcbiAgICAgIGVsZW1lbnQgPSBfbm9ybWFsaXplVG9BcnJheVswXTsgLy8gRWxlbWVudHMgY3JlYXRlZCB2aWEgYSA8dGVtcGxhdGU+IGhhdmUgYW4gb3duZXJEb2N1bWVudCB3aXRoIG5vIHJlZmVyZW5jZSB0byB0aGUgYm9keVxuXG5cbiAgcmV0dXJuIGVsZW1lbnQgIT0gbnVsbCAmJiAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSAhPSBudWxsICYmIF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5ID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihwb3BwZXJUcmVlRGF0YSwgZXZlbnQpIHtcbiAgdmFyIGNsaWVudFggPSBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gIHJldHVybiBwb3BwZXJUcmVlRGF0YS5ldmVyeShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBwb3BwZXJSZWN0ID0gX3JlZi5wb3BwZXJSZWN0LFxuICAgICAgICBwb3BwZXJTdGF0ZSA9IF9yZWYucG9wcGVyU3RhdGUsXG4gICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICB2YXIgaW50ZXJhY3RpdmVCb3JkZXIgPSBwcm9wcy5pbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocG9wcGVyU3RhdGUucGxhY2VtZW50KTtcbiAgICB2YXIgb2Zmc2V0RGF0YSA9IHBvcHBlclN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0O1xuXG4gICAgaWYgKCFvZmZzZXREYXRhKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdG9wRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJyA/IG9mZnNldERhdGEudG9wLnkgOiAwO1xuICAgIHZhciBib3R0b21EaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnID8gb2Zmc2V0RGF0YS5ib3R0b20ueSA6IDA7XG4gICAgdmFyIGxlZnREaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcgPyBvZmZzZXREYXRhLmxlZnQueCA6IDA7XG4gICAgdmFyIHJpZ2h0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcgPyBvZmZzZXREYXRhLnJpZ2h0LnggOiAwO1xuICAgIHZhciBleGNlZWRzVG9wID0gcG9wcGVyUmVjdC50b3AgLSBjbGllbnRZICsgdG9wRGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc0JvdHRvbSA9IGNsaWVudFkgLSBwb3BwZXJSZWN0LmJvdHRvbSAtIGJvdHRvbURpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNMZWZ0ID0gcG9wcGVyUmVjdC5sZWZ0IC0gY2xpZW50WCArIGxlZnREaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzUmlnaHQgPSBjbGllbnRYIC0gcG9wcGVyUmVjdC5yaWdodCAtIHJpZ2h0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICByZXR1cm4gZXhjZWVkc1RvcCB8fCBleGNlZWRzQm90dG9tIHx8IGV4Y2VlZHNMZWZ0IHx8IGV4Y2VlZHNSaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCBhY3Rpb24sIGxpc3RlbmVyKSB7XG4gIHZhciBtZXRob2QgPSBhY3Rpb24gKyBcIkV2ZW50TGlzdGVuZXJcIjsgLy8gc29tZSBicm93c2VycyBhcHBhcmVudGx5IHN1cHBvcnQgYHRyYW5zaXRpb25gICh1bnByZWZpeGVkKSBidXQgb25seSBmaXJlXG4gIC8vIGB3ZWJraXRUcmFuc2l0aW9uRW5kYC4uLlxuXG4gIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBib3hbbWV0aG9kXShldmVudCwgbGlzdGVuZXIpO1xuICB9KTtcbn1cbi8qKlxuICogQ29tcGFyZWQgdG8geHh4LmNvbnRhaW5zLCB0aGlzIGZ1bmN0aW9uIHdvcmtzIGZvciBkb20gc3RydWN0dXJlcyB3aXRoIHNoYWRvd1xuICogZG9tXG4gKi9cblxuZnVuY3Rpb24gYWN0dWFsQ29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgdGFyZ2V0ID0gY2hpbGQ7XG5cbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIHZhciBfdGFyZ2V0JGdldFJvb3ROb2RlO1xuXG4gICAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0Um9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGFyZ2V0JGdldFJvb3ROb2RlID0gdGFyZ2V0LmdldFJvb3ROb2RlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JGdldFJvb3ROb2RlLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBjdXJyZW50SW5wdXQgPSB7XG4gIGlzVG91Y2g6IGZhbHNlXG59O1xudmFyIGxhc3RNb3VzZU1vdmVUaW1lID0gMDtcbi8qKlxuICogV2hlbiBhIGB0b3VjaHN0YXJ0YCBldmVudCBpcyBmaXJlZCwgaXQncyBhc3N1bWVkIHRoZSB1c2VyIGlzIHVzaW5nIHRvdWNoXG4gKiBpbnB1dC4gV2UnbGwgYmluZCBhIGBtb3VzZW1vdmVgIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgbW91c2UgaW5wdXQgaW5cbiAqIHRoZSBmdXR1cmUuIFRoaXMgd2F5LCB0aGUgYGlzVG91Y2hgIHByb3BlcnR5IGlzIGZ1bGx5IGR5bmFtaWMgYW5kIHdpbGwgaGFuZGxlXG4gKiBoeWJyaWQgZGV2aWNlcyB0aGF0IHVzZSBhIG1peCBvZiB0b3VjaCArIG1vdXNlIGlucHV0LlxuICovXG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaFN0YXJ0KCkge1xuICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG59XG4vKipcbiAqIFdoZW4gdHdvIGBtb3VzZW1vdmVgIGV2ZW50IGFyZSBmaXJlZCBjb25zZWN1dGl2ZWx5IHdpdGhpbiAyMG1zLCBpdCdzIGFzc3VtZWRcbiAqIHRoZSB1c2VyIGlzIHVzaW5nIG1vdXNlIGlucHV0IGFnYWluLiBgbW91c2Vtb3ZlYCBjYW4gZmlyZSBvbiB0b3VjaCBkZXZpY2VzIGFzXG4gKiB3ZWxsLCBidXQgdmVyeSByYXJlbHkgdGhhdCBxdWlja2x5LlxuICovXG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRNb3VzZU1vdmUoKSB7XG4gIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBpZiAobm93IC0gbGFzdE1vdXNlTW92ZVRpbWUgPCAyMCkge1xuICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gZmFsc2U7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cblxuICBsYXN0TW91c2VNb3ZlVGltZSA9IG5vdztcbn1cbi8qKlxuICogV2hlbiBhbiBlbGVtZW50IGlzIGluIGZvY3VzIGFuZCBoYXMgYSB0aXBweSwgbGVhdmluZyB0aGUgdGFiL3dpbmRvdyBhbmRcbiAqIHJldHVybmluZyBjYXVzZXMgaXQgdG8gc2hvdyBhZ2Fpbi4gRm9yIG1vdXNlIHVzZXJzIHRoaXMgaXMgdW5leHBlY3RlZCwgYnV0XG4gKiBmb3Iga2V5Ym9hcmQgdXNlIGl0IG1ha2VzIHNlbnNlLlxuICogVE9ETzogZmluZCBhIGJldHRlciB0ZWNobmlxdWUgdG8gc29sdmUgdGhpcyBwcm9ibGVtXG4gKi9cblxuZnVuY3Rpb24gb25XaW5kb3dCbHVyKCkge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgaWYgKGlzUmVmZXJlbmNlRWxlbWVudChhY3RpdmVFbGVtZW50KSkge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUVsZW1lbnQuX3RpcHB5O1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQuYmx1ciAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG9jdW1lbnRUb3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbldpbmRvd0JsdXIpO1xufVxuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgPyAvLyBAdHMtaWdub3JlXG4hIXdpbmRvdy5tc0NyeXB0byA6IGZhbHNlO1xuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlMZWFrV2FybmluZyhtZXRob2QpIHtcbiAgdmFyIHR4dCA9IG1ldGhvZCA9PT0gJ2Rlc3Ryb3knID8gJ24gYWxyZWFkeS0nIDogJyAnO1xuICByZXR1cm4gW21ldGhvZCArIFwiKCkgd2FzIGNhbGxlZCBvbiBhXCIgKyB0eHQgKyBcImRlc3Ryb3llZCBpbnN0YW5jZS4gVGhpcyBpcyBhIG5vLW9wIGJ1dFwiLCAnaW5kaWNhdGVzIGEgcG90ZW50aWFsIG1lbW9yeSBsZWFrLiddLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGNsZWFuKHZhbHVlKSB7XG4gIHZhciBzcGFjZXNBbmRUYWJzID0gL1sgXFx0XXsyLH0vZztcbiAgdmFyIGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBnZXREZXZNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNsZWFuKFwiXFxuICAlY3RpcHB5LmpzXFxuXFxuICAlY1wiICsgY2xlYW4obWVzc2FnZSkgKyBcIlxcblxcbiAgJWNcXHVEODNEXFx1REM3N1xcdTIwMEQgVGhpcyBpcyBhIGRldmVsb3BtZW50LW9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24uXFxuICBcIik7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gW2dldERldk1lc3NhZ2UobWVzc2FnZSksIC8vIHRpdGxlXG4gICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjNlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgLy8gbWVzc2FnZVxuICAnbGluZS1oZWlnaHQ6IDEuNScsIC8vIGZvb3RlclxuICAnY29sb3I6ICNhNmEwOTU7J107XG59IC8vIEFzc3VtZSB3YXJuaW5ncyBhbmQgZXJyb3JzIG5ldmVyIGhhdmUgdGhlIHNhbWUgbWVzc2FnZVxuXG52YXIgdmlzaXRlZE1lc3NhZ2VzO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCkge1xuICB2aXNpdGVkTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG59XG5mdW5jdGlvbiB3YXJuV2hlbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhdmlzaXRlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlKSkge1xuICAgIHZhciBfY29uc29sZTtcblxuICAgIHZpc2l0ZWRNZXNzYWdlcy5hZGQobWVzc2FnZSk7XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JXaGVuKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmFyIF9jb25zb2xlMjtcblxuICAgIHZpc2l0ZWRNZXNzYWdlcy5hZGQobWVzc2FnZSk7XG5cbiAgICAoX2NvbnNvbGUyID0gY29uc29sZSkuZXJyb3IuYXBwbHkoX2NvbnNvbGUyLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIGRpZFBhc3NGYWxzeVZhbHVlID0gIXRhcmdldHM7XG4gIHZhciBkaWRQYXNzUGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0cykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICF0YXJnZXRzLmFkZEV2ZW50TGlzdGVuZXI7XG4gIGVycm9yV2hlbihkaWRQYXNzRmFsc3lWYWx1ZSwgWyd0aXBweSgpIHdhcyBwYXNzZWQnLCAnYCcgKyBTdHJpbmcodGFyZ2V0cykgKyAnYCcsICdhcyBpdHMgdGFyZ2V0cyAoZmlyc3QpIGFyZ3VtZW50LiBWYWxpZCB0eXBlcyBhcmU6IFN0cmluZywgRWxlbWVudCwnLCAnRWxlbWVudFtdLCBvciBOb2RlTGlzdC4nXS5qb2luKCcgJykpO1xuICBlcnJvcldoZW4oZGlkUGFzc1BsYWluT2JqZWN0LCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCBhIHBsYWluIG9iamVjdCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGFzIGFuIGFyZ3VtZW50JywgJ2ZvciB2aXJ0dWFsIHBvc2l0aW9uaW5nLiBVc2UgcHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG59XG5cbnZhciBwbHVnaW5Qcm9wcyA9IHtcbiAgYW5pbWF0ZUZpbGw6IGZhbHNlLFxuICBmb2xsb3dDdXJzb3I6IGZhbHNlLFxuICBpbmxpbmVQb3NpdGlvbmluZzogZmFsc2UsXG4gIHN0aWNreTogZmFsc2Vcbn07XG52YXIgcmVuZGVyUHJvcHMgPSB7XG4gIGFsbG93SFRNTDogZmFsc2UsXG4gIGFuaW1hdGlvbjogJ2ZhZGUnLFxuICBhcnJvdzogdHJ1ZSxcbiAgY29udGVudDogJycsXG4gIGluZXJ0aWE6IGZhbHNlLFxuICBtYXhXaWR0aDogMzUwLFxuICByb2xlOiAndG9vbHRpcCcsXG4gIHRoZW1lOiAnJyxcbiAgekluZGV4OiA5OTk5XG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe1xuICBhcHBlbmRUbzogVElQUFlfREVGQVVMVF9BUFBFTkRfVE8sXG4gIGFyaWE6IHtcbiAgICBjb250ZW50OiAnYXV0bycsXG4gICAgZXhwYW5kZWQ6ICdhdXRvJ1xuICB9LFxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IFszMDAsIDI1MF0sXG4gIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gIGhpZGVPbkNsaWNrOiB0cnVlLFxuICBpZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZUJvcmRlcjogMixcbiAgaW50ZXJhY3RpdmVEZWJvdW5jZTogMCxcbiAgbW92ZVRyYW5zaXRpb246ICcnLFxuICBvZmZzZXQ6IFswLCAxMF0sXG4gIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoKSB7fSxcbiAgb25CZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIG9uQmVmb3JlVXBkYXRlKCkge30sXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHt9LFxuICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7fSxcbiAgb25IaWRlOiBmdW5jdGlvbiBvbkhpZGUoKSB7fSxcbiAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHt9LFxuICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHt9LFxuICBvblNob3duOiBmdW5jdGlvbiBvblNob3duKCkge30sXG4gIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKCkge30sXG4gIG9uVW50cmlnZ2VyOiBmdW5jdGlvbiBvblVudHJpZ2dlcigpIHt9LFxuICBvbkNsaWNrT3V0c2lkZTogZnVuY3Rpb24gb25DbGlja091dHNpZGUoKSB7fSxcbiAgcGxhY2VtZW50OiAndG9wJyxcbiAgcGx1Z2luczogW10sXG4gIHBvcHBlck9wdGlvbnM6IHt9LFxuICByZW5kZXI6IG51bGwsXG4gIHNob3dPbkNyZWF0ZTogZmFsc2UsXG4gIHRvdWNoOiB0cnVlLFxuICB0cmlnZ2VyOiAnbW91c2VlbnRlciBmb2N1cycsXG4gIHRyaWdnZXJUYXJnZXQ6IG51bGxcbn0sIHBsdWdpblByb3BzLCByZW5kZXJQcm9wcyk7XG52YXIgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0UHJvcHMpO1xudmFyIHNldERlZmF1bHRQcm9wcyA9IGZ1bmN0aW9uIHNldERlZmF1bHRQcm9wcyhwYXJ0aWFsUHJvcHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBbXSk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcyk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVmYXVsdFByb3BzW2tleV0gPSBwYXJ0aWFsUHJvcHNba2V5XTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhwYXNzZWRQcm9wcykge1xuICB2YXIgcGx1Z2lucyA9IHBhc3NlZFByb3BzLnBsdWdpbnMgfHwgW107XG4gIHZhciBwbHVnaW5Qcm9wcyA9IHBsdWdpbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsdWdpbikge1xuICAgIHZhciBuYW1lID0gcGx1Z2luLm5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHBsdWdpbi5kZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIF9uYW1lO1xuXG4gICAgICBhY2NbbmFtZV0gPSBwYXNzZWRQcm9wc1tuYW1lXSAhPT0gdW5kZWZpbmVkID8gcGFzc2VkUHJvcHNbbmFtZV0gOiAoX25hbWUgPSBkZWZhdWx0UHJvcHNbbmFtZV0pICE9IG51bGwgPyBfbmFtZSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwYXNzZWRQcm9wcywgcGx1Z2luUHJvcHMpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcGx1Z2lucykge1xuICB2YXIgcHJvcEtleXMgPSBwbHVnaW5zID8gT2JqZWN0LmtleXMoZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zXG4gIH0pKSkgOiBkZWZhdWx0S2V5cztcbiAgdmFyIHByb3BzID0gcHJvcEtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIHZhciB2YWx1ZUFzU3RyaW5nID0gKHJlZmVyZW5jZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRpcHB5LVwiICsga2V5KSB8fCAnJykudHJpbSgpO1xuXG4gICAgaWYgKCF2YWx1ZUFzU3RyaW5nKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdjb250ZW50Jykge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBhY2Nba2V5XSA9IEpTT04ucGFyc2UodmFsdWVBc1N0cmluZyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBwcm9wcykge1xuICB2YXIgb3V0ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBjb250ZW50OiBpbnZva2VXaXRoQXJnc09yUmV0dXJuKHByb3BzLmNvbnRlbnQsIFtyZWZlcmVuY2VdKVxuICB9LCBwcm9wcy5pZ25vcmVBdHRyaWJ1dGVzID8ge30gOiBnZXREYXRhQXR0cmlidXRlUHJvcHMocmVmZXJlbmNlLCBwcm9wcy5wbHVnaW5zKSk7XG4gIG91dC5hcmlhID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLmFyaWEsIG91dC5hcmlhKTtcbiAgb3V0LmFyaWEgPSB7XG4gICAgZXhwYW5kZWQ6IG91dC5hcmlhLmV4cGFuZGVkID09PSAnYXV0bycgPyBwcm9wcy5pbnRlcmFjdGl2ZSA6IG91dC5hcmlhLmV4cGFuZGVkLFxuICAgIGNvbnRlbnQ6IG91dC5hcmlhLmNvbnRlbnQgPT09ICdhdXRvJyA/IHByb3BzLmludGVyYWN0aXZlID8gbnVsbCA6ICdkZXNjcmliZWRieScgOiBvdXQuYXJpYS5jb250ZW50XG4gIH07XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHBhcnRpYWxQcm9wcywgcGx1Z2lucykge1xuICBpZiAocGFydGlhbFByb3BzID09PSB2b2lkIDApIHtcbiAgICBwYXJ0aWFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHtcbiAgICBwbHVnaW5zID0gW107XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcyk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBub25QbHVnaW5Qcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMoZGVmYXVsdFByb3BzLCBPYmplY3Qua2V5cyhwbHVnaW5Qcm9wcykpO1xuICAgIHZhciBkaWRQYXNzVW5rbm93blByb3AgPSAhaGFzT3duUHJvcGVydHkobm9uUGx1Z2luUHJvcHMsIHByb3ApOyAvLyBDaGVjayBpZiB0aGUgcHJvcCBleGlzdHMgaW4gYHBsdWdpbnNgXG5cbiAgICBpZiAoZGlkUGFzc1Vua25vd25Qcm9wKSB7XG4gICAgICBkaWRQYXNzVW5rbm93blByb3AgPSBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4ubmFtZSA9PT0gcHJvcDtcbiAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICB3YXJuV2hlbihkaWRQYXNzVW5rbm93blByb3AsIFtcImBcIiArIHByb3AgKyBcImBcIiwgXCJpcyBub3QgYSB2YWxpZCBwcm9wLiBZb3UgbWF5IGhhdmUgc3BlbGxlZCBpdCBpbmNvcnJlY3RseSwgb3IgaWYgaXQnc1wiLCAnYSBwbHVnaW4sIGZvcmdvdCB0byBwYXNzIGl0IGluIGFuIGFycmF5IGFzIHByb3BzLnBsdWdpbnMuJywgJ1xcblxcbicsICdBbGwgcHJvcHM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hbGwtcHJvcHMvXFxuJywgJ1BsdWdpbnM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9wbHVnaW5zLyddLmpvaW4oJyAnKSk7XG4gIH0pO1xufVxuXG52YXIgaW5uZXJIVE1MID0gZnVuY3Rpb24gaW5uZXJIVE1MKCkge1xuICByZXR1cm4gJ2lubmVySFRNTCc7XG59O1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNseVNldElubmVySFRNTChlbGVtZW50LCBodG1sKSB7XG4gIGVsZW1lbnRbaW5uZXJIVE1MKCldID0gaHRtbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyb3dFbGVtZW50KHZhbHVlKSB7XG4gIHZhciBhcnJvdyA9IGRpdigpO1xuXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IEFSUk9XX0NMQVNTO1xuICB9IGVsc2Uge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IFNWR19BUlJPV19DTEFTUztcblxuICAgIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICBhcnJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGFycm93LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycm93O1xufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQsIHByb3BzKSB7XG4gIGlmIChpc0VsZW1lbnQocHJvcHMuY29udGVudCkpIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCAnJyk7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZChwcm9wcy5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuY29udGVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9wcy5hbGxvd0hUTUwpIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGNvbnRlbnQsIHByb3BzLmNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50LnRleHRDb250ZW50ID0gcHJvcHMuY29udGVudDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKHBvcHBlcikge1xuICB2YXIgYm94ID0gcG9wcGVyLmZpcnN0RWxlbWVudENoaWxkO1xuICB2YXIgYm94Q2hpbGRyZW4gPSBhcnJheUZyb20oYm94LmNoaWxkcmVuKTtcbiAgcmV0dXJuIHtcbiAgICBib3g6IGJveCxcbiAgICBjb250ZW50OiBib3hDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQ09OVEVOVF9DTEFTUyk7XG4gICAgfSksXG4gICAgYXJyb3c6IGJveENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhBUlJPV19DTEFTUykgfHwgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoU1ZHX0FSUk9XX0NMQVNTKTtcbiAgICB9KSxcbiAgICBiYWNrZHJvcDogYm94Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEJBQ0tEUk9QX0NMQVNTKTtcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gcmVuZGVyKGluc3RhbmNlKSB7XG4gIHZhciBwb3BwZXIgPSBkaXYoKTtcbiAgdmFyIGJveCA9IGRpdigpO1xuICBib3guY2xhc3NOYW1lID0gQk9YX0NMQVNTO1xuICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2hpZGRlbicpO1xuICBib3guc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICB2YXIgY29udGVudCA9IGRpdigpO1xuICBjb250ZW50LmNsYXNzTmFtZSA9IENPTlRFTlRfQ0xBU1M7XG4gIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2hpZGRlbicpO1xuICBzZXRDb250ZW50KGNvbnRlbnQsIGluc3RhbmNlLnByb3BzKTtcbiAgcG9wcGVyLmFwcGVuZENoaWxkKGJveCk7XG4gIGJveC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgb25VcGRhdGUoaW5zdGFuY2UucHJvcHMsIGluc3RhbmNlLnByb3BzKTtcblxuICBmdW5jdGlvbiBvblVwZGF0ZShwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICAgIHZhciBfZ2V0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihwb3BwZXIpLFxuICAgICAgICBib3ggPSBfZ2V0Q2hpbGRyZW4uYm94LFxuICAgICAgICBjb250ZW50ID0gX2dldENoaWxkcmVuLmNvbnRlbnQsXG4gICAgICAgIGFycm93ID0gX2dldENoaWxkcmVuLmFycm93O1xuXG4gICAgaWYgKG5leHRQcm9wcy50aGVtZSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScsIG5leHRQcm9wcy50aGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5leHRQcm9wcy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsIG5leHRQcm9wcy5hbmltYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuaW5lcnRpYSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnKTtcbiAgICB9XG5cbiAgICBib3guc3R5bGUubWF4V2lkdGggPSB0eXBlb2YgbmV4dFByb3BzLm1heFdpZHRoID09PSAnbnVtYmVyJyA/IG5leHRQcm9wcy5tYXhXaWR0aCArIFwicHhcIiA6IG5leHRQcm9wcy5tYXhXaWR0aDtcblxuICAgIGlmIChuZXh0UHJvcHMucm9sZSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgncm9sZScsIG5leHRQcm9wcy5yb2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIH1cblxuICAgIGlmIChwcmV2UHJvcHMuY29udGVudCAhPT0gbmV4dFByb3BzLmNvbnRlbnQgfHwgcHJldlByb3BzLmFsbG93SFRNTCAhPT0gbmV4dFByb3BzLmFsbG93SFRNTCkge1xuICAgICAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5hcnJvdykge1xuICAgICAgaWYgKCFhcnJvdykge1xuICAgICAgICBib3guYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KG5leHRQcm9wcy5hcnJvdykpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2UHJvcHMuYXJyb3cgIT09IG5leHRQcm9wcy5hcnJvdykge1xuICAgICAgICBib3gucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgICAgICBib3guYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KG5leHRQcm9wcy5hcnJvdykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJyb3cpIHtcbiAgICAgIGJveC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3BwZXI6IHBvcHBlcixcbiAgICBvblVwZGF0ZTogb25VcGRhdGVcbiAgfTtcbn0gLy8gUnVudGltZSBjaGVjayB0byBpZGVudGlmeSBpZiB0aGUgcmVuZGVyIGZ1bmN0aW9uIGlzIHRoZSBkZWZhdWx0IG9uZTsgdGhpc1xuLy8gd2F5IHdlIGNhbiBhcHBseSBkZWZhdWx0IENTUyB0cmFuc2l0aW9ucyBsb2dpYyBhbmQgaXQgY2FuIGJlIHRyZWUtc2hha2VuIGF3YXlcblxucmVuZGVyLiQkdGlwcHkgPSB0cnVlO1xuXG52YXIgaWRDb3VudGVyID0gMTtcbnZhciBtb3VzZU1vdmVMaXN0ZW5lcnMgPSBbXTsgLy8gVXNlZCBieSBgaGlkZUFsbCgpYFxuXG52YXIgbW91bnRlZEluc3RhbmNlcyA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlVGlwcHkocmVmZXJlbmNlLCBwYXNzZWRQcm9wcykge1xuICB2YXIgcHJvcHMgPSBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHJlbW92ZVVuZGVmaW5lZFByb3BzKHBhc3NlZFByb3BzKSkpKTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZW1iZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBzaG93VGltZW91dDtcbiAgdmFyIGhpZGVUaW1lb3V0O1xuICB2YXIgc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWU7XG4gIHZhciBpc1Zpc2libGVGcm9tQ2xpY2sgPSBmYWxzZTtcbiAgdmFyIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gZmFsc2U7XG4gIHZhciBkaWRUb3VjaE1vdmUgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZU9uRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgdmFyIGxhc3RUcmlnZ2VyRXZlbnQ7XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyO1xuICB2YXIgb25GaXJzdFVwZGF0ZTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgcHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gIHZhciBjdXJyZW50VGFyZ2V0OyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkSBQdWJsaWMgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgaWQgPSBpZENvdW50ZXIrKztcbiAgdmFyIHBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgdmFyIHBsdWdpbnMgPSB1bmlxdWUocHJvcHMucGx1Z2lucyk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICAvLyBJcyB0aGUgaW5zdGFuY2UgY3VycmVudGx5IGVuYWJsZWQ/XG4gICAgaXNFbmFibGVkOiB0cnVlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgc2hvd2luZyBhbmQgbm90IHRyYW5zaXRpb25pbmcgb3V0P1xuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSBpbnN0YW5jZSBiZWVuIGRlc3Ryb3llZD9cbiAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBtb3VudGVkIHRvIHRoZSBET00/XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIHRpcHB5IGZpbmlzaGVkIHRyYW5zaXRpb25pbmcgaW4/XG4gICAgaXNTaG93bjogZmFsc2VcbiAgfTtcbiAgdmFyIGluc3RhbmNlID0ge1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBpZDogaWQsXG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgcG9wcGVyOiBkaXYoKSxcbiAgICBwb3BwZXJJbnN0YW5jZTogcG9wcGVySW5zdGFuY2UsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBwbHVnaW5zOiBwbHVnaW5zLFxuICAgIC8vIG1ldGhvZHNcbiAgICBjbGVhckRlbGF5VGltZW91dHM6IGNsZWFyRGVsYXlUaW1lb3V0cyxcbiAgICBzZXRQcm9wczogc2V0UHJvcHMsXG4gICAgc2V0Q29udGVudDogc2V0Q29udGVudCxcbiAgICBzaG93OiBzaG93LFxuICAgIGhpZGU6IGhpZGUsXG4gICAgaGlkZVdpdGhJbnRlcmFjdGl2aXR5OiBoaWRlV2l0aEludGVyYWN0aXZpdHksXG4gICAgZW5hYmxlOiBlbmFibGUsXG4gICAgZGlzYWJsZTogZGlzYWJsZSxcbiAgICB1bm1vdW50OiB1bm1vdW50LFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3lcbiAgfTsgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgZWFybHkgcmV0dXJuIGNhdXNlcyBhIFREWiBlcnJvciBpbiB0aGUgdGVzdHMg4oCUXG4gIC8vIGl0IGRvZXNuJ3Qgc2VlbSB0byBoYXBwZW4gaW4gdGhlIGJyb3dzZXJcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICBpZiAoIXByb3BzLnJlbmRlcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGVycm9yV2hlbih0cnVlLCAncmVuZGVyKCkgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHN1cHBsaWVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSW5pdGlhbCBtdXRhdGlvbnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICB2YXIgX3Byb3BzJHJlbmRlciA9IHByb3BzLnJlbmRlcihpbnN0YW5jZSksXG4gICAgICBwb3BwZXIgPSBfcHJvcHMkcmVuZGVyLnBvcHBlcixcbiAgICAgIG9uVXBkYXRlID0gX3Byb3BzJHJlbmRlci5vblVwZGF0ZTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXJvb3QnLCAnJyk7XG4gIHBvcHBlci5pZCA9IFwidGlwcHktXCIgKyBpbnN0YW5jZS5pZDtcbiAgaW5zdGFuY2UucG9wcGVyID0gcG9wcGVyO1xuICByZWZlcmVuY2UuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHBvcHBlci5fdGlwcHkgPSBpbnN0YW5jZTtcbiAgdmFyIHBsdWdpbnNIb29rcyA9IHBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICByZXR1cm4gcGx1Z2luLmZuKGluc3RhbmNlKTtcbiAgfSk7XG4gIHZhciBoYXNBcmlhRXhwYW5kZWQgPSByZWZlcmVuY2UuaGFzQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gIGFkZExpc3RlbmVycygpO1xuICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgaGFuZGxlU3R5bGVzKCk7XG4gIGludm9rZUhvb2soJ29uQ3JlYXRlJywgW2luc3RhbmNlXSk7XG5cbiAgaWYgKHByb3BzLnNob3dPbkNyZWF0ZSkge1xuICAgIHNjaGVkdWxlU2hvdygpO1xuICB9IC8vIFByZXZlbnQgYSB0aXBweSB3aXRoIGEgZGVsYXkgZnJvbSBoaWRpbmcgaWYgdGhlIGN1cnNvciBsZWZ0IHRoZW4gcmV0dXJuZWRcbiAgLy8gYmVmb3JlIGl0IHN0YXJ0ZWQgaGlkaW5nXG5cblxuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICB9XG4gIH0pO1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMCkge1xuICAgICAgZ2V0RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlOyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkiBQcml2YXRlIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKSB7XG4gICAgdmFyIHRvdWNoID0gaW5zdGFuY2UucHJvcHMudG91Y2g7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodG91Y2gpID8gdG91Y2ggOiBbdG91Y2gsIDBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkge1xuICAgIHJldHVybiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpWzBdID09PSAnaG9sZCc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0RlZmF1bHRSZW5kZXJGbigpIHtcbiAgICB2YXIgX2luc3RhbmNlJHByb3BzJHJlbmRlO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAhISgoX2luc3RhbmNlJHByb3BzJHJlbmRlID0gaW5zdGFuY2UucHJvcHMucmVuZGVyKSAhPSBudWxsICYmIF9pbnN0YW5jZSRwcm9wcyRyZW5kZS4kJHRpcHB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQgfHwgcmVmZXJlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgdmFyIHBhcmVudCA9IGdldEN1cnJlbnRUYXJnZXQoKS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBwYXJlbnQgPyBnZXRPd25lckRvY3VtZW50KHBhcmVudCkgOiBkb2N1bWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCkge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihwb3BwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVsYXkoaXNTaG93KSB7XG4gICAgLy8gRm9yIHRvdWNoIG9yIGtleWJvYXJkIGlucHV0LCBmb3JjZSBgMGAgZGVsYXkgZm9yIFVYIHJlYXNvbnNcbiAgICAvLyBBbHNvIGlmIHRoZSBpbnN0YW5jZSBpcyBtb3VudGVkIGJ1dCBub3QgdmlzaWJsZSAodHJhbnNpdGlvbmluZyBvdXQpLFxuICAgIC8vIGlnbm9yZSBkZWxheVxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fCBsYXN0VHJpZ2dlckV2ZW50ICYmIGxhc3RUcmlnZ2VyRXZlbnQudHlwZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmRlbGF5LCBpc1Nob3cgPyAwIDogMSwgZGVmYXVsdFByb3BzLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0eWxlcyhmcm9tSGlkZSkge1xuICAgIGlmIChmcm9tSGlkZSA9PT0gdm9pZCAwKSB7XG4gICAgICBmcm9tSGlkZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHBvcHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgIWZyb21IaWRlID8gJycgOiAnbm9uZSc7XG4gICAgcG9wcGVyLnN0eWxlLnpJbmRleCA9IFwiXCIgKyBpbnN0YW5jZS5wcm9wcy56SW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VIb29rKGhvb2ssIGFyZ3MsIHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2sgPT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkSW52b2tlUHJvcHNIb29rID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwbHVnaW5zSG9va3MuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luSG9va3MpIHtcbiAgICAgIGlmIChwbHVnaW5Ib29rc1tob29rXSkge1xuICAgICAgICBwbHVnaW5Ib29rc1tob29rXS5hcHBseShwbHVnaW5Ib29rcywgYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2hvdWxkSW52b2tlUHJvcHNIb29rKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHByb3BzO1xuXG4gICAgICAoX2luc3RhbmNlJHByb3BzID0gaW5zdGFuY2UucHJvcHMpW2hvb2tdLmFwcGx5KF9pbnN0YW5jZSRwcm9wcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKSB7XG4gICAgdmFyIGFyaWEgPSBpbnN0YW5jZS5wcm9wcy5hcmlhO1xuXG4gICAgaWYgKCFhcmlhLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXR0ciA9IFwiYXJpYS1cIiArIGFyaWEuY29udGVudDtcbiAgICB2YXIgaWQgPSBwb3BwZXIuaWQ7XG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpO1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIGN1cnJlbnRWYWx1ZSA/IGN1cnJlbnRWYWx1ZSArIFwiIFwiICsgaWQgOiBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5yZXBsYWNlKGlkLCAnJykudHJpbSgpO1xuXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBuZXh0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKSB7XG4gICAgaWYgKGhhc0FyaWFFeHBhbmRlZCB8fCAhaW5zdGFuY2UucHJvcHMuYXJpYS5leHBhbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBub2RlID09PSBnZXRDdXJyZW50VGFyZ2V0KCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpIHtcbiAgICBnZXREb2N1bWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBtb3VzZU1vdmVMaXN0ZW5lcnMgPSBtb3VzZU1vdmVMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyICE9PSBkZWJvdW5jZWRPbk1vdXNlTW92ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRG9jdW1lbnRQcmVzcyhldmVudCkge1xuICAgIC8vIE1vdmVkIGZpbmdlciB0byBzY3JvbGwgaW5zdGVhZCBvZiBhbiBpbnRlbnRpb25hbCB0YXAgb3V0c2lkZVxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgICAgaWYgKGRpZFRvdWNoTW92ZSB8fCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbFRhcmdldCA9IGV2ZW50LmNvbXBvc2VkUGF0aCAmJiBldmVudC5jb21wb3NlZFBhdGgoKVswXSB8fCBldmVudC50YXJnZXQ7IC8vIENsaWNrZWQgb24gaW50ZXJhY3RpdmUgcG9wcGVyXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYWN0dWFsQ29udGFpbnMocG9wcGVyLCBhY3R1YWxUYXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGlja2VkIG9uIHRoZSBldmVudCBsaXN0ZW5lcnMgdGFyZ2V0XG5cblxuICAgIGlmIChub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKS5zb21lKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGFjdHVhbENvbnRhaW5zKGVsLCBhY3R1YWxUYXJnZXQpO1xuICAgIH0pKSB7XG4gICAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW52b2tlSG9vaygnb25DbGlja091dHNpZGUnLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTsgLy8gYG1vdXNlZG93bmAgZXZlbnQgaXMgZmlyZWQgcmlnaHQgYmVmb3JlIGBmb2N1c2AgaWYgcHJlc3NpbmcgdGhlXG4gICAgICAvLyBjdXJyZW50VGFyZ2V0LiBUaGlzIGxldHMgYSB0aXBweSB3aXRoIGBmb2N1c2AgdHJpZ2dlciBrbm93IHRoYXQgaXRcbiAgICAgIC8vIHNob3VsZCBub3Qgc2hvd1xuXG4gICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIH0pOyAvLyBUaGUgbGlzdGVuZXIgZ2V0cyBhZGRlZCBpbiBgc2NoZWR1bGVTaG93KClgLCBidXQgdGhpcyBtYXkgYmUgaGlkaW5nIGl0XG4gICAgICAvLyBiZWZvcmUgaXQgc2hvd3MsIGFuZCBoaWRlKCkncyBlYXJseSBiYWlsLW91dCBiZWhhdmlvciBjYW4gcHJldmVudCBpdFxuICAgICAgLy8gZnJvbSBiZWluZyBjbGVhbmVkIHVwXG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZSgpIHtcbiAgICBkaWRUb3VjaE1vdmUgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCkge1xuICAgIGRpZFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRG9jdW1lbnRQcmVzcygpIHtcbiAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRG9jdW1lbnRQcmVzcygpIHtcbiAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBwb3BwZXIucGFyZW50Tm9kZSAmJiBwb3BwZXIucGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBib3ggPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLmJveDtcblxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBib3gpIHtcbiAgICAgICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgY2FsbGJhY2sgc3luY2hyb25vdXMgaWYgZHVyYXRpb24gaXMgMFxuICAgIC8vIGB0cmFuc2l0aW9uZW5kYCB3b24ndCBmaXJlIG90aGVyd2lzZVxuXG5cbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyKTtcbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAnYWRkJywgbGlzdGVuZXIpO1xuICAgIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmIChnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSkge1xuICAgICAgb24oJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvbigndG91Y2hlbmQnLCBvbk1vdXNlTGVhdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3BsaXRCeVNwYWNlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb24oZXZlbnRUeXBlLCBvblRyaWdnZXIpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZWVudGVyJzpcbiAgICAgICAgICBvbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgIG9uKGlzSUUxMSA/ICdmb2N1c291dCcgOiAnYmx1cicsIG9uQmx1ck9yRm9jdXNPdXQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgICAgIG9uKCdmb2N1c291dCcsIG9uQmx1ck9yRm9jdXNPdXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgICBldmVudFR5cGUgPSBfcmVmLmV2ZW50VHlwZSxcbiAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyLFxuICAgICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudCkge1xuICAgIHZhciBfbGFzdFRyaWdnZXJFdmVudDtcblxuICAgIHZhciBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgfHwgaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkgfHwgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FzRm9jdXNlZCA9ICgoX2xhc3RUcmlnZ2VyRXZlbnQgPSBsYXN0VHJpZ2dlckV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2xhc3RUcmlnZ2VyRXZlbnQudHlwZSkgPT09ICdmb2N1cyc7XG4gICAgbGFzdFRyaWdnZXJFdmVudCA9IGV2ZW50O1xuICAgIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgLy8gSWYgc2Nyb2xsaW5nLCBgbW91c2VlbnRlcmAgZXZlbnRzIGNhbiBiZSBmaXJlZCBpZiB0aGUgY3Vyc29yIGxhbmRzXG4gICAgICAvLyBvdmVyIGEgbmV3IHRhcmdldCwgYnV0IGBtb3VzZW1vdmVgIGV2ZW50cyBkb24ndCBnZXQgZmlyZWQuIFRoaXNcbiAgICAgIC8vIGNhdXNlcyBpbnRlcmFjdGl2ZSB0b29sdGlwcyB0byBnZXQgc3R1Y2sgb3BlbiB1bnRpbCB0aGUgY3Vyc29yIGlzXG4gICAgICAvLyBtb3ZlZFxuICAgICAgbW91c2VNb3ZlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9IC8vIFRvZ2dsZSBzaG93L2hpZGUgd2hlbiBjbGlja2luZyBjbGljay10cmlnZ2VyZWQgdG9vbHRpcHNcblxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpIDwgMCB8fCBpc1Zpc2libGVGcm9tQ2xpY2spICYmIGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrICE9PSBmYWxzZSAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTaG93KGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gIXNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSAmJiAhd2FzRm9jdXNlZCkge1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyID0gZ2V0Q3VycmVudFRhcmdldCgpLmNvbnRhaW5zKHRhcmdldCkgfHwgcG9wcGVyLmNvbnRhaW5zKHRhcmdldCk7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9wcGVyVHJlZURhdGEgPSBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuY29uY2F0KHBvcHBlcikubWFwKGZ1bmN0aW9uIChwb3BwZXIpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcG9wcGVySW5zdGE7XG5cbiAgICAgIHZhciBpbnN0YW5jZSA9IHBvcHBlci5fdGlwcHk7XG4gICAgICB2YXIgc3RhdGUgPSAoX2luc3RhbmNlJHBvcHBlckluc3RhID0gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkcG9wcGVySW5zdGEuc3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcHBlclJlY3Q6IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBwb3BwZXJTdGF0ZTogc3RhdGUsXG4gICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICAgIGlmIChpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihwb3BwZXJUcmVlRGF0YSwgZXZlbnQpKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkQmFpbCA9IGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8IGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmIGlzVmlzaWJsZUZyb21DbGljaztcblxuICAgIGlmIChzaG91bGRCYWlsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBpbnN0YW5jZS5oaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkJsdXJPckZvY3VzT3V0KGV2ZW50KSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignZm9jdXNpbicpIDwgMCAmJiBldmVudC50YXJnZXQgIT09IGdldEN1cnJlbnRUYXJnZXQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgZm9jdXMgd2FzIG1vdmVkIHRvIHdpdGhpbiB0aGUgcG9wcGVyXG5cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHBvcHBlci5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRJbnB1dC5pc1RvdWNoID8gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkgIT09IGV2ZW50LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpIHtcbiAgICBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTtcbiAgICB2YXIgX2luc3RhbmNlJHByb3BzMiA9IGluc3RhbmNlLnByb3BzLFxuICAgICAgICBwb3BwZXJPcHRpb25zID0gX2luc3RhbmNlJHByb3BzMi5wb3BwZXJPcHRpb25zLFxuICAgICAgICBwbGFjZW1lbnQgPSBfaW5zdGFuY2UkcHJvcHMyLnBsYWNlbWVudCxcbiAgICAgICAgb2Zmc2V0ID0gX2luc3RhbmNlJHByb3BzMi5vZmZzZXQsXG4gICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3QgPSBfaW5zdGFuY2UkcHJvcHMyLmdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICAgIG1vdmVUcmFuc2l0aW9uID0gX2luc3RhbmNlJHByb3BzMi5tb3ZlVHJhbnNpdGlvbjtcbiAgICB2YXIgYXJyb3cgPSBnZXRJc0RlZmF1bHRSZW5kZXJGbigpID8gZ2V0Q2hpbGRyZW4ocG9wcGVyKS5hcnJvdyA6IG51bGw7XG4gICAgdmFyIGNvbXB1dGVkUmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA/IHtcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgIGNvbnRleHRFbGVtZW50OiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LmNvbnRleHRFbGVtZW50IHx8IGdldEN1cnJlbnRUYXJnZXQoKVxuICAgIH0gOiByZWZlcmVuY2U7XG4gICAgdmFyIHRpcHB5TW9kaWZpZXIgPSB7XG4gICAgICBuYW1lOiAnJCR0aXBweScsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gICAgICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ10sXG4gICAgICBmbjogZnVuY3Rpb24gZm4oX3JlZjIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG5cbiAgICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSxcbiAgICAgICAgICAgICAgYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoLmJveDtcblxuICAgICAgICAgIFsncGxhY2VtZW50JywgJ3JlZmVyZW5jZS1oaWRkZW4nLCAnZXNjYXBlZCddLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyID09PSAncGxhY2VtZW50Jykge1xuICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcsIHN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXJbXCJkYXRhLXBvcHBlci1cIiArIGF0dHJdKSB7XG4gICAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBhdHRyLCAnJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtXCIgKyBhdHRyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBtb2RpZmllcnMgPSBbe1xuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0b3A6IDIsXG4gICAgICAgICAgYm90dG9tOiAyLFxuICAgICAgICAgIGxlZnQ6IDUsXG4gICAgICAgICAgcmlnaHQ6IDVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzogNVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWRhcHRpdmU6ICFtb3ZlVHJhbnNpdGlvblxuICAgICAgfVxuICAgIH0sIHRpcHB5TW9kaWZpZXJdO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkgJiYgYXJyb3cpIHtcbiAgICAgIG1vZGlmaWVycy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGVsZW1lbnQ6IGFycm93LFxuICAgICAgICAgIHBhZGRpbmc6IDNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kaWZpZXJzLnB1c2guYXBwbHkobW9kaWZpZXJzLCAocG9wcGVyT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpIHx8IFtdKTtcbiAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IGNyZWF0ZVBvcHBlcihjb21wdXRlZFJlZmVyZW5jZSwgcG9wcGVyLCBPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJPcHRpb25zLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IG9uRmlyc3RVcGRhdGUsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpIHtcbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICB2YXIgYXBwZW5kVG8gPSBpbnN0YW5jZS5wcm9wcy5hcHBlbmRUbztcbiAgICB2YXIgcGFyZW50Tm9kZTsgLy8gQnkgZGVmYXVsdCwgd2UnbGwgYXBwZW5kIHRoZSBwb3BwZXIgdG8gdGhlIHRyaWdnZXJUYXJnZXRzJ3MgcGFyZW50Tm9kZSBzb1xuICAgIC8vIGl0J3MgZGlyZWN0bHkgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50IHNvIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhlXG4gICAgLy8gdGlwcHkgY2FuIGJlIHRhYmJlZCB0b1xuICAgIC8vIElmIHRoZXJlIGFyZSBjbGlwcGluZyBpc3N1ZXMsIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGEgZGlmZmVyZW50IGFwcGVuZFRvXG4gICAgLy8gYW5kIGVuc3VyZSBmb2N1cyBtYW5hZ2VtZW50IGlzIGhhbmRsZWQgY29ycmVjdGx5IG1hbnVhbGx5XG5cbiAgICB2YXIgbm9kZSA9IGdldEN1cnJlbnRUYXJnZXQoKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBhcHBlbmRUbyA9PT0gVElQUFlfREVGQVVMVF9BUFBFTkRfVE8gfHwgYXBwZW5kVG8gPT09ICdwYXJlbnQnKSB7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlID0gaW52b2tlV2l0aEFyZ3NPclJldHVybihhcHBlbmRUbywgW25vZGVdKTtcbiAgICB9IC8vIFRoZSBwb3BwZXIgZWxlbWVudCBuZWVkcyB0byBleGlzdCBvbiB0aGUgRE9NIGJlZm9yZSBpdHMgcG9zaXRpb24gY2FuIGJlXG4gICAgLy8gdXBkYXRlZCBhcyBQb3BwZXIgbmVlZHMgdG8gcmVhZCBpdHMgZGltZW5zaW9uc1xuXG5cbiAgICBpZiAoIXBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gQWNjZXNzaWJpbGl0eSBjaGVja1xuICAgICAgd2FybldoZW4oaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IGRlZmF1bHRQcm9wcy5hcHBlbmRUbyAmJiBub2RlLm5leHRFbGVtZW50U2libGluZyAhPT0gcG9wcGVyLCBbJ0ludGVyYWN0aXZlIHRpcHB5IGVsZW1lbnQgbWF5IG5vdCBiZSBhY2Nlc3NpYmxlIHZpYSBrZXlib2FyZCcsICduYXZpZ2F0aW9uIGJlY2F1c2UgaXQgaXMgbm90IGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCcsICdpbiB0aGUgRE9NIHNvdXJjZSBvcmRlci4nLCAnXFxuXFxuJywgJ1VzaW5nIGEgd3JhcHBlciA8ZGl2PiBvciA8c3Bhbj4gdGFnIGFyb3VuZCB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLCAnc29sdmVzIHRoaXMgYnkgY3JlYXRpbmcgYSBuZXcgcGFyZW50Tm9kZSBjb250ZXh0LicsICdcXG5cXG4nLCAnU3BlY2lmeWluZyBgYXBwZW5kVG86IGRvY3VtZW50LmJvZHlgIHNpbGVuY2VzIHRoaXMgd2FybmluZywgYnV0IGl0JywgJ2Fzc3VtZXMgeW91IGFyZSB1c2luZyBhIGZvY3VzIG1hbmFnZW1lbnQgc29sdXRpb24gdG8gaGFuZGxlJywgJ2tleWJvYXJkIG5hdmlnYXRpb24uJywgJ1xcblxcbicsICdTZWU6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hY2Nlc3NpYmlsaXR5LyNpbnRlcmFjdGl2aXR5J10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXN0ZWRQb3BwZXJUcmVlKCkge1xuICAgIHJldHVybiBhcnJheUZyb20ocG9wcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRpcHB5LXJvb3RdJykpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVTaG93KGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGludm9rZUhvb2soJ29uVHJpZ2dlcicsIFtpbnN0YW5jZSwgZXZlbnRdKTtcbiAgICB9XG5cbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG4gICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXkodHJ1ZSk7XG5cbiAgICB2YXIgX2dldE5vcm1hbGl6ZWRUb3VjaFNlID0gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKSxcbiAgICAgICAgdG91Y2hWYWx1ZSA9IF9nZXROb3JtYWxpemVkVG91Y2hTZVswXSxcbiAgICAgICAgdG91Y2hEZWxheSA9IF9nZXROb3JtYWxpemVkVG91Y2hTZVsxXTtcblxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiB0b3VjaFZhbHVlID09PSAnaG9sZCcgJiYgdG91Y2hEZWxheSkge1xuICAgICAgZGVsYXkgPSB0b3VjaERlbGF5O1xuICAgIH1cblxuICAgIGlmIChkZWxheSkge1xuICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgaW52b2tlSG9vaygnb25VbnRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIHNjaGVkdWxlSGlkZSBpcyBhZGRlZCB0byBhIGRvY3VtZW50LmJvZHkgaGFuZGxlclxuICAgIC8vIGZyb20gb25Nb3VzZUxlYXZlIHNvIG11c3QgaW50ZXJjZXB0IHNjaGVkdWxlZCBoaWRlcyBmcm9tIG1vdXNlbW92ZS9sZWF2ZVxuICAgIC8vIGV2ZW50cyB3aGVuIHRyaWdnZXIgY29udGFpbnMgbW91c2VlbnRlciBhbmQgY2xpY2ssIGFuZCB0aGUgdGlwIGlzXG4gICAgLy8gY3VycmVudGx5IHNob3duIGFzIGEgcmVzdWx0IG9mIGEgY2xpY2suXG5cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwICYmIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmIFsnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnXS5pbmRleE9mKGV2ZW50LnR5cGUpID49IDAgJiYgaXNWaXNpYmxlRnJvbUNsaWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXkoZmFsc2UpO1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpeGVzIGEgYHRyYW5zaXRpb25lbmRgIHByb2JsZW0gd2hlbiBpdCBmaXJlcyAxIGZyYW1lIHRvb1xuICAgICAgLy8gbGF0ZSBzb21ldGltZXMsIHdlIGRvbid0IHdhbnQgaGlkZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SRIFB1YmxpYyBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIC8vIERpc2FibGluZyB0aGUgaW5zdGFuY2Ugc2hvdWxkIGFsc28gaGlkZSBpdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5LmpzLXJlYWN0L2lzc3Vlcy8xMDZcbiAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRlbGF5VGltZW91dHMoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNob3dUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQoaGlkZVRpbWVvdXQpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzZXRQcm9wcycpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkJlZm9yZVVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgdmFyIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgT2JqZWN0LmFzc2lnbih7fSwgcHJldlByb3BzLCByZW1vdmVVbmRlZmluZWRQcm9wcyhwYXJ0aWFsUHJvcHMpLCB7XG4gICAgICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSkpO1xuICAgIGluc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuICAgIGFkZExpc3RlbmVycygpO1xuXG4gICAgaWYgKHByZXZQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlICE9PSBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgICB9IC8vIEVuc3VyZSBzdGFsZSBhcmlhLWV4cGFuZGVkIGF0dHJpYnV0ZXMgYXJlIHJlbW92ZWRcblxuXG4gICAgaWYgKHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0ICYmICFuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgbm9ybWFsaXplVG9BcnJheShwcmV2UHJvcHMudHJpZ2dlclRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgcmVmZXJlbmNlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgIH1cblxuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuICAgIGhhbmRsZVN0eWxlcygpO1xuXG4gICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICBvblVwZGF0ZShwcmV2UHJvcHMsIG5leHRQcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpOyAvLyBGaXhlcyBhbiBpc3N1ZSB3aXRoIG5lc3RlZCB0aXBwaWVzIGlmIHRoZXkgYXJlIGFsbCBnZXR0aW5nIHJlLXJlbmRlcmVkLFxuICAgICAgLy8gYW5kIHRoZSBuZXN0ZWQgb25lcyBnZXQgcmUtcmVuZGVyZWQgZmlyc3QuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbWlrcy90aXBweWpzLXJlYWN0L2lzc3Vlcy8xNzdcbiAgICAgIC8vIFRPRE86IGZpbmQgYSBjbGVhbmVyIC8gbW9yZSBlZmZpY2llbnQgc29sdXRpb24oISlcblxuICAgICAgZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmZvckVhY2goZnVuY3Rpb24gKG5lc3RlZFBvcHBlcikge1xuICAgICAgICAvLyBSZWFjdCAoYW5kIG90aGVyIFVJIGxpYnMgbGlrZWx5KSByZXF1aXJlcyBhIHJBRiB3cmFwcGVyIGFzIGl0IGZsdXNoZXNcbiAgICAgICAgLy8gaXRzIHdvcmsgaW4gb25lXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShuZXN0ZWRQb3BwZXIuX3RpcHB5LnBvcHBlckluc3RhbmNlLmZvcmNlVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQWZ0ZXJVcGRhdGUnLCBbaW5zdGFuY2UsIHBhcnRpYWxQcm9wc10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgY29udGVudDogY29udGVudFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdygpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2hvdycpKTtcbiAgICB9IC8vIEVhcmx5IGJhaWwtb3V0XG5cblxuICAgIHZhciBpc0FscmVhZHlWaXNpYmxlID0gaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkO1xuICAgIHZhciBpc0Rpc2FibGVkID0gIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZDtcbiAgICB2YXIgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQgPSBjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiAhaW5zdGFuY2UucHJvcHMudG91Y2g7XG4gICAgdmFyIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDAsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG5cbiAgICBpZiAoaXNBbHJlYWR5VmlzaWJsZSB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkIHx8IGlzVG91Y2hBbmRUb3VjaERpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBOb3JtYWxpemUgYGRpc2FibGVkYCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgLy8gRmlyZWZveCBhbGxvd3MgZXZlbnRzIG9uIGRpc2FibGVkIGVsZW1lbnRzLCBidXQgQ2hyb21lIGRvZXNuJ3QuXG4gICAgLy8gVXNpbmcgYSB3cmFwcGVyIGVsZW1lbnQgKGkuZS4gPHNwYW4+KSBpcyByZWNvbW1lbmRlZC5cblxuXG4gICAgaWYgKGdldEN1cnJlbnRUYXJnZXQoKS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvblNob3cnLCBbaW5zdGFuY2VdLCBmYWxzZSk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMub25TaG93KGluc3RhbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgPSB0cnVlO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIGhhbmRsZVN0eWxlcygpO1xuICAgIGFkZERvY3VtZW50UHJlc3MoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICB9IC8vIElmIGZsaXBwaW5nIHRvIHRoZSBvcHBvc2l0ZSBzaWRlIGFmdGVyIGhpZGluZyBhdCBsZWFzdCBvbmNlLCB0aGVcbiAgICAvLyBhbmltYXRpb24gd2lsbCB1c2UgdGhlIHdyb25nIHBsYWNlbWVudCB3aXRob3V0IHJlc2V0dGluZyB0aGUgZHVyYXRpb25cblxuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHZhciBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gyID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSxcbiAgICAgICAgICBib3ggPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gyLmJveCxcbiAgICAgICAgICBjb250ZW50ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMi5jb250ZW50O1xuXG4gICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIDApO1xuICAgIH1cblxuICAgIG9uRmlyc3RVcGRhdGUgPSBmdW5jdGlvbiBvbkZpcnN0VXBkYXRlKCkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwb3BwZXJJbnN0YTI7XG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlIHx8IGlnbm9yZU9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gdHJ1ZTsgLy8gcmVmbG93XG5cbiAgICAgIHZvaWQgcG9wcGVyLm9mZnNldEhlaWdodDtcbiAgICAgIHBvcHBlci5zdHlsZS50cmFuc2l0aW9uID0gaW5zdGFuY2UucHJvcHMubW92ZVRyYW5zaXRpb247XG5cbiAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoMyA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgICBfYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMy5ib3gsXG4gICAgICAgICAgICBfY29udGVudCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDMuY29udGVudDtcblxuICAgICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW19ib3gsIF9jb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW19ib3gsIF9jb250ZW50XSwgJ3Zpc2libGUnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKTtcbiAgICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuICAgICAgcHVzaElmVW5pcXVlKG1vdW50ZWRJbnN0YW5jZXMsIGluc3RhbmNlKTsgLy8gY2VydGFpbiBtb2RpZmllcnMgKGUuZy4gYG1heFNpemVgKSByZXF1aXJlIGEgc2Vjb25kIHVwZGF0ZSBhZnRlciB0aGVcbiAgICAgIC8vIHBvcHBlciBoYXMgYmVlbiBwb3NpdGlvbmVkIGZvciB0aGUgZmlyc3QgdGltZVxuXG4gICAgICAoX2luc3RhbmNlJHBvcHBlckluc3RhMiA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHBvcHBlckluc3RhMi5mb3JjZVVwZGF0ZSgpO1xuICAgICAgaW52b2tlSG9vaygnb25Nb3VudCcsIFtpbnN0YW5jZV0pO1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uICYmIGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSB0cnVlO1xuICAgICAgICAgIGludm9rZUhvb2soJ29uU2hvd24nLCBbaW5zdGFuY2VdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1vdW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlJykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeUhpZGRlbiA9ICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIHZhciBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLCAxLCBkZWZhdWx0UHJvcHMuZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzQWxyZWFkeUhpZGRlbiB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25IaWRlJywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uSGlkZShpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IGZhbHNlO1xuICAgIGlnbm9yZU9uRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgIGhhbmRsZVN0eWxlcyh0cnVlKTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoNCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoNC5ib3gsXG4gICAgICAgICAgY29udGVudCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDQuY29udGVudDtcblxuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtib3gsIGNvbnRlbnRdLCAnaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgIG9uVHJhbnNpdGlvbmVkT3V0KGR1cmF0aW9uLCBpbnN0YW5jZS51bm1vdW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UudW5tb3VudCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGVXaXRoSW50ZXJhY3Rpdml0eShldmVudCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlV2l0aEludGVyYWN0aXZpdHknKSk7XG4gICAgfVxuXG4gICAgZ2V0RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgcHVzaElmVW5pcXVlKG1vdXNlTW92ZUxpc3RlbmVycywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3VubW91bnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7IC8vIElmIGEgcG9wcGVyIGlzIG5vdCBpbnRlcmFjdGl2ZSwgaXQgd2lsbCBiZSBhcHBlbmRlZCBvdXRzaWRlIHRoZSBwb3BwZXJcbiAgICAvLyB0cmVlIGJ5IGRlZmF1bHQuIFRoaXMgc2VlbXMgbWFpbmx5IGZvciBpbnRlcmFjdGl2ZSB0aXBwaWVzLCBidXQgd2Ugc2hvdWxkXG4gICAgLy8gZmluZCBhIHdvcmthcm91bmQgaWYgcG9zc2libGVcblxuICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWRQb3BwZXIpIHtcbiAgICAgIG5lc3RlZFBvcHBlci5fdGlwcHkudW5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBvcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICBwb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIG1vdW50ZWRJbnN0YW5jZXMgPSBtb3VudGVkSW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkgIT09IGluc3RhbmNlO1xuICAgIH0pO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGludm9rZUhvb2soJ29uSGlkZGVuJywgW2luc3RhbmNlXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdkZXN0cm95JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGluc3RhbmNlLnVubW91bnQoKTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBkZWxldGUgcmVmZXJlbmNlLl90aXBweTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgaW52b2tlSG9vaygnb25EZXN0cm95JywgW2luc3RhbmNlXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGlwcHkodGFyZ2V0cywgb3B0aW9uYWxQcm9wcykge1xuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBkZWZhdWx0UHJvcHMucGx1Z2lucy5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVUYXJnZXRzKHRhcmdldHMpO1xuICAgIHZhbGlkYXRlUHJvcHMob3B0aW9uYWxQcm9wcywgcGx1Z2lucyk7XG4gIH1cblxuICBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgdmFyIHBhc3NlZFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uYWxQcm9wcywge1xuICAgIHBsdWdpbnM6IHBsdWdpbnNcbiAgfSk7XG4gIHZhciBlbGVtZW50cyA9IGdldEFycmF5T2ZFbGVtZW50cyh0YXJnZXRzKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGlzU2luZ2xlQ29udGVudEVsZW1lbnQgPSBpc0VsZW1lbnQocGFzc2VkUHJvcHMuY29udGVudCk7XG4gICAgdmFyIGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50ID0gZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICB3YXJuV2hlbihpc1NpbmdsZUNvbnRlbnRFbGVtZW50ICYmIGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50LCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCBhbiBFbGVtZW50IGFzIHRoZSBgY29udGVudGAgcHJvcCwgYnV0IG1vcmUgdGhhbicsICdvbmUgdGlwcHkgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgYnkgdGhpcyBpbnZvY2F0aW9uLiBUaGlzIG1lYW5zIHRoZScsICdjb250ZW50IGVsZW1lbnQgd2lsbCBvbmx5IGJlIGFwcGVuZGVkIHRvIHRoZSBsYXN0IHRpcHB5IGluc3RhbmNlLicsICdcXG5cXG4nLCAnSW5zdGVhZCwgcGFzcyB0aGUgLmlubmVySFRNTCBvZiB0aGUgZWxlbWVudCwgb3IgdXNlIGEgZnVuY3Rpb24gdGhhdCcsICdyZXR1cm5zIGEgY2xvbmVkIHZlcnNpb24gb2YgdGhlIGVsZW1lbnQgaW5zdGVhZC4nLCAnXFxuXFxuJywgJzEpIGNvbnRlbnQ6IGVsZW1lbnQuaW5uZXJIVE1MXFxuJywgJzIpIGNvbnRlbnQ6ICgpID0+IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpJ10uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZXMgPSBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcmVmZXJlbmNlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gcmVmZXJlbmNlICYmIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBhY2MucHVzaChpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gaXNFbGVtZW50KHRhcmdldHMpID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xufVxuXG50aXBweS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG50aXBweS5zZXREZWZhdWx0UHJvcHMgPSBzZXREZWZhdWx0UHJvcHM7XG50aXBweS5jdXJyZW50SW5wdXQgPSBjdXJyZW50SW5wdXQ7XG52YXIgaGlkZUFsbCA9IGZ1bmN0aW9uIGhpZGVBbGwoX3RlbXApIHtcbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgIGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA9IF9yZWYuZXhjbHVkZSxcbiAgICAgIGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbjtcblxuICBtb3VudGVkSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgdmFyIGlzRXhjbHVkZWQgPSBmYWxzZTtcblxuICAgIGlmIChleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UpIHtcbiAgICAgIGlzRXhjbHVkZWQgPSBpc1JlZmVyZW5jZUVsZW1lbnQoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSA/IGluc3RhbmNlLnJlZmVyZW5jZSA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlIDogaW5zdGFuY2UucG9wcGVyID09PSBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UucG9wcGVyO1xuICAgIH1cblxuICAgIGlmICghaXNFeGNsdWRlZCkge1xuICAgICAgdmFyIG9yaWdpbmFsRHVyYXRpb24gPSBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbjtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgZHVyYXRpb246IG9yaWdpbmFsRHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIGV2ZXJ5IHRpbWUgdGhlIHBvcHBlciBpcyBkZXN0cm95ZWQgKGkuZS4gYSBuZXcgdGFyZ2V0KSwgcmVtb3ZpbmcgdGhlIHN0eWxlc1xuLy8gYW5kIGNhdXNpbmcgdHJhbnNpdGlvbnMgdG8gYnJlYWsgZm9yIHNpbmdsZXRvbnMgd2hlbiB0aGUgY29uc29sZSBpcyBvcGVuLCBidXRcbi8vIG1vc3Qgbm90YWJseSBmb3Igbm9uLXRyYW5zZm9ybSBzdHlsZXMgYmVpbmcgdXNlZCwgYGdwdUFjY2VsZXJhdGlvbjogZmFsc2VgLlxuXG52YXIgYXBwbHlTdHlsZXNNb2RpZmllciA9IE9iamVjdC5hc3NpZ24oe30sIGFwcGx5U3R5bGVzLCB7XG4gIGVmZmVjdDogZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICAgIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9wcGVyOiB7XG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBtYXJnaW46ICcwJ1xuICAgICAgfSxcbiAgICAgIGFycm93OiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9LFxuICAgICAgcmVmZXJlbmNlOiB7fVxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gICAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgICB9IC8vIGludGVudGlvbmFsbHkgcmV0dXJuIG5vIGNsZWFudXAgZnVuY3Rpb25cbiAgICAvLyByZXR1cm4gKCkgPT4geyAuLi4gfVxuXG4gIH1cbn0pO1xuXG52YXIgY3JlYXRlU2luZ2xldG9uID0gZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uKHRpcHB5SW5zdGFuY2VzLCBvcHRpb25hbFByb3BzKSB7XG4gIHZhciBfb3B0aW9uYWxQcm9wcyRwb3BwZXI7XG5cbiAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcldoZW4oIUFycmF5LmlzQXJyYXkodGlwcHlJbnN0YW5jZXMpLCBbJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU2luZ2xldG9uKCkgbXVzdCBiZSBhbiBhcnJheSBvZicsICd0aXBweSBpbnN0YW5jZXMuIFRoZSBwYXNzZWQgdmFsdWUgd2FzJywgU3RyaW5nKHRpcHB5SW5zdGFuY2VzKV0uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBpbmRpdmlkdWFsSW5zdGFuY2VzID0gdGlwcHlJbnN0YW5jZXM7XG4gIHZhciByZWZlcmVuY2VzID0gW107XG4gIHZhciB0cmlnZ2VyVGFyZ2V0cyA9IFtdO1xuICB2YXIgY3VycmVudFRhcmdldDtcbiAgdmFyIG92ZXJyaWRlcyA9IG9wdGlvbmFsUHJvcHMub3ZlcnJpZGVzO1xuICB2YXIgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IFtdO1xuICB2YXIgc2hvd25PbkNyZWF0ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldFRyaWdnZXJUYXJnZXRzKCkge1xuICAgIHRyaWdnZXJUYXJnZXRzID0gaW5kaXZpZHVhbEluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IGluc3RhbmNlLnJlZmVyZW5jZSk7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KGl0ZW0pO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFJlZmVyZW5jZXMoKSB7XG4gICAgcmVmZXJlbmNlcyA9IGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnJlZmVyZW5jZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuYWJsZUluc3RhbmNlcyhpc0VuYWJsZWQpIHtcbiAgICBpbmRpdmlkdWFsSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgIGluc3RhbmNlLmVuYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKSB7XG4gICAgcmV0dXJuIGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG9yaWdpbmFsU2V0UHJvcHMgPSBpbnN0YW5jZS5zZXRQcm9wcztcblxuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgb3JpZ2luYWxTZXRQcm9wcyhwcm9wcyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnJlZmVyZW5jZSA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIHNpbmdsZXRvbi5zZXRQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzID0gb3JpZ2luYWxTZXRQcm9wcztcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gLy8gaGF2ZSB0byBwYXNzIHNpbmdsZXRvbiwgYXMgaXQgbWF5YmUgdW5kZWZpbmVkIG9uIGZpcnN0IGNhbGxcblxuXG4gIGZ1bmN0aW9uIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHRhcmdldCkge1xuICAgIHZhciBpbmRleCA9IHRyaWdnZXJUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTsgLy8gYmFpbC1vdXRcblxuICAgIGlmICh0YXJnZXQgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHZhciBvdmVycmlkZVByb3BzID0gKG92ZXJyaWRlcyB8fCBbXSkuY29uY2F0KCdjb250ZW50JykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgIGFjY1twcm9wXSA9IGluZGl2aWR1YWxJbnN0YW5jZXNbaW5kZXhdLnByb3BzW3Byb3BdO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgc2luZ2xldG9uLnNldFByb3BzKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlUHJvcHMsIHtcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IHR5cGVvZiBvdmVycmlkZVByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgPT09ICdmdW5jdGlvbicgPyBvdmVycmlkZVByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmZXJlbmNlcyRpbmRleDtcblxuICAgICAgICByZXR1cm4gKF9yZWZlcmVuY2VzJGluZGV4ID0gcmVmZXJlbmNlc1tpbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfcmVmZXJlbmNlcyRpbmRleC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICBzZXRSZWZlcmVuY2VzKCk7XG4gIHNldFRyaWdnZXJUYXJnZXRzKCk7XG4gIHZhciBwbHVnaW4gPSB7XG4gICAgZm46IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7XG4gICAgICAgICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7XG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbiBvbkNsaWNrT3V0c2lkZShpbnN0YW5jZSkge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zaG93T25DcmVhdGUgJiYgIXNob3duT25DcmVhdGUpIHtcbiAgICAgICAgICAgIHNob3duT25DcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdyhpbnN0YW5jZSkge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zaG93T25DcmVhdGUgJiYgIXNob3duT25DcmVhdGUpIHtcbiAgICAgICAgICAgIHNob3duT25DcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcHJlcGFyZUluc3RhbmNlKGluc3RhbmNlLCByZWZlcmVuY2VzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKGluc3RhbmNlLCBldmVudCkge1xuICAgICAgICAgIHByZXBhcmVJbnN0YW5jZShpbnN0YW5jZSwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB2YXIgc2luZ2xldG9uID0gdGlwcHkoZGl2KCksIE9iamVjdC5hc3NpZ24oe30sIHJlbW92ZVByb3BlcnRpZXMob3B0aW9uYWxQcm9wcywgWydvdmVycmlkZXMnXSksIHtcbiAgICBwbHVnaW5zOiBbcGx1Z2luXS5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKSxcbiAgICB0cmlnZ2VyVGFyZ2V0OiB0cmlnZ2VyVGFyZ2V0cyxcbiAgICBwb3BwZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25hbFByb3BzLnBvcHBlck9wdGlvbnMsIHtcbiAgICAgIG1vZGlmaWVyczogW10uY29uY2F0KCgoX29wdGlvbmFsUHJvcHMkcG9wcGVyID0gb3B0aW9uYWxQcm9wcy5wb3BwZXJPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbmFsUHJvcHMkcG9wcGVyLm1vZGlmaWVycykgfHwgW10sIFthcHBseVN0eWxlc01vZGlmaWVyXSlcbiAgICB9KVxuICB9KSk7XG4gIHZhciBvcmlnaW5hbFNob3cgPSBzaW5nbGV0b24uc2hvdztcblxuICBzaW5nbGV0b24uc2hvdyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBvcmlnaW5hbFNob3coKTsgLy8gZmlyc3QgdGltZSwgc2hvd09uQ3JlYXRlIG9yIHByb2dyYW1tYXRpYyBjYWxsIHdpdGggbm8gcGFyYW1zXG4gICAgLy8gZGVmYXVsdCB0byBzaG93aW5nIGZpcnN0IGluc3RhbmNlXG5cbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQgJiYgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWZlcmVuY2VzWzBdKTtcbiAgICB9IC8vIHRyaWdnZXJlZCBmcm9tIGV2ZW50IChkbyBub3RoaW5nIGFzIHByZXBhcmVJbnN0YW5jZSBhbHJlYWR5IGNhbGxlZCBieSBvblRyaWdnZXIpXG4gICAgLy8gcHJvZ3JhbW1hdGljIGNhbGwgd2l0aCBubyBwYXJhbXMgd2hlbiBhbHJlYWR5IHZpc2libGUgKGRvIG5vdGhpbmcgYWdhaW4pXG5cblxuICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB0YXJnZXQgaXMgaW5kZXggb2YgaW5zdGFuY2VcblxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmVmZXJlbmNlc1t0YXJnZXRdICYmIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZmVyZW5jZXNbdGFyZ2V0XSk7XG4gICAgfSAvLyB0YXJnZXQgaXMgYSBjaGlsZCB0aXBweSBpbnN0YW5jZVxuXG5cbiAgICBpZiAoaW5kaXZpZHVhbEluc3RhbmNlcy5pbmRleE9mKHRhcmdldCkgPj0gMCkge1xuICAgICAgdmFyIHJlZiA9IHRhcmdldC5yZWZlcmVuY2U7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmKTtcbiAgICB9IC8vIHRhcmdldCBpcyBhIFJlZmVyZW5jZUVsZW1lbnRcblxuXG4gICAgaWYgKHJlZmVyZW5jZXMuaW5kZXhPZih0YXJnZXQpID49IDApIHtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCB0YXJnZXQpO1xuICAgIH1cbiAgfTtcblxuICBzaW5nbGV0b24uc2hvd05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0ID0gcmVmZXJlbmNlc1swXTtcblxuICAgIGlmICghY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbi5zaG93KDApO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHJlZmVyZW5jZXMuaW5kZXhPZihjdXJyZW50VGFyZ2V0KTtcbiAgICBzaW5nbGV0b24uc2hvdyhyZWZlcmVuY2VzW2luZGV4ICsgMV0gfHwgZmlyc3QpO1xuICB9O1xuXG4gIHNpbmdsZXRvbi5zaG93UHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3QgPSByZWZlcmVuY2VzW3JlZmVyZW5jZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b24uc2hvdyhsYXN0KTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgdmFyIHRhcmdldCA9IHJlZmVyZW5jZXNbaW5kZXggLSAxXSB8fCBsYXN0O1xuICAgIHNpbmdsZXRvbi5zaG93KHRhcmdldCk7XG4gIH07XG5cbiAgdmFyIG9yaWdpbmFsU2V0UHJvcHMgPSBzaW5nbGV0b24uc2V0UHJvcHM7XG5cbiAgc2luZ2xldG9uLnNldFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgb3ZlcnJpZGVzID0gcHJvcHMub3ZlcnJpZGVzIHx8IG92ZXJyaWRlcztcbiAgICBvcmlnaW5hbFNldFByb3BzKHByb3BzKTtcbiAgfTtcblxuICBzaW5nbGV0b24uc2V0SW5zdGFuY2VzID0gZnVuY3Rpb24gKG5leHRJbnN0YW5jZXMpIHtcbiAgICBlbmFibGVJbnN0YW5jZXModHJ1ZSk7XG4gICAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSk7XG4gICAgaW5kaXZpZHVhbEluc3RhbmNlcyA9IG5leHRJbnN0YW5jZXM7XG4gICAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgICBzZXRSZWZlcmVuY2VzKCk7XG4gICAgc2V0VHJpZ2dlclRhcmdldHMoKTtcbiAgICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKTtcbiAgICBzaW5nbGV0b24uc2V0UHJvcHMoe1xuICAgICAgdHJpZ2dlclRhcmdldDogdHJpZ2dlclRhcmdldHNcbiAgICB9KTtcbiAgfTtcblxuICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKTtcbiAgcmV0dXJuIHNpbmdsZXRvbjtcbn07XG5cbnZhciBCVUJCTElOR19FVkVOVFNfTUFQID0ge1xuICBtb3VzZW92ZXI6ICdtb3VzZWVudGVyJyxcbiAgZm9jdXNpbjogJ2ZvY3VzJyxcbiAgY2xpY2s6ICdjbGljaydcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBkZWxlZ2F0ZSBpbnN0YW5jZSB0aGF0IGNvbnRyb2xzIHRoZSBjcmVhdGlvbiBvZiB0aXBweSBpbnN0YW5jZXNcbiAqIGZvciBjaGlsZCBlbGVtZW50cyAoYHRhcmdldGAgQ1NTIHNlbGVjdG9yKS5cbiAqL1xuXG5mdW5jdGlvbiBkZWxlZ2F0ZSh0YXJnZXRzLCBwcm9wcykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JXaGVuKCEocHJvcHMgJiYgcHJvcHMudGFyZ2V0KSwgWydZb3UgbXVzdCBzcGVjaXR5IGEgYHRhcmdldGAgcHJvcCBpbmRpY2F0aW5nIGEgQ1NTIHNlbGVjdG9yIHN0cmluZyBtYXRjaGluZycsICd0aGUgdGFyZ2V0IGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlY2VpdmUgYSB0aXBweS4nXS5qb2luKCcgJykpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgdmFyIHRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgdmFyIG5hdGl2ZVByb3BzID0gcmVtb3ZlUHJvcGVydGllcyhwcm9wcywgWyd0YXJnZXQnXSk7XG4gIHZhciBwYXJlbnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG5hdGl2ZVByb3BzLCB7XG4gICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgdG91Y2g6IGZhbHNlXG4gIH0pO1xuICB2YXIgY2hpbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHRvdWNoOiBkZWZhdWx0UHJvcHMudG91Y2hcbiAgfSwgbmF0aXZlUHJvcHMsIHtcbiAgICBzaG93T25DcmVhdGU6IHRydWVcbiAgfSk7XG4gIHZhciByZXR1cm5WYWx1ZSA9IHRpcHB5KHRhcmdldHMsIHBhcmVudFByb3BzKTtcbiAgdmFyIG5vcm1hbGl6ZWRSZXR1cm5WYWx1ZSA9IG5vcm1hbGl6ZVRvQXJyYXkocmV0dXJuVmFsdWUpO1xuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudCkge1xuICAgIGlmICghZXZlbnQudGFyZ2V0IHx8IGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSBldmVudC50YXJnZXQuY2xvc2VzdCh0YXJnZXQpO1xuXG4gICAgaWYgKCF0YXJnZXROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgcmVsZXZhbnQgdHJpZ2dlciB3aXRoIGZhbGxiYWNrczpcbiAgICAvLyAxLiBDaGVjayBgZGF0YS10aXBweS10cmlnZ2VyYCBhdHRyaWJ1dGUgb24gdGFyZ2V0IG5vZGVcbiAgICAvLyAyLiBGYWxsYmFjayB0byBgdHJpZ2dlcmAgcGFzc2VkIHRvIGBkZWxlZ2F0ZSgpYFxuICAgIC8vIDMuIEZhbGxiYWNrIHRvIGBkZWZhdWx0UHJvcHMudHJpZ2dlcmBcblxuXG4gICAgdmFyIHRyaWdnZXIgPSB0YXJnZXROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS10aXBweS10cmlnZ2VyJykgfHwgcHJvcHMudHJpZ2dlciB8fCBkZWZhdWx0UHJvcHMudHJpZ2dlcjsgLy8gQHRzLWlnbm9yZVxuXG4gICAgaWYgKHRhcmdldE5vZGUuX3RpcHB5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiB0eXBlb2YgY2hpbGRQcm9wcy50b3VjaCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgIT09ICd0b3VjaHN0YXJ0JyAmJiB0cmlnZ2VyLmluZGV4T2YoQlVCQkxJTkdfRVZFTlRTX01BUFtldmVudC50eXBlXSkgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gdGlwcHkodGFyZ2V0Tm9kZSwgY2hpbGRQcm9wcyk7XG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBjaGlsZFRpcHB5SW5zdGFuY2VzLmNvbmNhdChpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb24obm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgb24ocmVmZXJlbmNlLCAndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgb24ocmVmZXJlbmNlLCAnbW91c2VvdmVyJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdmb2N1c2luJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdjbGljaycsIG9uVHJpZ2dlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgZXZlbnRUeXBlID0gX3JlZi5ldmVudFR5cGUsXG4gICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseU11dGF0aW9ucyhpbnN0YW5jZSkge1xuICAgIHZhciBvcmlnaW5hbERlc3Ryb3kgPSBpbnN0YW5jZS5kZXN0cm95O1xuICAgIHZhciBvcmlnaW5hbEVuYWJsZSA9IGluc3RhbmNlLmVuYWJsZTtcbiAgICB2YXIgb3JpZ2luYWxEaXNhYmxlID0gaW5zdGFuY2UuZGlzYWJsZTtcblxuICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvcmlnaW5hbEVuYWJsZSgpO1xuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZW5hYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGluc3RhbmNlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvcmlnaW5hbERpc2FibGUoKTtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmRpc2FibGUoKTtcbiAgICAgIH0pO1xuICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICBub3JtYWxpemVkUmV0dXJuVmFsdWUuZm9yRWFjaChhcHBseU11dGF0aW9ucyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxudmFyIGFuaW1hdGVGaWxsID0ge1xuICBuYW1lOiAnYW5pbWF0ZUZpbGwnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlJHByb3BzJHJlbmRlO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghKChfaW5zdGFuY2UkcHJvcHMkcmVuZGUgPSBpbnN0YW5jZS5wcm9wcy5yZW5kZXIpICE9IG51bGwgJiYgX2luc3RhbmNlJHByb3BzJHJlbmRlLiQkdGlwcHkpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yV2hlbihpbnN0YW5jZS5wcm9wcy5hbmltYXRlRmlsbCwgJ1RoZSBgYW5pbWF0ZUZpbGxgIHBsdWdpbiByZXF1aXJlcyB0aGUgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgX2dldENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaW5zdGFuY2UucG9wcGVyKSxcbiAgICAgICAgYm94ID0gX2dldENoaWxkcmVuLmJveCxcbiAgICAgICAgY29udGVudCA9IF9nZXRDaGlsZHJlbi5jb250ZW50O1xuXG4gICAgdmFyIGJhY2tkcm9wID0gaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGwgPyBjcmVhdGVCYWNrZHJvcEVsZW1lbnQoKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYm94Lmluc2VydEJlZm9yZShiYWNrZHJvcCwgYm94LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGVmaWxsJywgJycpO1xuICAgICAgICAgIGJveC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgIGFycm93OiBmYWxzZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogJ3NoaWZ0LWF3YXknXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gYm94LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBOdW1iZXIodHJhbnNpdGlvbkR1cmF0aW9uLnJlcGxhY2UoJ21zJywgJycpKTsgLy8gVGhlIGNvbnRlbnQgc2hvdWxkIGZhZGUgaW4gYWZ0ZXIgdGhlIGJhY2tkcm9wIGhhcyBtb3N0bHkgZmlsbGVkIHRoZVxuICAgICAgICAgIC8vIHRvb2x0aXAgZWxlbWVudC4gYGNsaXAtcGF0aGAgaXMgdGhlIG90aGVyIGFsdGVybmF0aXZlIGJ1dCBpcyBub3RcbiAgICAgICAgICAvLyB3ZWxsLXN1cHBvcnRlZCBhbmQgaXMgYnVnZ3kgb24gc29tZSBkZXZpY2VzLlxuXG4gICAgICAgICAgY29udGVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBNYXRoLnJvdW5kKGR1cmF0aW9uIC8gMTApICsgXCJtc1wiO1xuICAgICAgICAgIGJhY2tkcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ3Zpc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMG1zJztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCkge1xuICB2YXIgYmFja2Ryb3AgPSBkaXYoKTtcbiAgYmFja2Ryb3AuY2xhc3NOYW1lID0gQkFDS0RST1BfQ0xBU1M7XG4gIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gIHJldHVybiBiYWNrZHJvcDtcbn1cblxudmFyIG1vdXNlQ29vcmRzID0ge1xuICBjbGllbnRYOiAwLFxuICBjbGllbnRZOiAwXG59O1xudmFyIGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xuXG5mdW5jdGlvbiBzdG9yZU1vdXNlQ29vcmRzKF9yZWYpIHtcbiAgdmFyIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuICBtb3VzZUNvb3JkcyA9IHtcbiAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgIGNsaWVudFk6IGNsaWVudFlcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpIHtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0b3JlTW91c2VDb29yZHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYykge1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RvcmVNb3VzZUNvb3Jkcyk7XG59XG5cbnZhciBmb2xsb3dDdXJzb3IgPSB7XG4gIG5hbWU6ICdmb2xsb3dDdXJzb3InLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIHZhciBkb2MgPSBnZXRPd25lckRvY3VtZW50KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICB2YXIgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIHZhciB3YXNGb2N1c0V2ZW50ID0gZmFsc2U7XG4gICAgdmFyIGlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0luaXRpYWxCZWhhdmlvcigpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgPT09ICdpbml0aWFsJyAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoKSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QoKSB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbFxuICAgICAgfSk7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIC8vIElmIHRoZSBpbnN0YW5jZSBpcyBpbnRlcmFjdGl2ZSwgYXZvaWQgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHVubGVzcyBpdCdzXG4gICAgICAvLyBvdmVyIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgICAgdmFyIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSA9IGV2ZW50LnRhcmdldCA/IHJlZmVyZW5jZS5jb250YWlucyhldmVudC50YXJnZXQpIDogdHJ1ZTtcbiAgICAgIHZhciBmb2xsb3dDdXJzb3IgPSBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3I7XG4gICAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB2YXIgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByZWxhdGl2ZVggPSBjbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgdmFyIHJlbGF0aXZlWSA9IGNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgICAgaWYgKGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSB8fCAhaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB1bm5lZWRlZCBET01SZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgeCA9IGNsaWVudFg7XG4gICAgICAgICAgICB2YXIgeSA9IGNsaWVudFk7XG5cbiAgICAgICAgICAgIGlmIChmb2xsb3dDdXJzb3IgPT09ICdpbml0aWFsJykge1xuICAgICAgICAgICAgICB4ID0gcmVjdC5sZWZ0ICsgcmVsYXRpdmVYO1xuICAgICAgICAgICAgICB5ID0gcmVjdC50b3AgKyByZWxhdGl2ZVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3AgPSBmb2xsb3dDdXJzb3IgPT09ICdob3Jpem9udGFsJyA/IHJlY3QudG9wIDogeTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGZvbGxvd0N1cnNvciA9PT0gJ3ZlcnRpY2FsJyA/IHJlY3QucmlnaHQgOiB4O1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnID8gcmVjdC5ib3R0b20gOiB5O1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCcgPyByZWN0LmxlZnQgOiB4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3AsXG4gICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICBhY3RpdmVJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgIGRvYzogZG9jXG4gICAgICAgIH0pO1xuICAgICAgICBhZGRNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlcyA9IGFjdGl2ZUluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuaW5zdGFuY2UgIT09IGluc3RhbmNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhY3RpdmVJbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmRvYyA9PT0gZG9jO1xuICAgICAgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGNyZWF0ZSxcbiAgICAgIG9uRGVzdHJveTogZGVzdHJveSxcbiAgICAgIG9uQmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBvbkJlZm9yZVVwZGF0ZSgpIHtcbiAgICAgICAgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB9LFxuICAgICAgb25BZnRlclVwZGF0ZTogZnVuY3Rpb24gb25BZnRlclVwZGF0ZShfLCBfcmVmMikge1xuICAgICAgICB2YXIgZm9sbG93Q3Vyc29yID0gX3JlZjIuZm9sbG93Q3Vyc29yO1xuXG4gICAgICAgIGlmIChpc0ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvbGxvd0N1cnNvciAhPT0gdW5kZWZpbmVkICYmIHByZXZQcm9wcy5mb2xsb3dDdXJzb3IgIT09IGZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIGRlc3Ryb3koKTtcblxuICAgICAgICAgIGlmIChmb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICAgIGNyZWF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkICYmICF3YXNGb2N1c0V2ZW50ICYmICFnZXRJc0luaXRpYWxCZWhhdmlvcigpKSB7XG4gICAgICAgICAgICAgIGFkZExpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICB1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yICYmICF3YXNGb2N1c0V2ZW50KSB7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZShtb3VzZUNvb3Jkcyk7XG4gICAgICAgICAgICBpc1VubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihfLCBldmVudCkge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIG1vdXNlQ29vcmRzID0ge1xuICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2FzRm9jdXNFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdmb2N1cyc7XG4gICAgICB9LFxuICAgICAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wcyhwcm9wcywgbW9kaWZpZXIpIHtcbiAgdmFyIF9wcm9wcyRwb3BwZXJPcHRpb25zO1xuXG4gIHJldHVybiB7XG4gICAgcG9wcGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucG9wcGVyT3B0aW9ucywge1xuICAgICAgbW9kaWZpZXJzOiBbXS5jb25jYXQoKCgoX3Byb3BzJHBvcHBlck9wdGlvbnMgPSBwcm9wcy5wb3BwZXJPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJHBvcHBlck9wdGlvbnMubW9kaWZpZXJzKSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICByZXR1cm4gbmFtZSAhPT0gbW9kaWZpZXIubmFtZTtcbiAgICAgIH0pLCBbbW9kaWZpZXJdKVxuICAgIH0pXG4gIH07XG59XG5cbnZhciBpbmxpbmVQb3NpdGlvbmluZyA9IHtcbiAgbmFtZTogJ2lubGluZVBvc2l0aW9uaW5nJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcblxuICAgIGZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiAhIWluc3RhbmNlLnByb3BzLmlubGluZVBvc2l0aW9uaW5nO1xuICAgIH1cblxuICAgIHZhciBwbGFjZW1lbnQ7XG4gICAgdmFyIGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgIHZhciBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgdmFyIHRyaWVkUGxhY2VtZW50cyA9IFtdO1xuICAgIHZhciBtb2RpZmllciA9IHtcbiAgICAgIG5hbWU6ICd0aXBweUlubGluZVBvc2l0aW9uaW5nJyxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgICAgZm46IGZ1bmN0aW9uIGZuKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuXG4gICAgICAgIGlmIChpc0VuYWJsZWQoKSkge1xuICAgICAgICAgIGlmICh0cmllZFBsYWNlbWVudHMuaW5kZXhPZihzdGF0ZS5wbGFjZW1lbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gc3RhdGUucGxhY2VtZW50ICYmIHRyaWVkUGxhY2VtZW50cy5pbmRleE9mKHN0YXRlLnBsYWNlbWVudCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0cmllZFBsYWNlbWVudHMucHVzaChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IGZ1bmN0aW9uIGdldFJlZmVyZW5jZUNsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWZlcmVuY2VDbGllbnRSZWN0KHN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBsYWNlbWVudCA9IHN0YXRlLnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpLCByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFycmF5RnJvbShyZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSksIGN1cnNvclJlY3RJbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJuYWxQcm9wcyhwYXJ0aWFsUHJvcHMpIHtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSB0cnVlO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMocGFydGlhbFByb3BzKTtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRNb2RpZmllcigpIHtcbiAgICAgIGlmICghaXNJbnRlcm5hbFVwZGF0ZSkge1xuICAgICAgICBzZXRJbnRlcm5hbFByb3BzKGdldFByb3BzKGluc3RhbmNlLnByb3BzLCBtb2RpZmllcikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogYWRkTW9kaWZpZXIsXG4gICAgICBvbkFmdGVyVXBkYXRlOiBhZGRNb2RpZmllcixcbiAgICAgIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKF8sIGV2ZW50KSB7XG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgdmFyIHJlY3RzID0gYXJyYXlGcm9tKGluc3RhbmNlLnJlZmVyZW5jZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgICAgICB2YXIgY3Vyc29yUmVjdCA9IHJlY3RzLmZpbmQoZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0LmxlZnQgLSAyIDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCArIDIgPj0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnRvcCAtIDIgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSArIDIgPj0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW5kZXggPSByZWN0cy5pbmRleE9mKGN1cnNvclJlY3QpO1xuICAgICAgICAgIGN1cnNvclJlY3RJbmRleCA9IGluZGV4ID4gLTEgPyBpbmRleCA6IGN1cnNvclJlY3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChjdXJyZW50QmFzZVBsYWNlbWVudCwgYm91bmRpbmdSZWN0LCBjbGllbnRSZWN0cywgY3Vyc29yUmVjdEluZGV4KSB7XG4gIC8vIE5vdCBhbiBpbmxpbmUgZWxlbWVudCwgb3IgcGxhY2VtZW50IGlzIG5vdCB5ZXQga25vd25cbiAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA8IDIgfHwgY3VycmVudEJhc2VQbGFjZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICB9IC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZFxuXG5cbiAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjdXJzb3JSZWN0SW5kZXggPj0gMCAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQpIHtcbiAgICByZXR1cm4gY2xpZW50UmVjdHNbY3Vyc29yUmVjdEluZGV4XSB8fCBib3VuZGluZ1JlY3Q7XG4gIH1cblxuICBzd2l0Y2ggKGN1cnJlbnRCYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAge1xuICAgICAgICB2YXIgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgIHZhciBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNUb3AgPSBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ3RvcCc7XG4gICAgICAgIHZhciB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICB2YXIgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICB2YXIgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB7XG4gICAgICAgIHZhciBtaW5MZWZ0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgY2xpZW50UmVjdHMubWFwKGZ1bmN0aW9uIChyZWN0cykge1xuICAgICAgICAgIHJldHVybiByZWN0cy5sZWZ0O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBtYXhSaWdodCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGNsaWVudFJlY3RzLm1hcChmdW5jdGlvbiAocmVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdHMucmlnaHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX3RvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgIHZhciBfYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgIHZhciBfbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgIHZhciBfcmlnaHQgPSBtYXhSaWdodDtcblxuICAgICAgICB2YXIgX3dpZHRoID0gX3JpZ2h0IC0gX2xlZnQ7XG5cbiAgICAgICAgdmFyIF9oZWlnaHQgPSBfYm90dG9tIC0gX3RvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogX3RvcCxcbiAgICAgICAgICBib3R0b206IF9ib3R0b20sXG4gICAgICAgICAgbGVmdDogX2xlZnQsXG4gICAgICAgICAgcmlnaHQ6IF9yaWdodCxcbiAgICAgICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgICAgIH1cbiAgfVxufVxuXG52YXIgc3RpY2t5ID0ge1xuICBuYW1lOiAnc3RpY2t5JyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gaW5zdGFuY2UucG9wcGVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID8gaW5zdGFuY2UucG9wcGVySW5zdGFuY2Uuc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlIDogcmVmZXJlbmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZENoZWNrKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMuc3RpY2t5ID09PSB0cnVlIHx8IGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHByZXZSZWZSZWN0ID0gbnVsbDtcbiAgICB2YXIgcHJldlBvcFJlY3QgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICB2YXIgY3VycmVudFJlZlJlY3QgPSBzaG91bGRDaGVjaygncmVmZXJlbmNlJykgPyBnZXRSZWZlcmVuY2UoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG4gICAgICB2YXIgY3VycmVudFBvcFJlY3QgPSBzaG91bGRDaGVjaygncG9wcGVyJykgPyBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuXG4gICAgICBpZiAoY3VycmVudFJlZlJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlJlZlJlY3QsIGN1cnJlbnRSZWZSZWN0KSB8fCBjdXJyZW50UG9wUmVjdCAmJiBhcmVSZWN0c0RpZmZlcmVudChwcmV2UG9wUmVjdCwgY3VycmVudFBvcFJlY3QpKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZSZWZSZWN0ID0gY3VycmVudFJlZlJlY3Q7XG4gICAgICBwcmV2UG9wUmVjdCA9IGN1cnJlbnRQb3BSZWN0O1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zdGlja3kpIHtcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlUmVjdHNEaWZmZXJlbnQocmVjdEEsIHJlY3RCKSB7XG4gIGlmIChyZWN0QSAmJiByZWN0Qikge1xuICAgIHJldHVybiByZWN0QS50b3AgIT09IHJlY3RCLnRvcCB8fCByZWN0QS5yaWdodCAhPT0gcmVjdEIucmlnaHQgfHwgcmVjdEEuYm90dG9tICE9PSByZWN0Qi5ib3R0b20gfHwgcmVjdEEubGVmdCAhPT0gcmVjdEIubGVmdDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG50aXBweS5zZXREZWZhdWx0UHJvcHMoe1xuICByZW5kZXI6IHJlbmRlclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRpcHB5O1xuZXhwb3J0IHsgYW5pbWF0ZUZpbGwsIGNyZWF0ZVNpbmdsZXRvbiwgZGVsZWdhdGUsIGZvbGxvd0N1cnNvciwgaGlkZUFsbCwgaW5saW5lUG9zaXRpb25pbmcsIFJPVU5EX0FSUk9XIGFzIHJvdW5kQXJyb3csIHN0aWNreSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlwcHkuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZVBvcHBlciIsImFwcGx5U3R5bGVzIiwiUk9VTkRfQVJST1ciLCJCT1hfQ0xBU1MiLCJDT05URU5UX0NMQVNTIiwiQkFDS0RST1BfQ0xBU1MiLCJBUlJPV19DTEFTUyIsIlNWR19BUlJPV19DTEFTUyIsIlRPVUNIX09QVElPTlMiLCJwYXNzaXZlIiwiY2FwdHVyZSIsIlRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPIiwiZG9jdW1lbnQiLCJib2R5IiwiaGFzT3duUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJjYWxsIiwiZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4iLCJ2YWx1ZSIsImluZGV4IiwiZGVmYXVsdFZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsImlzVHlwZSIsInR5cGUiLCJzdHIiLCJ0b1N0cmluZyIsImluZGV4T2YiLCJpbnZva2VXaXRoQXJnc09yUmV0dXJuIiwiYXJncyIsImFwcGx5IiwiZGVib3VuY2UiLCJmbiIsIm1zIiwidGltZW91dCIsImFyZyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJyZW1vdmVQcm9wZXJ0aWVzIiwia2V5cyIsImNsb25lIiwiT2JqZWN0IiwiYXNzaWduIiwiZm9yRWFjaCIsInNwbGl0QnlTcGFjZXMiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJub3JtYWxpemVUb0FycmF5IiwiY29uY2F0IiwicHVzaElmVW5pcXVlIiwiYXJyIiwicHVzaCIsInVuaXF1ZSIsIml0ZW0iLCJnZXRCYXNlUGxhY2VtZW50IiwicGxhY2VtZW50IiwiYXJyYXlGcm9tIiwic2xpY2UiLCJyZW1vdmVVbmRlZmluZWRQcm9wcyIsInJlZHVjZSIsImFjYyIsInVuZGVmaW5lZCIsImRpdiIsImNyZWF0ZUVsZW1lbnQiLCJpc0VsZW1lbnQiLCJzb21lIiwiaXNOb2RlTGlzdCIsImlzTW91c2VFdmVudCIsImlzUmVmZXJlbmNlRWxlbWVudCIsIl90aXBweSIsInJlZmVyZW5jZSIsImdldEFycmF5T2ZFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZXRUcmFuc2l0aW9uRHVyYXRpb24iLCJlbHMiLCJlbCIsInN0eWxlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic2V0VmlzaWJpbGl0eVN0YXRlIiwic3RhdGUiLCJzZXRBdHRyaWJ1dGUiLCJnZXRPd25lckRvY3VtZW50IiwiZWxlbWVudE9yRWxlbWVudHMiLCJfZWxlbWVudCRvd25lckRvY3VtZW4iLCJfbm9ybWFsaXplVG9BcnJheSIsImVsZW1lbnQiLCJvd25lckRvY3VtZW50IiwiaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIiLCJwb3BwZXJUcmVlRGF0YSIsImV2ZW50IiwiY2xpZW50WCIsImNsaWVudFkiLCJldmVyeSIsIl9yZWYiLCJwb3BwZXJSZWN0IiwicG9wcGVyU3RhdGUiLCJwcm9wcyIsImludGVyYWN0aXZlQm9yZGVyIiwiYmFzZVBsYWNlbWVudCIsIm9mZnNldERhdGEiLCJtb2RpZmllcnNEYXRhIiwib2Zmc2V0IiwidG9wRGlzdGFuY2UiLCJ0b3AiLCJ5IiwiYm90dG9tRGlzdGFuY2UiLCJib3R0b20iLCJsZWZ0RGlzdGFuY2UiLCJsZWZ0IiwieCIsInJpZ2h0RGlzdGFuY2UiLCJyaWdodCIsImV4Y2VlZHNUb3AiLCJleGNlZWRzQm90dG9tIiwiZXhjZWVkc0xlZnQiLCJleGNlZWRzUmlnaHQiLCJ1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIiLCJib3giLCJhY3Rpb24iLCJsaXN0ZW5lciIsIm1ldGhvZCIsImFjdHVhbENvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJ0YXJnZXQiLCJfdGFyZ2V0JGdldFJvb3ROb2RlIiwiY29udGFpbnMiLCJnZXRSb290Tm9kZSIsImhvc3QiLCJjdXJyZW50SW5wdXQiLCJpc1RvdWNoIiwibGFzdE1vdXNlTW92ZVRpbWUiLCJvbkRvY3VtZW50VG91Y2hTdGFydCIsIndpbmRvdyIsInBlcmZvcm1hbmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uRG9jdW1lbnRNb3VzZU1vdmUiLCJub3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25XaW5kb3dCbHVyIiwiYWN0aXZlRWxlbWVudCIsImluc3RhbmNlIiwiYmx1ciIsImlzVmlzaWJsZSIsImJpbmRHbG9iYWxFdmVudExpc3RlbmVycyIsImlzQnJvd3NlciIsImlzSUUxMSIsIm1zQ3J5cHRvIiwiY3JlYXRlTWVtb3J5TGVha1dhcm5pbmciLCJ0eHQiLCJqb2luIiwiY2xlYW4iLCJzcGFjZXNBbmRUYWJzIiwibGluZVN0YXJ0V2l0aFNwYWNlcyIsInJlcGxhY2UiLCJ0cmltIiwiZ2V0RGV2TWVzc2FnZSIsIm1lc3NhZ2UiLCJnZXRGb3JtYXR0ZWRNZXNzYWdlIiwidmlzaXRlZE1lc3NhZ2VzIiwicHJvY2VzcyIsInJlc2V0VmlzaXRlZE1lc3NhZ2VzIiwiU2V0Iiwid2FybldoZW4iLCJjb25kaXRpb24iLCJoYXMiLCJfY29uc29sZSIsImFkZCIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyb3JXaGVuIiwiX2NvbnNvbGUyIiwiZXJyb3IiLCJ2YWxpZGF0ZVRhcmdldHMiLCJ0YXJnZXRzIiwiZGlkUGFzc0ZhbHN5VmFsdWUiLCJkaWRQYXNzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJTdHJpbmciLCJwbHVnaW5Qcm9wcyIsImFuaW1hdGVGaWxsIiwiZm9sbG93Q3Vyc29yIiwiaW5saW5lUG9zaXRpb25pbmciLCJzdGlja3kiLCJyZW5kZXJQcm9wcyIsImFsbG93SFRNTCIsImFuaW1hdGlvbiIsImFycm93IiwiY29udGVudCIsImluZXJ0aWEiLCJtYXhXaWR0aCIsInJvbGUiLCJ0aGVtZSIsInpJbmRleCIsImRlZmF1bHRQcm9wcyIsImFwcGVuZFRvIiwiYXJpYSIsImV4cGFuZGVkIiwiZGVsYXkiLCJkdXJhdGlvbiIsImdldFJlZmVyZW5jZUNsaWVudFJlY3QiLCJoaWRlT25DbGljayIsImlnbm9yZUF0dHJpYnV0ZXMiLCJpbnRlcmFjdGl2ZSIsImludGVyYWN0aXZlRGVib3VuY2UiLCJtb3ZlVHJhbnNpdGlvbiIsIm9uQWZ0ZXJVcGRhdGUiLCJvbkJlZm9yZVVwZGF0ZSIsIm9uQ3JlYXRlIiwib25EZXN0cm95Iiwib25IaWRkZW4iLCJvbkhpZGUiLCJvbk1vdW50Iiwib25TaG93Iiwib25TaG93biIsIm9uVHJpZ2dlciIsIm9uVW50cmlnZ2VyIiwib25DbGlja091dHNpZGUiLCJwbHVnaW5zIiwicG9wcGVyT3B0aW9ucyIsInJlbmRlciIsInNob3dPbkNyZWF0ZSIsInRvdWNoIiwidHJpZ2dlciIsInRyaWdnZXJUYXJnZXQiLCJkZWZhdWx0S2V5cyIsInNldERlZmF1bHRQcm9wcyIsInBhcnRpYWxQcm9wcyIsInZhbGlkYXRlUHJvcHMiLCJnZXRFeHRlbmRlZFBhc3NlZFByb3BzIiwicGFzc2VkUHJvcHMiLCJwbHVnaW4iLCJuYW1lIiwiX25hbWUiLCJnZXREYXRhQXR0cmlidXRlUHJvcHMiLCJwcm9wS2V5cyIsInZhbHVlQXNTdHJpbmciLCJnZXRBdHRyaWJ1dGUiLCJKU09OIiwicGFyc2UiLCJlIiwiZXZhbHVhdGVQcm9wcyIsIm91dCIsInByb3AiLCJub25QbHVnaW5Qcm9wcyIsImRpZFBhc3NVbmtub3duUHJvcCIsImxlbmd0aCIsImlubmVySFRNTCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiaHRtbCIsImNyZWF0ZUFycm93RWxlbWVudCIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwic2V0Q29udGVudCIsInRleHRDb250ZW50IiwiZ2V0Q2hpbGRyZW4iLCJwb3BwZXIiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImJveENoaWxkcmVuIiwiY2hpbGRyZW4iLCJmaW5kIiwibm9kZSIsImNsYXNzTGlzdCIsImJhY2tkcm9wIiwib25VcGRhdGUiLCJwcmV2UHJvcHMiLCJuZXh0UHJvcHMiLCJfZ2V0Q2hpbGRyZW4iLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZW1vdmVDaGlsZCIsIiQkdGlwcHkiLCJpZENvdW50ZXIiLCJtb3VzZU1vdmVMaXN0ZW5lcnMiLCJtb3VudGVkSW5zdGFuY2VzIiwiY3JlYXRlVGlwcHkiLCJzaG93VGltZW91dCIsImhpZGVUaW1lb3V0Iiwic2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUiLCJpc1Zpc2libGVGcm9tQ2xpY2siLCJkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biIsImRpZFRvdWNoTW92ZSIsImlnbm9yZU9uRmlyc3RVcGRhdGUiLCJsYXN0VHJpZ2dlckV2ZW50IiwiY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciIsIm9uRmlyc3RVcGRhdGUiLCJsaXN0ZW5lcnMiLCJkZWJvdW5jZWRPbk1vdXNlTW92ZSIsIm9uTW91c2VNb3ZlIiwiY3VycmVudFRhcmdldCIsImlkIiwicG9wcGVySW5zdGFuY2UiLCJpc0VuYWJsZWQiLCJpc0Rlc3Ryb3llZCIsImlzTW91bnRlZCIsImlzU2hvd24iLCJjbGVhckRlbGF5VGltZW91dHMiLCJzZXRQcm9wcyIsInNob3ciLCJoaWRlIiwiaGlkZVdpdGhJbnRlcmFjdGl2aXR5IiwiZW5hYmxlIiwiZGlzYWJsZSIsInVubW91bnQiLCJkZXN0cm95IiwiX3Byb3BzJHJlbmRlciIsInBsdWdpbnNIb29rcyIsIm1hcCIsImhhc0FyaWFFeHBhbmRlZCIsImhhc0F0dHJpYnV0ZSIsImFkZExpc3RlbmVycyIsImhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSIsImhhbmRsZVN0eWxlcyIsImludm9rZUhvb2siLCJzY2hlZHVsZVNob3ciLCJnZXREb2N1bWVudCIsImdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzIiwiZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yIiwiZ2V0SXNEZWZhdWx0UmVuZGVyRm4iLCJfaW5zdGFuY2UkcHJvcHMkcmVuZGUiLCJnZXRDdXJyZW50VGFyZ2V0IiwicGFyZW50Tm9kZSIsImdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuIiwiZ2V0RGVsYXkiLCJpc1Nob3ciLCJmcm9tSGlkZSIsInBvaW50ZXJFdmVudHMiLCJob29rIiwic2hvdWxkSW52b2tlUHJvcHNIb29rIiwicGx1Z2luSG9va3MiLCJfaW5zdGFuY2UkcHJvcHMiLCJoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSIsImF0dHIiLCJub2RlcyIsImN1cnJlbnRWYWx1ZSIsIm5leHRWYWx1ZSIsImNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzIiwib25Eb2N1bWVudFByZXNzIiwiYWN0dWFsVGFyZ2V0IiwiY29tcG9zZWRQYXRoIiwicmVtb3ZlRG9jdW1lbnRQcmVzcyIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaFN0YXJ0IiwiYWRkRG9jdW1lbnRQcmVzcyIsImRvYyIsIm9uVHJhbnNpdGlvbmVkT3V0IiwiY2FsbGJhY2siLCJvblRyYW5zaXRpb25FbmQiLCJvblRyYW5zaXRpb25lZEluIiwib24iLCJldmVudFR5cGUiLCJoYW5kbGVyIiwib3B0aW9ucyIsIm9uTW91c2VMZWF2ZSIsIm9uQmx1ck9yRm9jdXNPdXQiLCJyZW1vdmVMaXN0ZW5lcnMiLCJfbGFzdFRyaWdnZXJFdmVudCIsInNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlIiwiaXNFdmVudExpc3RlbmVyU3RvcHBlZCIsIndhc0ZvY3VzZWQiLCJzY2hlZHVsZUhpZGUiLCJpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlciIsImdldE5lc3RlZFBvcHBlclRyZWUiLCJfaW5zdGFuY2UkcG9wcGVySW5zdGEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaG91bGRCYWlsIiwicmVsYXRlZFRhcmdldCIsImNyZWF0ZVBvcHBlckluc3RhbmNlIiwiZGVzdHJveVBvcHBlckluc3RhbmNlIiwiX2luc3RhbmNlJHByb3BzMiIsImNvbXB1dGVkUmVmZXJlbmNlIiwiY29udGV4dEVsZW1lbnQiLCJ0aXBweU1vZGlmaWVyIiwiZW5hYmxlZCIsInBoYXNlIiwicmVxdWlyZXMiLCJfcmVmMiIsIl9nZXREZWZhdWx0VGVtcGxhdGVDaCIsImF0dHJpYnV0ZXMiLCJtb2RpZmllcnMiLCJwYWRkaW5nIiwiYWRhcHRpdmUiLCJtb3VudCIsIm5leHRFbGVtZW50U2libGluZyIsIl9nZXROb3JtYWxpemVkVG91Y2hTZSIsInRvdWNoVmFsdWUiLCJ0b3VjaERlbGF5IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJuZXN0ZWRQb3BwZXIiLCJmb3JjZVVwZGF0ZSIsImlzQWxyZWFkeVZpc2libGUiLCJpc0Rpc2FibGVkIiwiaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQiLCJ2aXNpYmlsaXR5IiwidHJhbnNpdGlvbiIsIl9nZXREZWZhdWx0VGVtcGxhdGVDaDIiLCJfaW5zdGFuY2UkcG9wcGVySW5zdGEyIiwib2Zmc2V0SGVpZ2h0IiwiX2dldERlZmF1bHRUZW1wbGF0ZUNoMyIsIl9ib3giLCJfY29udGVudCIsImlzQWxyZWFkeUhpZGRlbiIsIl9nZXREZWZhdWx0VGVtcGxhdGVDaDQiLCJpIiwidGlwcHkiLCJvcHRpb25hbFByb3BzIiwiZWxlbWVudHMiLCJpc1NpbmdsZUNvbnRlbnRFbGVtZW50IiwiaXNNb3JlVGhhbk9uZVJlZmVyZW5jZUVsZW1lbnQiLCJpbnN0YW5jZXMiLCJoaWRlQWxsIiwiX3RlbXAiLCJleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UiLCJleGNsdWRlIiwiaXNFeGNsdWRlZCIsIm9yaWdpbmFsRHVyYXRpb24iLCJhcHBseVN0eWxlc01vZGlmaWVyIiwiZWZmZWN0IiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwic3RyYXRlZ3kiLCJtYXJnaW4iLCJzdHlsZXMiLCJjcmVhdGVTaW5nbGV0b24iLCJ0aXBweUluc3RhbmNlcyIsIl9vcHRpb25hbFByb3BzJHBvcHBlciIsImluZGl2aWR1YWxJbnN0YW5jZXMiLCJyZWZlcmVuY2VzIiwidHJpZ2dlclRhcmdldHMiLCJvdmVycmlkZXMiLCJpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzIiwic2hvd25PbkNyZWF0ZSIsInNldFRyaWdnZXJUYXJnZXRzIiwic2V0UmVmZXJlbmNlcyIsImVuYWJsZUluc3RhbmNlcyIsImludGVyY2VwdFNldFByb3BzIiwic2luZ2xldG9uIiwib3JpZ2luYWxTZXRQcm9wcyIsInByZXBhcmVJbnN0YW5jZSIsIm92ZXJyaWRlUHJvcHMiLCJfcmVmZXJlbmNlcyRpbmRleCIsIm9yaWdpbmFsU2hvdyIsInJlZiIsInNob3dOZXh0IiwiZmlyc3QiLCJzaG93UHJldmlvdXMiLCJsYXN0Iiwic2V0SW5zdGFuY2VzIiwibmV4dEluc3RhbmNlcyIsIkJVQkJMSU5HX0VWRU5UU19NQVAiLCJtb3VzZW92ZXIiLCJmb2N1c2luIiwiY2xpY2siLCJkZWxlZ2F0ZSIsImNoaWxkVGlwcHlJbnN0YW5jZXMiLCJkaXNhYmxlZCIsIm5hdGl2ZVByb3BzIiwicGFyZW50UHJvcHMiLCJjaGlsZFByb3BzIiwicmV0dXJuVmFsdWUiLCJub3JtYWxpemVkUmV0dXJuVmFsdWUiLCJ0YXJnZXROb2RlIiwiY2xvc2VzdCIsImFkZEV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJhcHBseU11dGF0aW9ucyIsIm9yaWdpbmFsRGVzdHJveSIsIm9yaWdpbmFsRW5hYmxlIiwib3JpZ2luYWxEaXNhYmxlIiwic2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzIiwiY3JlYXRlQmFja2Ryb3BFbGVtZW50IiwiaW5zZXJ0QmVmb3JlIiwib3ZlcmZsb3ciLCJOdW1iZXIiLCJ0cmFuc2l0aW9uRGVsYXkiLCJNYXRoIiwicm91bmQiLCJtb3VzZUNvb3JkcyIsImFjdGl2ZUluc3RhbmNlcyIsInN0b3JlTW91c2VDb29yZHMiLCJhZGRNb3VzZUNvb3Jkc0xpc3RlbmVyIiwicmVtb3ZlTW91c2VDb29yZHNMaXN0ZW5lciIsImlzSW50ZXJuYWxVcGRhdGUiLCJ3YXNGb2N1c0V2ZW50IiwiaXNVbm1vdW50ZWQiLCJnZXRJc0luaXRpYWxCZWhhdmlvciIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QiLCJpc0N1cnNvck92ZXJSZWZlcmVuY2UiLCJyZWN0IiwicmVsYXRpdmVYIiwicmVsYXRpdmVZIiwid2lkdGgiLCJoZWlnaHQiLCJjcmVhdGUiLCJkYXRhIiwiXyIsImdldFByb3BzIiwibW9kaWZpZXIiLCJfcHJvcHMkcG9wcGVyT3B0aW9ucyIsImN1cnNvclJlY3RJbmRleCIsInRyaWVkUGxhY2VtZW50cyIsIl9nZXRSZWZlcmVuY2VDbGllbnRSZWN0IiwiZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdHMiLCJzZXRJbnRlcm5hbFByb3BzIiwiYWRkTW9kaWZpZXIiLCJyZWN0cyIsImN1cnNvclJlY3QiLCJjdXJyZW50QmFzZVBsYWNlbWVudCIsImJvdW5kaW5nUmVjdCIsImNsaWVudFJlY3RzIiwiZmlyc3RSZWN0IiwibGFzdFJlY3QiLCJpc1RvcCIsIm1pbkxlZnQiLCJtaW4iLCJtYXhSaWdodCIsIm1heCIsIm1lYXN1cmVSZWN0cyIsIl90b3AiLCJfYm90dG9tIiwiX2xlZnQiLCJfcmlnaHQiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiZ2V0UmVmZXJlbmNlIiwic2hvdWxkQ2hlY2siLCJwcmV2UmVmUmVjdCIsInByZXZQb3BSZWN0IiwidXBkYXRlUG9zaXRpb24iLCJjdXJyZW50UmVmUmVjdCIsImN1cnJlbnRQb3BSZWN0IiwiYXJlUmVjdHNEaWZmZXJlbnQiLCJ1cGRhdGUiLCJyZWN0QSIsInJlY3RCIiwicm91bmRBcnJvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\n");

/***/ })

};
;